struct Package {
    root: String
    kind: Package_Kind
    dir: String = "."
    num_requirements: Int = 0
    requirements: [8]?Requirement = [ // TODO: Replace with an Arraylist
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none
    ]
    include_dirs: [8]?String = [
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
    ]
    libs: [8]?String = [
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
    ]
    lib_dirs: [8]?String = [
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
    ]
}

enum Package_Kind {
    executable
    static_library
}

struct Requirement {
    name: String
    package: &Package
}

enum Package_Source {
    relative(String)
    git(Git_Source)
}

struct Git_Source {
    url: String
    subdir: String = ""
    reference: Git_Reference = .branch("main")
}

enum Git_Reference {
    branch(String)
    tag(String)
    rev(String)
}

impl for Package {
    /// Creates an executable package
    fn executable(root: String) -> Self { Self(root, .executable, "", 0) }

    /// Creates a static library package
    fn static_library(root: String) -> Self { Self(root, .static_library, "") }

    /// Finds a package given a name
    /// NOTE: This is currently implemented as a builtin-function in the compiler
    fn find(src: Package_Source) -> &Self { _ = src; unreachable }

    /// Adds a package to the list of required packages
    fn requires(&mut self, name: String, other: &Package) {
        self.requirements[self.num_requirements] = .some(Requirement(name, other))
        self.num_requirements += 1
    }

    fn add_include_directory(&mut self, include_directory: String) {
        while let mut i = 0; i < 8; i += 1 {
            if self.include_dirs[i] == .none {
                self.include_dirs[i] = .some(include_directory)
                return
            }
        }
        unreachable // no more space!
    }

    fn add_library(&mut self, library: String) {
        // TODO: assert not static library
        while let mut i = 0; i < 8; i += 1 {
            if self.libs[i] == .none {
                self.libs[i] = .some(library)
                return
            }
        }
        unreachable // no more space!
    }

    fn add_library_directory(&mut self, library_directory: String) {
        // TODO: assert not static library
        while let mut i = 0; i < 8; i += 1 {
            if self.lib_dirs[i] == .none {
                self.lib_dirs[i] = .some(library_directory)
                return
            }
        }
        unreachable // no more space!
    }
}

type Test_Result = ()!()

trait Allocator {
    virtual fn alloc(&mut self, nbytes: Int) -> ?[*mut]Byte
    virtual fn realloc(&mut self, allocation: [*mut]Byte, newsize: Int) -> ?[*mut]Byte
    virtual fn free(&mut self, allocation: [*mut]Byte)
}

trait Writer {
    virtual fn write(&mut self, bytes: []Byte) -> ()!()
}

fn format_all(writer: &mut dyn Writer, args: []&dyn Format) -> ()!() {
    while let mut i = 0; i < args.length; i += 1 {
        let arg = args[i]
        try arg.>format(writer)
    }
    .ok
}

trait Reader {
    virtual fn read(&mut self, writer: &mut dyn Writer, limit: ?Int) -> ()!()
}

trait Format {
    virtual fn format(&self, writer: &mut dyn Writer) -> ()!()
}

impl Format for String {
    virtual fn format(&self, writer: &mut dyn Writer) -> ()!() {
        writer.>write(self^)
    }
}

trait Eq {
    fn eq(self, other: Self) -> Bool
}

impl Eq for String {
    fn eq(self, other: Self) -> Bool {
        if self.length != other.length {
            return false
        }
        while let mut i = 0; i < self.length; i += 1 {
            if self[i] != other[i] {
                return false
            }
        }
        true
    }
}

trait Hash: Eq {
    virtual fn hash(&self) -> Word64
}

impl Hash for String {
    virtual fn hash(&self) -> Word64 {
        let mut h: Word64 = 14695981039346656037
        const prime: Word64 = 1099511628211

        while let mut i = 0; i < self.length; i += 1 {
            h ~= (self[i] as Word64) * prime
        }

        h
    }
}

enum File_Mode {
    read
    write
    append
    read_and_write
}

trait File_System {
    virtual fn open(&mut self, path: String, mode: File_Mode = File_Mode.read) -> ?&mut dyn File
}

trait File: Writer + Reader {
    virtual fn close(&mut self)
}

trait Iterator {
    type Item

    fn next(&mut self) -> ?Self::Item
}

trait Into_Iterator {
    type Item
    type Iter: Iterator[Item = Self::Item]

    fn into_iter(self) -> Self::Iter
}

struct Slice_Iter[T] {
    items: []T
    pos: Int
}

impl[T] Iterator for Slice_Iter[T] {
    type Item = T
    fn next(&mut self) -> ?Self::Item {
        if self.pos >= self.items.length {
            return .none
        }
        let retval = self.items[self.pos]
        self.pos += 1
        .some(retval)
    }
}

impl[I] Into_Iterator for []I {
    type Item = I
    type Iter = Slice_Iter[I]

    fn into_iter(self) -> Self::Iter {
        Self::Iter(.items = self, .pos = 0)
    }
}

struct Range {
    start: Int
    end: Int
}

struct Range_Iter {
    range: Range
    counter: Int
}

impl Into_Iterator for Range {
    type Item = Int
    type Iter = Range_Iter

    fn into_iter(self) -> Self::Iter {
        Range_Iter(self, self.start)
    }
}

impl Iterator for Range_Iter {
    type Item = Int

    fn next(&mut self) -> ?Int {
        if self.counter == self.range.end {
            .none
        } else {
            let retval = self.counter
            self.counter += 1
            .some(retval)
        }
    }
}

context Allocating {
    alloc: &mut dyn Allocator
}

context IO {
    writer: &mut dyn Writer
    reader: &mut dyn Reader
}

context Args {
    args: []String
}

context File_IO {
    fs: &mut dyn File_System
}
