struct Package {
    root: String
    kind: Package_Kind
    dir: String = "."
    num_requirements: Int = 0
    requirements: [8]?Requirement = [ // TODO: Replace with an Arraylist
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none
    ]
    include_dirs: [8]?String = [
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
    ]
    libs: [8]?String = [
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
    ]
    lib_dirs: [8]?String = [
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
        .none,
    ]
}

enum Package_Kind {
    executable
    static_library
}

struct Requirement {
    name: String
    package: &Package
}

enum Package_Source {
    relative(String)
    git(Git_Source)
}

struct Git_Source {
    url: String
    subdir: String = ""
    reference: Git_Reference = .branch("main")
}

enum Git_Reference {
    branch(String)
    tag(String)
    rev(String)
}

impl for Package {
    /// Creates an executable package
    fn executable(root: String) -> Self { Self(root, .executable, "", 0) }

    /// Creates a static library package
    fn static_library(root: String) -> Self { Self(root, .static_library, "") }

    /// Finds a package given a name
    /// NOTE: This is currently implemented as a builtin-function in the compiler
    fn find(src: Package_Source) -> &Self { _ = src; unreachable }

    /// Adds a package to the list of required packages
    fn requires(&mut self, name: String, other: &Package) -> () {
        self.requirements[self.num_requirements] = .some(Requirement(name, other))
        self.num_requirements += 1
    }

    fn add_include_directory(&mut self, include_directory: String) -> () {
        while let mut i = 0; i < 8; i += 1 {
            if self.include_dirs[i] == .none {
                self.include_dirs[i] = .some(include_directory)
                return
            }
        }
        unreachable // no more space!
    }

    fn add_library(&mut self, library: String) -> () {
        // TODO: assert not static library
        while let mut i = 0; i < 8; i += 1 {
            if self.libs[i] == .none {
                self.libs[i] = .some(library)
                return
            }
        }
        unreachable // no more space!
    }

    fn add_library_directory(&mut self, library_directory: String) -> () {
        // TODO: assert not static library
        while let mut i = 0; i < 8; i += 1 {
            if self.lib_dirs[i] == .none {
                self.lib_dirs[i] = .some(library_directory)
                return
            }
        }
        unreachable // no more space!
    }
}

type Test_Result = ()!()

trait Allocator {
    virtual fn alloc(&mut self, nbytes: Int) -> ?[*mut]Byte
    virtual fn free(&mut self, allocation: [*]Byte) -> ()
    virtual fn resize(&mut self, allocation: [*mut]Byte, newsize: Int) -> ?[*mut]Byte
}

trait Writer {
    virtual fn write(&mut self, bytes: []Byte) -> ()
}

trait Reader {
    virtual fn read(&mut self) -> [mut]Byte
}
