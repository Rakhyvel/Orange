const std = @import("std");
const ast_ = @import("../ast/ast.zig");
const Basic_Block = @import("../ir/basic-block.zig");
const CFG = @import("../ir/cfg.zig");
const lval_ = @import("../ir/lval.zig");
const Span = @import("../util/span.zig");
const String = @import("../zig-string/zig-string.zig").String;
const Symbol = @import("../symbol/symbol.zig");

const Self = @This();

pub const String_Idx: type = struct { // TODO: Move to interned string set file
    module_uid: u32,
    string_idx: u32,
};

pub const Index: type = u32;

var instruction_uid: u64 = 0;
// TODO: Add Instruction_List struct, with some append_instruction, mark_instructions_as_removed, and get_latest_def
/// Unique identifier for this Self. Mainly used for debugging.
uid: u64,
kind: Kind,
dest: ?*lval_.L_Value,
src1: ?*lval_.L_Value,
src2: ?*lval_.L_Value,

data: Data,
next: ?*Self,
prev: ?*Self,

in_block: ?*Basic_Block,
span: Span,

removed: bool,
allocator: std.mem.Allocator,

safe: bool, // Disables static UB checks for this Self. Used for Self generated by `match`'s

pub fn init(
    kind: Kind,
    dest: ?*lval_.L_Value,
    src1: ?*lval_.L_Value,
    src2: ?*lval_.L_Value,
    span: Span,
    allocator: std.mem.Allocator,
) *Self {
    var retval = allocator.create(Self) catch unreachable;
    retval.kind = kind;
    retval.dest = dest;
    retval.src1 = src1;
    retval.src2 = src2;
    retval.uid = instruction_uid;
    retval.in_block = null;
    retval.prev = null;
    retval.next = null;
    retval.data = Data.none;
    retval.span = span;
    retval.allocator = allocator;
    instruction_uid += 1;
    return retval;
}

pub fn init_int(dest: *lval_.L_Value, int: i128, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.load_int, dest, null, null, span, allocator);
    retval.data = Data{ .int = int };
    return retval;
}

pub fn init_float(dest: *lval_.L_Value, float: f64, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.load_float, dest, null, null, span, allocator);
    retval.data = Data{ .float = float };
    return retval;
}

pub fn init_string(dest: *lval_.L_Value, id: String_Idx, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.load_string, dest, null, null, span, allocator);
    retval.data = Data{ .string_id = id };
    return retval;
}

pub fn init_ast(dest: *lval_.L_Value, ast: *ast_.AST, span: Span, allocator: std.mem.Allocator) *Self {
    const retval = Self.init(.load_AST, dest, null, null, span, allocator);
    retval.data = Data{ .ast = ast };
    return retval;
}

pub fn init_simple_copy(dest: *lval_.L_Value, src: *lval_.L_Value, span: Span, allocator: std.mem.Allocator) *Self {
    const instr = Self.init(.copy, dest, src, null, span, allocator);
    return instr;
}

pub fn init_label(cfg: ?*CFG, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.label, null, null, null, span, allocator);
    retval.data = Data{ .cfg = cfg };
    return retval;
}

pub fn init_branch(condition: *lval_.L_Value, label: ?*Self, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.branch_if_false, null, condition, null, span, allocator);
    retval.data = Data{ .branch = label };
    return retval;
}

pub fn init_jump(label: ?*Self, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.jump, null, null, null, span, allocator);
    retval.data = Data{ .branch = label };
    return retval;
}

pub fn init_jump_addr(next: ?*Basic_Block, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.jump, null, null, null, span, allocator);
    retval.data = Data{ .jump_bb = .{ .next = next } };
    return retval;
}

pub fn init_branch_addr(
    condition: *lval_.L_Value,
    next: ?*Basic_Block,
    branch: ?*Basic_Block,
    span: Span,
    allocator: std.mem.Allocator,
) *Self {
    var retval = Self.init(.branch_if_false, null, condition, null, span, allocator);
    retval.data = Data{ .branch_bb = .{ .next = next, .branch = branch } };
    return retval;
}

pub fn init_call(dest: *lval_.L_Value, src1: *lval_.L_Value, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.call, dest, src1, null, span, allocator);
    retval.data = Data{ .lval_list = std.ArrayList(*lval_.L_Value).init(allocator) };
    return retval;
}

pub fn init_invoke(dest: *lval_.L_Value, method_decl: *ast_.AST, lval_list: std.ArrayList(*lval_.L_Value), dyn_value: ?*lval_.L_Value, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.invoke, dest, null, null, span, allocator);
    retval.data = Data{
        .invoke = .{
            .method_decl = method_decl,
            .lval_list = lval_list,
            .dyn_value = dyn_value,
            .method_decl_lval = null, // Filled in later
        },
    };
    return retval;
}

pub fn init_dyn(dest: *lval_.L_Value, src1: *lval_.L_Value, mut: bool, impl: *ast_.AST, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(if (mut) .mut_dyn_value else .dyn_value, dest, src1, null, span, allocator);
    retval.data = Data{ .dyn = .{ .impl = impl } };
    return retval;
}

pub fn init_load_struct(dest: *lval_.L_Value, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.load_struct, dest, null, null, span, allocator);
    retval.data = Data{ .lval_list = std.ArrayList(*lval_.L_Value).init(allocator) };
    return retval;
}

pub fn init_get_tag(dest: *lval_.L_Value, src1: *lval_.L_Value, span: Span, allocator: std.mem.Allocator) *Self {
    const retval = Self.init(.get_tag, dest, src1, null, span, allocator);
    return retval;
}

pub fn init_union(dest: *lval_.L_Value, _init: ?*lval_.L_Value, tag: i128, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.load_union, dest, _init, null, span, allocator);
    retval.data = Data{ .int = tag };
    return retval;
}

pub fn init_stack_push(span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.push_stack_trace, null, null, null, span, allocator);
    retval.data = Data.none;
    return retval;
}

pub fn init_stack_pop(span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.pop_stack_trace, null, null, null, span, allocator);
    retval.data = Data.none;
    return retval;
}

pub fn init_panic(message: []const u8, span: Span, allocator: std.mem.Allocator) *Self {
    var retval = Self.init(.panic, null, null, null, span, allocator);
    retval.data = Data{ .string = message };
    return retval;
}

pub fn init_int_float_kind(
    int_kind: Kind,
    float_kind: Kind,
    dest: ?*lval_.L_Value,
    src1: ?*lval_.L_Value,
    src2: ?*lval_.L_Value,
    span: Span,
    allocator: std.mem.Allocator,
) *Self {
    if (src1.?.get_expanded_type().can_represent_float()) {
        return init(float_kind, dest, src1, src2, span, allocator);
    } else {
        return init(int_kind, dest, src1, src2, span, allocator);
    }
}

pub fn deinit(self: *Self) void {
    if (self.dest != null) {
        self.dest.?.deinit();
    }
    self.allocator.destroy(self);
}

pub fn get_tail(self: *Self) *Self {
    var mut_self: *Self = self;
    while (mut_self.next != null) : (mut_self = mut_self.next.?) {}
    return mut_self;
}

/// Snips the Self linked list in two, with this Self being the end of the list, and the next Self (if any) being the head
/// of the new linked list.
pub fn snip(self: *Self) void {
    if (self.next) |_| {
        self.next.?.prev = null;
        self.next = null;
    }
}

pub fn pprint(self: Self, allocator: std.mem.Allocator) ![]const u8 {
    var out = String.init(allocator);
    defer out.deinit();

    switch (self.kind) {
        .label => try out.writer().print("BB{}:\n", .{self.uid}),
        .load_int => {
            try out.writer().print("    {} := {}\n", .{ self.dest.?, self.data.int });
        },
        .load_float => {
            try out.writer().print("    {} := {}\n", .{ self.dest.?, self.data.float });
        },
        .load_symbol => {
            try out.writer().print("    {} := {s}\n", .{ self.dest.?, self.data.symbol.name });
        },
        .load_struct => {
            try out.writer().print("    {} := {{", .{self.dest.?});
            try print_lval_list(self.data.lval_list, out.writer());
            try out.writer().print("}}\n", .{});
        },
        .load_union => {
            // init may be null, if it is unit
            try out.writer().print("    {} := {{init={?}, tag={}}}\n", .{ self.dest.?, self.src1, self.data.int });
        },
        .load_string => {
            try out.writer().print("    {} := <interned string:{}>\n", .{ self.dest.?, self.data.string_id });
        },
        .load_AST => {
            try out.writer().print("    {} := AST({})\n", .{ self.dest.?, self.data.ast });
        },
        .load_unit => {
            try out.writer().print("    {} := {{}}\n", .{self.dest.?});
        },
        .copy => {
            try out.writer().print("    {} := {?}\n", .{ self.dest.?, self.src1 });
        },
        .not => {
            try out.writer().print("    {} := !{}\n", .{ self.dest.?, self.src1.? });
        },
        .negate_int => {
            try out.writer().print("    {} := -{}\n", .{ self.dest.?, self.src1.? });
        },
        .negate_float => {
            try out.writer().print("    {} := -.{}\n", .{ self.dest.?, self.src1.? });
        },
        .size_of => {
            try out.writer().print("    {} := sizeof({})\n", .{ self.dest.?, self.src1.? });
        },
        .addr_of => {
            try out.writer().print("    {} := &{}\n", .{ self.dest.?, self.src1.? });
        },
        .mut_addr_of => {
            try out.writer().print("    {} := &mut {}\n", .{ self.dest.?, self.src1.? });
        },
        .equal => {
            try out.writer().print("    {} := {} == {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .not_equal => {
            try out.writer().print("    {} := {} != {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .greater_int => {
            try out.writer().print("    {} := {} > {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .greater_float => {
            try out.writer().print("    {} := {} >. {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .lesser_int => {
            try out.writer().print("    {} := {} < {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .lesser_float => {
            try out.writer().print("    {} := {} <. {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .greater_equal_int => {
            try out.writer().print("    {} := {} >= {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .greater_equal_float => {
            try out.writer().print("    {} := {} >=. {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .lesser_equal_int => {
            try out.writer().print("    {} := {} <= {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .lesser_equal_float => {
            try out.writer().print("    {} := {} <=. {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .add_int => {
            try out.writer().print("    {} := {} + {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .add_float => {
            try out.writer().print("    {} := {} +. {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .sub_int => {
            try out.writer().print("    {} := {} - {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .sub_float => {
            try out.writer().print("    {} := {} -. {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .mult_int => {
            try out.writer().print("    {} := {} * {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .mult_float => {
            try out.writer().print("    {} := {} *. {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .div_int => {
            try out.writer().print("    {} := {} / {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .div_float => {
            try out.writer().print("    {} := {} /. {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .mod => {
            try out.writer().print("    {} := {} % {}\n", .{ self.dest.?, self.src1.?, self.src2.? });
        },
        .get_tag => {
            try out.writer().print("    {} := {}.tag\n", .{ self.dest.?, self.src1.? });
        },
        .jump => {
            if (self.data == .jump_bb and self.data.jump_bb.next != null) {
                try out.writer().print("    jump BB{}\n", .{self.data.jump_bb.next.?.uid});
            } else {
                try out.writer().print("    ret\n", .{});
            }
        },
        .branch_if_false => {
            if (self.data == .branch_bb and self.data.branch_bb.next != null) {
                try out.writer().print("    if ({}) jump BB{}", .{ self.src1.?, self.data.branch_bb.next.?.uid });
            } else {
                try out.writer().print("    if ({}) ret", .{self.src1.?});
            }
            try out.writer().print(" ", .{});
            if (self.data == .branch_bb and self.data.branch_bb.branch != null) {
                try out.writer().print("else jump BB{}\n", .{self.data.branch_bb.branch.?.uid});
            } else {
                try out.writer().print("else ret\n", .{});
            }
        },
        .call => {
            try out.writer().print("    {} := {}(", .{ self.dest.?, self.src1.? });
            try print_lval_list(self.data.lval_list, out.writer());
            try out.writer().print(")\n", .{});
        },
        .invoke => {
            try out.writer().print("    {} := ::{s}(", .{ self.dest.?, self.data.invoke.method_decl.method_decl.name.token().data });
            try print_lval_list(self.data.invoke.lval_list, out.writer());
            try out.writer().print(")\n", .{});
        },
        .push_stack_trace => {
            try out.writer().print("    push-stack-trace\n", .{});
        },
        .pop_stack_trace => {
            try out.writer().print("    pop-stack-trace\n", .{});
        },
        .panic => {
            try out.writer().print("    panic\n", .{});
        },
        else => {
            try out.writer().print("<TODO: {s}>\n", .{@tagName(self.kind)});
        },
    }

    return (try out.toOwned()).?;
}

pub fn format(self: Self, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
    _ = options;
    _ = fmt;
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    const out = self.pprint(arena.allocator()) catch unreachable;

    // TODO: Generic pprinter that makes the arena and string and passes the writer to a pprint method

    try writer.print("{s}", .{out});
}

fn print_lval_list(
    lval_list: std.ArrayList(*lval_.L_Value),
    writer: anytype,
) !void {
    for (lval_list.items, 0..) |lval, i| {
        try writer.print("{}", .{lval});
        if (i < lval_list.items.len - 1) {
            try writer.print(", ", .{});
        }
    }
}

/// This function is O(n) in terms of Self between start and stop
pub fn get_latest_def_after(start_at_instr: *Self, symbol: *Symbol, stop_at_instr: ?*Self) ?*Self {
    var maybe_instr: ?*Self = start_at_instr;
    var retval: ?*Self = null;
    while (maybe_instr != null and maybe_instr != stop_at_instr) : (maybe_instr = maybe_instr.?.next) {
        var instr: *Self = maybe_instr.?;
        if (instr.dest != null and instr.dest.?.* == .select and instr.dest.?.extract_symbver().symbol == symbol) {
            return null;
        } else if (instr.dest != null and instr.dest.?.* == .index and instr.dest.?.extract_symbver().symbol == symbol) {
            return null;
        } else if (instr.dest != null and instr.dest.?.* == .symbver and instr.dest.?.symbver.symbol == symbol) {
            retval = instr;
        } else if (instr.kind == .mut_addr_of and instr.src1.?.extract_symbver().symbol == symbol) {
            retval = null;
        }
    }
    return retval;
}

// This function is O(n)
pub fn any_def_after(start_at_instr: *Self, symbol: *Symbol, stop_at_instr: ?*Self) ?*Self {
    var maybe_instr: ?*Self = start_at_instr;
    while (maybe_instr != null and maybe_instr != stop_at_instr) : (maybe_instr = maybe_instr.?.next) {
        var instr: *Self = maybe_instr.?;
        if (instr.dest != null and instr.dest.?.* == .select and instr.dest.?.extract_symbver().symbol == symbol) {
            return instr;
        } else if (instr.dest != null and instr.dest.?.* == .index and instr.dest.?.extract_symbver().symbol == symbol) {
            return instr;
        } else if (instr.kind == .mut_addr_of and instr.src1.?.extract_symbver().symbol == symbol) {
            return instr;
        } else if (instr.dest != null and instr.dest.?.* == .symbver and instr.dest.?.symbver.symbol == symbol) {
            return instr;
        }
    }
    return null;
}

pub const Kind = enum {
    // nullary instructions
    load_symbol,
    load_extern,
    load_int,
    load_float,
    load_struct,
    load_union, // src1 is init, data.int is tag id
    load_string,
    load_AST,
    load_unit, // no-op, but required. DO NOT optimize away

    // Monadic instructions
    copy,
    not,
    negate_int,
    negate_float,
    bit_not,
    size_of, //< For extern types that Orng can't do automatically
    addr_of,
    mut_addr_of, // Separate kind to allow for aliasing analysis
    dyn_value,
    mut_dyn_value, // Separate kind to allow for aliasing analysis

    // Diadic instructions
    equal,
    not_equal,
    greater_int,
    greater_float,
    lesser_int,
    lesser_float,
    greater_equal_int,
    greater_equal_float,
    lesser_equal_int,
    lesser_equal_float,
    bit_and,
    bit_or,
    bit_xor,
    left_shift,
    right_shift,
    add_int,
    add_float,
    sub_int,
    sub_float,
    mult_int,
    mult_float,
    div_int,
    div_float,
    mod,
    get_tag, // dest = src1.tag
    cast,

    // Control-flow
    label,
    jump, // jump to BB{uid} if codegen, ip := {addr} if interpreting
    branch_if_false,
    call, // dest = src1(symbver_list...)
    invoke, // dest = {impl-vtable}.{method_name}(symbver_list...)

    // Errors
    push_stack_trace, // Pushes a static span/code to the lines array if debug mode is on
    pop_stack_trace, // Pops a message off the stack after a function is successfully called
    panic, // if debug mode is on, panics with a message, unrolls lines stack, exits

    pub fn is_checked(self: Kind) bool {
        return switch (self) {
            .negate_int,
            .add_int,
            .sub_int,
            .mult_int,
            .div_int,
            .mod,
            => true,
            else => false,
        };
    }

    pub fn checked_name(self: Kind) []const u8 {
        return switch (self) {
            .negate_int => "negate",
            .add_int => "add",
            .sub_int => "sub",
            .mult_int => "mult",
            .div_int => "div",
            .mod => "mod",
            else => unreachable,
        };
    }

    pub fn c_token(self: Kind) []const u8 {
        return switch (self) {
            .not => "!",
            .bit_not => "~",
            .negate_int, .negate_float => "-",
            .equal => "==",
            .not_equal => "!=",
            .greater_int, .greater_float => ">",
            .lesser_int, .lesser_float => "<",
            .greater_equal_int, .greater_equal_float => ">=",
            .lesser_equal_int, .lesser_equal_float => "<=",
            .add_int, .add_float => "+",
            .sub_int, .sub_float => "-",
            .mult_int, .mult_float => "*",
            .div_int, .div_float => "/",
            .mod => "%",
            .bit_and => "&",
            .bit_or => "|",
            .bit_xor => "^",
            .left_shift => "<<",
            .right_shift => ">>",
            else => unreachable,
        };
    }

    pub fn arity(self: Kind) enum { unop, binop } {
        return switch (self) {
            .not, .negate_int, .negate_float, .bit_not => .unop,
            .equal,
            .not_equal,
            .greater_int,
            .greater_float,
            .lesser_int,
            .lesser_float,
            .greater_equal_int,
            .greater_equal_float,
            .lesser_equal_int,
            .lesser_equal_float,
            .add_int,
            .add_float,
            .sub_int,
            .sub_float,
            .mult_int,
            .mult_float,
            .div_int,
            .div_float,
            .mod,
            .bit_and,
            .bit_or,
            .bit_xor,
            .left_shift,
            .right_shift,
            => .binop,
            else => unreachable,
        };
    }

    pub fn precedence(self: Kind) i64 {
        return switch (self) {
            .load_symbol,
            .load_extern,
            .load_int,
            .load_float,
            .load_struct,
            .load_union,
            .load_string,
            => 0,

            .call,
            .get_tag,
            => 1,

            .negate_int,
            .negate_float,
            .not,
            .bit_not,
            .size_of,
            .cast,
            .mut_addr_of,
            .addr_of,
            .mut_dyn_value,
            .dyn_value,
            => 2,

            .mult_int,
            .mult_float,
            .div_int,
            .div_float,
            .mod,
            => 3,

            .add_int,
            .add_float,
            .sub_int,
            .sub_float,
            => 4,

            .bit_and, .bit_or, .bit_xor, .left_shift, .right_shift => 5,

            .greater_int,
            .greater_float,
            .lesser_int,
            .lesser_float,
            .greater_equal_int,
            .greater_equal_float,
            .lesser_equal_int,
            .lesser_equal_float,
            => 6,

            .equal,
            .not_equal,
            => 7,

            .copy => 14,

            else => std.debug.panic("compiler error: unimplemented precedence for kind {s}", .{@tagName(self)}),
        };
    }
};

pub const Data = union(enum) {
    branch: ?*Self,
    jump_bb: struct { next: ?*Basic_Block },
    branch_bb: struct { next: ?*Basic_Block, branch: ?*Basic_Block },
    int: i128,
    float: f64,
    string_id: String_Idx,
    cfg: ?*CFG, // Used by the interpreter to know how much space to leave for a CFGs locals
    string: []const u8,
    symbol: *Symbol,
    lval_list: std.ArrayList(*lval_.L_Value),
    invoke: struct {
        method_decl: *ast_.AST, // AST of method decl. Either trait's definition if dyn, or impl's declaration if static
        method_decl_lval: ?*lval_.L_Value, // L-value of the method; non-null when statically known (ie not dyn)
        lval_list: std.ArrayList(*lval_.L_Value), // List of args. Receiver will always be prepended
        dyn_value: ?*lval_.L_Value, // L-value of the vtable-data-ptr pair; non-null when the call is through a vtable, regardless of if the method uses the receiver
    },
    dyn: struct { impl: *ast_.AST },
    select: struct { offset: i128, field: i128 },
    ast: *ast_.AST,
    none,

    pub fn pprint(self: Data, allocator: std.mem.Allocator) ![]const u8 {
        var out = String.init(allocator);
        defer out.deinit();

        switch (self) {
            .int => {
                try out.writer().print("{}", .{self.int});
            },
            .float => {
                try out.writer().print("{d:.6}", .{self.float});
            },
            .none => {
                try out.writer().print("none", .{});
            },
            .symbol => {
                try out.writer().print("{s}", .{self.symbol.name});
            },
            .string_id => {
                try out.writer().print("<interned string:{}>", .{self.string_id});
            },
            else => {
                try out.writer().print("??? ({s})", .{@tagName(self)});
            },
        }

        return (try out.toOwned()).?;
    }

    pub fn format(self: Data, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = options;
        _ = fmt;
        var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
        defer arena.deinit();

        // TODO: Generic pprinter that makes the arena and string and passes the writer to a pprint method
        const out = self.pprint(arena.allocator()) catch unreachable;

        try writer.print("{s}", .{out});
    }

    pub fn equals(self: Data, other: Data) bool {
        if (self == .branch and other == .branch) {
            return self.branch == other.branch;
        } else if (self == .int and other == .int) {
            return self.int == other.int;
        } else if (self == .float and other == .float) {
            return self.float == other.float;
        } else if (self == .int and other == .float) {
            return self.int == @as(i128, @intFromFloat(other.float)); // These will crash if float is not representable by i128
        } else if (self == .float and other == .int) { //                This should not be a problem with user-generated code, since it's type-checked
            return @as(i128, @intFromFloat(self.float)) == other.int; // But keep it in mind for compiler-generated code generated after type-checking, such as defaults
        } else if (self == .string_id and other == .string_id) {
            return self.string_id == other.string_id;
        } else if (self == .string and other == .string) {
            return std.mem.eql(u8, self.string, other.string);
        } else if (self == .symbol and other == .symbol) {
            return self.symbol == other.symbol;
        } else {
            return false; // tags are mismatched
        }
    }

    // TODO: Fix these when removing i128

    pub fn add_int_overflow(self: Data, other: Data) error{CompileError}!Data {
        return Data{
            .int = std.math.add(i128, self.int, other.int) catch unreachable,
        };
    }

    pub fn sub_int_overflow(self: Data, other: Data) error{CompileError}!Data {
        return Data{
            .int = std.math.sub(i128, self.int, other.int) catch unreachable,
        };
    }

    pub fn mult_int_overflow(self: Data, other: Data) error{CompileError}!Data {
        return Data{
            .int = std.math.mul(i128, self.int, other.int) catch unreachable,
        };
    }
};
