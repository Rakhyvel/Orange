import std
<<<<<<< HEAD
// define a symbol called `externs`, which refers to a module symbol externs.orng
// if you're looking to resolve `externs`, then look for `externs.orng`
import externs
// define a symbol called `debug`, which refers to a module symbol std::debug
// if you're looking to resolve `debug`, then find `std::debug`
import std::debug

fn main() -> () {
    let mut x: Int = 45
    _ = x
    
    // find println in externs
    // externs is an import, it refers to externs.orng module
    // find println in externs.orng module
    // externs::println refers to the (externs.orng)::println symbol
    externs::println("Hello, ")
    
    // find println in debug
    // what does debug refer to? import symbol
    // what import symbol? import symbol: std::debug
    // what does std refer to? import symbol
    // what import symbol? module symbol: std/lib.orng
    // is there a debug symbol in the child scope of `std/lib.orng`? yes
    debug::println("World!")

    // there must be module symbols
    // they must refer to their child scope, somehow
    // perhaps their init is a special `module` ast, contains the scope
    // Module struct refers to this symbol, rather than the scope. The scope can be acquired indirectly
=======
import externs
// import core // imported by std, this is what we want to prevent

fn main() -> () {
    externs::println("Hello, ")
    std::println("World!")
>>>>>>> origin/main
}
