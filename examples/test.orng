fn main: (sys: System)->!() =
    sys.out.>println("Hello, World!")

// One-liner factorial function!
fn factorial: (n: Int)->Int = if n < 2 {1} else {n * fact(n - 1)}

const FizzBuzzResult 
    = string: String
    | integer: Int

fn fizzbuzz: (n: Int)->FizzBuzzResult =
    cond
    | n % 15 == 0 => FizzBuzzResult.string("fizzbuzz");
    //               ^^^^^^^^^^^^^^
    // We can either be explicit with the ADT we use...
    | n % 5 == 0  => .string("buzz");
    //              ^
    // ... Or we can let it be inferred, if possible
    | n % 3 == 0  => .string("fizz");
    | else        => .integer(n);

fn main: (sys: System)->!() =
    while let i = 0; i < 100; i += 1
        case fizzbuzz(i)
        | .string(s')  => try sys.out.>println("{}", s');
        | .integer(j') => try sys.out.>println("{}", j');

// Function that works for any type `T'` in the `Eq` type-class
fn contains: (haystack: []T', needle: T')->Bool
where T' < Eq =
    cond 
    | haystack.len == 0     => false;
    | haystack[0] == needle => true;
    | else                  => contains(haystack[1..], needle);


