# https://github.com/proebsting/rdgen
# used just to check for ambiguity
# python3.11 src/rdgen/main.py create --input docs/orng.ebnf --output parser.py && grep "AMBIGUOUS" parser.py

program: top_level_declaration {"newline" top_level_declaration} "eof".

top_level_declaration: fn_declaration 
                     | let_declaration
                     .

let_declaration: "let" let_pattern_atom (":" arrowExpr ["=" expr] | "=" expr).

let_pattern_product: let_pattern_atom {"," let_pattern_atom}.
let_pattern_atom: ["mut" | "const"] ident
                | "(" let_pattern_product ")"
                .

statement: let_declaration
         | "defer" (expr | let_declaration)
         | "errdefer" (expr | let_declaration)
         | expr
         .

expr: caseMatchExpr
    | sumExpr
    .

sumExpr: productExpr {"|" annotExpr}. # (lhs of | must be ident or annotExpr with proper pattern left of the :)

productExpr: annotExpr {"," annotExpr}.

annotExpr: assignExpr [":" arrowExpr ["where" arrowExpr] ["=" arrowExpr]]. # (lhs of : must be ident or other TBD patterns)

assignExpr: "_" "=" assignExpr
          | arrowExpr [("=" | "+=" | "-=" | "*=" | "/=" | "%=" | "**=" | "<-") assignExpr]
          .

arrowExpr: boolExpr {"->" boolExpr}.

boolExpr: conditionalExpr {("and" | "or") conditionalExpr}.

conditionalExpr: deltaExpr {("==" | "!=" | "<" | "<=" | ">" | ">=") deltaExpr}.

deltaExpr: coalesceExpr {">>" coalesceExpr}. # (rhs must be a call expr)

coalesceExpr: intExpr {("orelse" | "catch") intExpr}.

intExpr: termExpr {("+" | "-" | "!") termExpr}.

termExpr: prefixExpr {("*" | "/" | "%" | "<>" | "||") prefixExpr}.

prefixExpr: "not" hyperExpr                         # boolean not
          | "-" hyperExpr                           # negation
          | "&" ["mut"] prefixExpr                  # address-of
          | "[" ["mut" | expr | "*"] "]" prefixExpr # slice-of/tuple-of/multi-pointer
          | "?" hyperExpr                           # optional
          | hyperExpr
          .

hyperExpr: postfixExpr {(".>" | "**") postfixExpr}.

postfixExpr: factor {parens | ("[" ((".."[expr]) | (expr[".." [expr]])) "]") | ("." ident) | ("^")}.

factor: ident
      | "true"
      | "false"
      | int
      | hex
      | octal
      | bin
      | float
      | char
      | string
      | blockExpr
      | ifExpr
      | whileExpr
      | forExpr
      | fn_declaration
      | "unreachable"
      | "." ident
      | parens
      .

indentBlockExpr: indent { statement "newline" } [("return" [expr] "newline") | ("continue" "newline") | ("break" "newline")] dedent.
braceBlockExpr: "{" [ statement { ";" statement } ] [("return" [expr]) | ("continue") | ("break")] "}".
blockExpr: indentBlockExpr | braceBlockExpr.

ifExpr: "if" [let_declaration ";"] expr blockExpr ["else" blockExpr].

whileExpr: "while" [let_declaration ";"] expr [";" statement ] blockExpr ["else" blockExpr].

forExpr: "for" ["mut"] ident "in" expr blockExpr ["else" blockExpr]. # TODO: Perhaps specify type of element?

fn_declaration: "fn" [ident] paramlist "->" ["!"] arrowExpr ["where" arrowExpr] blockExpr.
paramlist: "(" [param {"," param}] ")".
param: let_pattern_atom ":" arrowExpr ["=" arrowExpr]. # must not be productExpr, or ambiguous with ,

caseMatchExpr: "case" caseExpr
             | "match" matchExpr
             .

caseExpr: [let_declaration ";"] caseBarList.
caseBarList: "|" caseBarListMiddle.
caseBarListMiddle: caseBarClause ["|" (caseBarElse | caseBarListMiddle)].
caseBarClause: annotExpr ["=>" annotExpr].
caseBarElse: "else" "=>" annotExpr.

matchExpr: [let_declaration ";"] productExpr matchBarList.
matchBarList: "|" matchBarListMiddle.
matchBarListMiddle: matchBarClause ["|" (matchBarElse | matchBarListMiddle)].
matchBarClause: match_pattern_brace "=>" annotExpr.
matchBarElse: "else" "=>" annotExpr.

match_pattern_product: match_pattern_inject {"," match_pattern_inject}.
match_pattern_inject: match_pattern_atom ["<-" match_pattern_atom].
match_pattern_atom: ["mut"] ident {"." ident} # ident if part of a dot, symbol otherwise
                  | "true"
                  | "false"
                  | int
                  | hex
                  | octal
                  | bin
                  | float
                  | char
                  | string
                  | braceBlockExpr
                  | "." ident
                  | "(" match_pattern_product ")"
                  .


parens: "(" [expr] ")". # ABSOLUTELY needs to be `"(" expr ")"` so that you can put exprs in parens