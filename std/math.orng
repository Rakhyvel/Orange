cinclude "../math.h"

import testing

impl for Float {
    fn is_nan(self) -> Bool {
        self != self
    }

    fn is_inf(self) -> Bool {
        let bits = self.>as_bits()
        let exp = @bit_and(@right_shift(bits, 52), 0x7FF)
        let mant = @bit_and(bits, 0xFFFFFFFFFFFFF)

        exp == 0x7FF and mant == 0
    }

    fn is_finite(self) -> Bool {
        not self.>is_inf()
    }

    fn as_bits(self) -> Word64 {
        enum Float_Or_Bits_Tagged {
            float(Float)
            bits(Word64)
        }
        type Float_Or_Bits = @Untagged(Float_Or_Bits_Tagged)
        let mut retval: Float_Or_Bits = undefined
        retval.float = self
        retval.bits
    }

    fn near(self, other: Float, epsilon: Float = 0.00001) -> Bool {
        (self - other).>abs() <= epsilon
    }

    fn floor(self) -> Float {
        extern("floor") const c_floor: Float -> Float
        c_floor(self)
    }

    fn ceil(self) -> Float {
        extern("ceil") const c_ceil: Float -> Float
        c_ceil(self)
    }

    fn round(self) -> Float {
        extern("round") const c_round: Float -> Float
        c_round(self)
    }

    fn trunc(self) -> Float {
        extern("trunc") const c_trunc: Float -> Float
        c_trunc(self)
    }

    fn fract(self) -> Float {
        self - self.>trunc()
    }

    fn pow(self, exponent: Float) -> Float {
        extern("pow") const c_pow: (Float, Float) -> Float
        c_pow(self, exponent)
    }

    fn sqrt(self) -> Float {
        extern("sqrt") const c_sqrt: Float -> Float
        c_sqrt(self)
    }

    fn cbrt(self) -> Float {
        extern("cbrt") const c_cbrt: Float -> Float
        c_cbrt(self)
    }

    // exp, ln, log10, log2, log
    // sin, cos, tan
    // asin, acos, atan, atan2
    // sinh, cosh, tanh
    // asinh, acosh, atanh
    // min, max, clamp, abs, signum, sign, copysign, recip, is_sign_positive, is_sign_negative
    fn abs(self) -> Float {
        extern("fabs") const fabs: Float -> Float
        fabs(self)
    }
}

impl for Int {
    // min, max, clamp, abs, signum, sign, copysign
}

fn as_int(x: Float) -> Int {
    extern const as_int_helper: Float -> Int
    as_int_helper(x)
}

fn as_float(x: Int) -> Float {
    extern const as_float_helper: Int -> Float
    as_float_helper(x)
}

test "as_bits" {
    let x = 1.0

    let bits = x.>as_bits()
    try testing::expect(bits == 0x3FF0000000000000)

    .ok
}

test "is_nan" {
    let x = 0.0 / 0.0

    try testing::expect(x.>is_nan())

    .ok
}

test "is_inf" {
    let x = 1.0 / 0.0

    try testing::expect(x.>is_inf())

    .ok
}

test "floor" {
    try testing::expect(14.5.>floor() == 14.0)
    try testing::expect((-14.5).>floor() == -15.0)
    .ok
}

test "ceil" {
    try testing::expect(14.5.>ceil() == 15.0)
    try testing::expect((-14.5).>ceil() == -14.0)
    .ok
}

test "round" {
    try testing::expect(5.0.>round() == 5.0)
    try testing::expect(-5.0.>round() == -5.0)
    try testing::expect(1.2.>round() == 1.0)
    try testing::expect(-1.2.>round() == -1.0)
    try testing::expect(1.7.>round() == 2.0)
    try testing::expect(-1.7.>round() == -2.0)
    try testing::expect(1.5.>round() == 2.0)
    try testing::expect(-1.5.>round() == -2.0)
    .ok
}

test "trunc" {
    try testing::expect(1.7.>trunc() == 1.0)
    try testing::expect(-1.7.>trunc() == -1.0)
    try testing::expect(3.2.>trunc() == 3.0)
    .ok
}

test "fract" {
    try testing::expect(3.5.>fract() == 0.5)
    try testing::expect(-3.5.>fract() == -0.5)
    try testing::expect(-5.0.>fract() == -0.0)
    .ok
}

test "Float::pow" {
    try testing::expect(2.0.>pow(10.0) == 1024.0)
    .ok
}

test "Float::sqrt" {
    try testing::expect(9.0.>sqrt() == 3.0)
    .ok
}

test "Float::cbrt" {
    try testing::expect(Float::near((-27.0).>cbrt(), -3.0))
    .ok
}