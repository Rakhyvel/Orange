cinclude "../math.h"

import testing

impl for Float {
    fn is_nan(self) -> Bool {
        self != self
    }

    fn is_inf(self) -> Bool {
        let bits = self.>as_bits()
        let exp = @bit_and(@right_shift(bits, 52), 0x7FF)
        let mant = @bit_and(bits, 0xFFFFFFFFFFFFF)

        exp == 0x7FF and mant == 0
    }

    fn is_finite(self) -> Bool {
        not self.>is_inf()
    }

    fn as_bits(self) -> Word64 {
        enum Float_Or_Bits_Tagged {
            float(Float)
            bits(Word64)
        }
        type Float_Or_Bits = @Untagged(Float_Or_Bits_Tagged)
        let mut retval: Float_Or_Bits = undefined
        retval.float = self
        retval.bits
    }

    fn near(self, other: Float, epsilon: Float = 0.00001) -> Bool {
        (self - other).>abs() <= epsilon
    }

    fn floor(self) -> Float {
        extern("floor") const c_floor: Float -> Float
        c_floor(self)
    }

    fn ceil(self) -> Float {
        extern("ceil") const c_ceil: Float -> Float
        c_ceil(self)
    }

    fn round(self) -> Float {
        extern("round") const c_round: Float -> Float
        c_round(self)
    }

    fn trunc(self) -> Float {
        extern("trunc") const c_trunc: Float -> Float
        c_trunc(self)
    }

    fn fract(self) -> Float {
        self - self.>trunc()
    }

    fn pow(self, exponent: Float) -> Float {
        extern("pow") const c_pow: (Float, Float) -> Float
        c_pow(self, exponent)
    }

    fn sqrt(self) -> Float {
        extern("sqrt") const c_sqrt: Float -> Float
        c_sqrt(self)
    }

    fn cbrt(self) -> Float {
        extern("cbrt") const c_cbrt: Float -> Float
        c_cbrt(self)
    }

    fn exp(self) -> Float {
        extern("exp") const c_exp: Float -> Float
        c_exp(self)
    }

    fn exp2(self) -> Float {
        extern("exp2") const c_exp2: Float -> Float
        c_exp2(self)
    }

    fn log(self) -> Float {
        extern("log") const c_log: Float -> Float
        c_log(self)
    }

    fn log2(self) -> Float {
        extern("log2") const c_log2: Float -> Float
        c_log2(self)
    }

    fn log10(self) -> Float {
        extern("log10") const c_log10: Float -> Float
        c_log10(self)
    }

    // sin, cos, tan
    // asin, acos, atan, atan2
    // sinh, cosh, tanh
    // asinh, acosh, atanh
    // min, max, clamp, abs, signum, sign, copysign, recip, is_sign_positive, is_sign_negative
    fn abs(self) -> Float {
        extern("fabs") const fabs: Float -> Float
        fabs(self)
    }
}

impl for Int {
    // min, max, clamp, abs, signum, sign, copysign
}

fn as_int(x: Float) -> Int {
    extern const as_int_helper: Float -> Int
    as_int_helper(x)
}

fn as_float(x: Int) -> Float {
    extern const as_float_helper: Int -> Float
    as_float_helper(x)
}

test "as_bits" {
    let x = 1.0

    let bits = x.>as_bits()
    try testing::expect(bits == 0x3FF0000000000000)

    .ok
}

test "is_nan" {
    let x = 0.0 / 0.0

    try testing::expect(x.>is_nan())

    .ok
}

test "is_inf" {
    let x = 1.0 / 0.0

    try testing::expect(x.>is_inf())

    .ok
}

test "floor" {
    try testing::expect(14.5.>floor() == 14.0)
    try testing::expect((-14.5).>floor() == -15.0)
    .ok
}

test "ceil" {
    try testing::expect(14.5.>ceil() == 15.0)
    try testing::expect((-14.5).>ceil() == -14.0)
    .ok
}

test "round" {
    try testing::expect(5.0.>round() == 5.0)
    try testing::expect(-5.0.>round() == -5.0)
    try testing::expect(1.2.>round() == 1.0)
    try testing::expect(-1.2.>round() == -1.0)
    try testing::expect(1.7.>round() == 2.0)
    try testing::expect(-1.7.>round() == -2.0)
    try testing::expect(1.5.>round() == 2.0)
    try testing::expect(-1.5.>round() == -2.0)
    .ok
}

test "trunc" {
    try testing::expect(1.7.>trunc() == 1.0)
    try testing::expect(-1.7.>trunc() == -1.0)
    try testing::expect(3.2.>trunc() == 3.0)
    .ok
}

test "fract" {
    try testing::expect(3.5.>fract() == 0.5)
    try testing::expect(-3.5.>fract() == -0.5)
    try testing::expect(-5.0.>fract() == -0.0)
    .ok
}

test "pow" {
    try testing::expect(2.0.>pow(10.0) == 1024.0)
    .ok
}

test "sqrt" {
    try testing::expect(9.0.>sqrt() == 3.0)
    .ok
}

test "cbrt" {
    try testing::expect(Float::near((-27.0).>cbrt(), -3.0))
    .ok
}



test "exp" {
    try testing::expect(Float::near(2.0.>exp(), 7.389056))
    .ok
}

test "log" {
    try testing::expect(Float::near(2.0.>log(), 0.69314))
    .ok
}

test "log2" {
    try testing::expect(Float::near(2.0.>log2(), 1.0))
    .ok
}

test "log10" {
    try testing::expect(Float::near(2.0.>log10(), 0.301030))
    .ok
}
