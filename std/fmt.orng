import ascii
import math
import mem
import string_buffer::String_Buffer
import testing

impl core::Format for Bool {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        if self^ {
            writer.>write("true")
        } else {
            writer.>write("false")
        }
    }
}

impl core::Format for Int {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        let mut value = self^
        let mut buf: [20]Byte // large enough for 64-bit int and sign
        let mut i = 0

        if value == 0 {
            try writer.>write("0")
            return .ok
        }

        // Handle sign
        if value < 0 {
            try writer.>write("-")
            value = -value
        }

        // Extract digits in reverse order
        while value > 0 {
            let digit = (value % 10) as Byte
            buf[i] = '0' + digit
            i += 1
            value /= 10
        }

        // Write digits in correct order
        let mut buf_slice = [mut]buf
        buf_slice.length = i
        mem::reverse(buf_slice)
        writer.>write(buf_slice)
    }
}

impl core::Format for Float {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        let mut value = self^

        // special cases
        if value.>is_nan() {
            try writer.>write("nan")
            return .ok
        } else if value.>is_inf() {
            if value < 0.0 {
                try writer.>write("-inf")
            } else {
                try writer.>write("inf")
            }
            return .ok
        }

        // handle sign
        if value < 0.0 {
            try writer.>write("-")
            value = -value
        }

        let int_part = math::truncate(value)
        let frac_part = value - math::as_float(int_part)

        try int_part.>format(writer)

        try writer.>write(".")

        const precision = 6
        let mut buf: [comptime{precision}]Byte
        let mut buf_slice = [mut]buf
        buf_slice.length = 0
        let mut scaled = frac_part
        while let mut i = 0; i < precision; i += 1 {
            scaled *= 10.0
            let digit = math::truncate(scaled)
            buf[i] = ('0' + digit) as Byte
            if digit != 0 {
                buf_slice.length = i + 1
            }
            scaled -= math::as_float(digit)
        }
        writer.>write(buf_slice)
    }
}

test "bool" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    try true.>format(&mut str)
    try str.>write(" ")
    try false.>format(&mut str)

    try testing::expect(str.>cmp("true false"))

    .ok
}

test "string" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    let hello = "Hello"
    let world = "World"

    try hello.>format(&mut str)
    try str.>write(", ")
    try world.>format(&mut str)
    try str.>write("!")

    try testing::expect(str.>cmp("Hello, World!"))

    .ok
}

test "int" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    let x = 123456789
    let y = -100
    let z = 0

    try x.>format(&mut str)
    try str.>write(" ")
    try y.>format(&mut str)
    try str.>write(" ")
    try z.>format(&mut str)

    try testing::expect(str.>cmp("123456789 -100 0"))

    .ok
}

test "float" with core::Allocating {

    let mut str = String_Buffer::init()
    defer str.>deinit()

    let x = 3.14
    let y = -3.14
    let z = 1.0 / 0.0
    let a = -1.0 / 0.0
    let b = 0.0 / 0.0

    try x.>format(&mut str)
    try str.>write(" ")
    try y.>format(&mut str)
    try str.>write(" ")
    try z.>format(&mut str)
    try str.>write(" ")
    try a.>format(&mut str)
    try str.>write(" ")
    try b.>format(&mut str)

    try testing::expect(str.>cmp("3.14 -3.14 inf -inf nan"))

    .ok
}

fn parse_int(buffer: String) -> Int {
    let mut retval = 0
    let mut sign = 1
    let mut i = 0
    
    // handle sign
    if buffer[0] == '-' {
        sign = -1
        i += 1
    } else if buffer[0] == '+' {
        i += 1
    }

    while i < buffer.length; i += 1 {
        let c: Byte = buffer[i]
        if c.>is_digit() {
            retval = retval * 10 + (c as Int - '0')
        } else {
            break
        }
    }

    retval * sign
}

fn parse_float(buffer: String) -> Float {
    // atof
    _ = buffer
    0.0
}

test "parse_int" with core::IO {
    let res = parse_int("123")
    try @println("{res}")
    try testing::expect(parse_int("123") == 123)
    //try testing::expect(parse_int("+123") == 123)
    //try testing::expect(parse_int("-123") == -123)
    //try testing::expect(parse_int("abc") == 0)
    //try testing::expect(parse_int("123abc") == 123)
    .ok
}