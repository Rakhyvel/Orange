import ascii
import math
import mem
import string_buffer::String_Buffer
import testing

impl core::Format for Bool {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        if self^ {
            writer.>write("true")
        } else {
            writer.>write("false")
        }
    }
}

impl core::Format for Int {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        let mut value = self^
        let mut buf: [20]Byte // large enough for 64-bit int and sign
        let mut i = 0

        if value == 0 {
            try writer.>write("0")
            return .ok
        }

        // Handle sign
        if value < 0 {
            try writer.>write("-")
            value = -value
        }

        // Extract digits in reverse order
        while value > 0 {
            let digit = (value % 10) as Byte
            buf[i] = '0' + digit
            i += 1
            value /= 10
        }

        // Write digits in correct order
        let mut buf_slice = [mut]buf
        buf_slice.length = i
        mem::reverse(buf_slice)
        writer.>write(buf_slice)
    }
}

impl core::Format for Byte {    
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        let mut value = self^
        let mut buf: [20]Byte
        let mut i = 0

        if value == 0 {
            try writer.>write("0")
            return .ok
        }

        // Extract digits in reverse order
        while value > 0 {
            let digit = (value % 10) as Byte
            buf[i] = '0' + digit
            i += 1
            value /= 10
        }

        // Write digits in correct order
        let mut buf_slice = [mut]buf
        buf_slice.length = i
        mem::reverse(buf_slice)
        writer.>write(buf_slice)
    }
}

impl core::Format for Word32 {    
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        let mut value = self^
        let mut buf: [20]Byte
        let mut i = 0

        if value == 0 {
            try writer.>write("0")
            return .ok
        }

        // Extract digits in reverse order
        while value > 0 {
            let digit = (value % 10) as Byte
            buf[i] = '0' + digit
            i += 1
            value /= 10
        }

        // Write digits in correct order
        let mut buf_slice = [mut]buf
        buf_slice.length = i
        mem::reverse(buf_slice)
        writer.>write(buf_slice)
    }
}

impl core::Format for Float {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        let mut value = self^

        // special cases
        if value.>is_nan() {
            try writer.>write("nan")
            return .ok
        } else if value.>is_inf() {
            if value < 0.0 {
                try writer.>write("-inf")
            } else {
                try writer.>write("inf")
            }
            return .ok
        }

        // handle sign
        if value < 0.0 {
            try writer.>write("-")
            value = -value
        }

        let int_part = math::int_from_float(value)
        let frac_part = value - math::float_from_int(int_part)

        try int_part.>format(writer)

        try writer.>write(".")

        const precision = 6
        let mut buf: [comptime{precision}]Byte
        let mut buf_slice = [mut]buf
        buf_slice.length = 0
        let mut scaled = frac_part
        while let mut i = 0; i < precision; i += 1 {
            scaled *= 10.0
            let digit = math::int_from_float(scaled)
            buf[i] = ('0' + digit) as Byte
            if digit != 0 or i == 0 {
                buf_slice.length = i + 1
            }
            scaled -= math::float_from_int(digit)
        }
        writer.>write(buf_slice)
    }
}

impl core::Format for Float32 {
    virtual fn format(&self, writer: &mut dyn core::Writer) -> ()!() {
        let mut value = self^

        // special cases
        if value.>is_nan() {
            try writer.>write("nan")
            return .ok
        } else if value.>is_inf() {
            if value < 0.0 {
                try writer.>write("-inf")
            } else {
                try writer.>write("inf")
            }
            return .ok
        }

        // handle sign
        if value < 0.0 {
            try writer.>write("-")
            value = -value
        }

        let int_part = math::int_from_float32(value)
        let frac_part = value - math::float32_from_int(int_part)

        try int_part.>format(writer)

        try writer.>write(".")

        const precision = 6
        let mut buf: [comptime{precision}]Byte
        let mut buf_slice = [mut]buf
        buf_slice.length = 0
        let mut scaled = frac_part
        while let mut i = 0; i < precision; i += 1 {
            scaled *= 10.0
            let digit = math::int_from_float32(scaled)
            buf[i] = ('0' + digit) as Byte
            if digit != 0 or i == 0 {
                buf_slice.length = i + 1
            }
            scaled -= math::float32_from_int(digit)
        }
        writer.>write(buf_slice)
    }
}

test "bool" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    try true.>format(&mut str)
    try str.>write(" ")
    try false.>format(&mut str)

    try testing::expect(str.>cmp("true false"))

    .ok
}

test "string" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    let hello = "Hello"
    let world = "World"

    try hello.>format(&mut str)
    try str.>write(", ")
    try world.>format(&mut str)
    try str.>write("!")

    try testing::expect(str.>cmp("Hello, World!"))

    .ok
}

test "int" with core::Allocating {
    let mut str = String_Buffer::init()
    defer str.>deinit()

    let x = 123456789
    let y = -100
    let z = 0

    try x.>format(&mut str)
    try str.>write(" ")
    try y.>format(&mut str)
    try str.>write(" ")
    try z.>format(&mut str)

    try testing::expect(str.>cmp("123456789 -100 0"))

    .ok
}

test "float" with core::Allocating {

    let mut str = String_Buffer::init()
    defer str.>deinit()

    let x = 3.14
    let y = -3.14
    let z = 1.0 / 0.0
    let a = -1.0 / 0.0
    let b = 0.0 / 0.0

    try x.>format(&mut str)
    try str.>write(" ")
    try y.>format(&mut str)
    try str.>write(" ")
    try z.>format(&mut str)
    try str.>write(" ")
    try a.>format(&mut str)
    try str.>write(" ")
    try b.>format(&mut str)

    try testing::expect(str.>cmp("3.14 -3.14 inf -inf nan"))

    .ok
}

fn parse_int(buffer: String) -> Int {
    let mut retval = 0
    let mut sign = 1
    let mut i = 0
    
    // handle sign
    if buffer[0] == '-' {
        sign = -1
        i += 1
    } else if buffer[0] == '+' {
        i += 1
    }

    while i < buffer.length; i += 1 {
        let c: Byte = buffer[i]
        if c.>is_digit() {
            retval = retval * 10 + (c as Int - '0')
        } else {
            break
        }
    }

    retval * sign
}

fn parse_float(buffer: String) -> Float {
    let mut retval = 0.0
    let mut sign = 1.0
    let mut i = 0

    // handle sign
    if buffer[0] == '-' {
        sign = -1.0
        i += 1
    } else if buffer[0] == '+' {
        i += 1
    }

    // process integer part
    while i < buffer.length; i += 1 {
        let c: Byte = buffer[i]
        if c.>is_digit() {
            retval = retval * 10.0 + math::float_from_int(c as Int - '0')
        } else {
            break
        }
    }

    // process fractional part
    if i < buffer.length and buffer[i] == '.' {
        i += 1
        let mut divisor = 10.0
        while i < buffer.length; i += 1 {
            let c: Byte = buffer[i]
            if c.>is_digit() {
                retval += math::float_from_int(c as Int - '0') / divisor
                divisor *= 10.0
            } else {
                break
            }
        }
    }

    retval * sign
}

test "parse_int" {
    try testing::expect(parse_int("123") == 123)
    try testing::expect(parse_int("+123") == 123)
    try testing::expect(parse_int("-123") == -123)
    try testing::expect(parse_int("abc") == 0)
    try testing::expect(parse_int("123abc") == 123)
    .ok
}

test "parse_float" {
    try testing::expect(parse_float("123") == 123.0)
    try testing::expect(parse_float("123.456") == 123.456)
    try testing::expect(parse_float("+123") == 123.0)
    try testing::expect(parse_float("+123.456") == 123.456)
    try testing::expect(parse_float("-123") == -123.0)
    try testing::expect(parse_float("-123.456") == -123.456)
    try testing::expect(parse_float("abc") == 0.0)
    try testing::expect(parse_float("123abc") == 123.0)
    try testing::expect(parse_float("123.456abc") == 123.456)
    .ok
}