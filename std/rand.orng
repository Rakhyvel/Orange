import debug
import fmt
import math
import testing

struct Xoshiro128 {
    state: [4]Word32
}

impl for Xoshiro128 {
    fn from_seed(the_seed: Word32) -> Self {
        let mut retval = Xoshiro128([0, 0, 0, 0])
        retval.>reseed(the_seed)
        retval
    }

    fn reseed(&mut self, the_seed: Word32) {
        fn splitmix32(the_seed: &mut Word32) -> Word32 {
            the_seed^ += 0x9E3779B9
            let mut z = the_seed^
            z ~= (z >> 16) * 0x85EBCA6B
            z ~= (z >> 13) * 0xC2B2AE35
            z ~ z >> 16
        }

        let mut tmp = the_seed
        while let mut i = 0; i < 4; i += 1 {
            self.state[i] = splitmix32(&mut tmp)
            if self.state[i] == 0 {
                self.state[i] = 0xDEADBEEF
            }
        }
    }

    fn next(&mut self) -> Word32 {
        let result = self.state[0] + self.state[3]

        let t: Word32 = self.state[1] << 9

        self.state[2] ~= self.state[0]
        self.state[3] ~= self.state[1]
        self.state[1] ~= self.state[2]
        self.state[0] ~= self.state[3]

        self.state[2] ~= t
        self.state[3] ~= rotl(self.state[3], 11)

        result
    }

    fn next_float(&mut self) -> Float {
        let result = self.>next()
        math::float_from_word32(result) / 4294967296.0
    }

    fn uniform(&mut self, lower: Float, upper: Float) -> Float {
        debug::assert(lower < upper)
        self.>next_float() * (upper - lower) + lower
    }

    fn normal(&mut self, loc: Float = 0.0, scale: Float = 1.0) -> Float {
        let mut u1 = self.>next_float()
        while u1 == 0.0 {
            u1 = self.>next_float() // to prevent log(0.0)
        }
        let u2 = self.>next_float()

        let z0 = (-2.0 * u1.>log()).>sqrt() * (2.0 * Float::pi * u2).>cos()
        z0 * scale + loc
    }
}

fn rotl(x: Word32, k: Word32) -> Word32 {
    x << k | x >> (32 - k)
}

test "rand" {
    let mut rng = Xoshiro128::from_seed(0)
    let mut histogram: [10]Int = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    const iterations = 1_000_000
    const tolerance = 0.05

    while let mut i = 0; i < iterations; i += 1 {
        let x = rng.>next_float()
        let idx = math::int_from_float(x * 10.0)
        histogram[idx] += 1
    }

    let expected = math::float_from_int(iterations) / 10.0

    while let mut i = 0; i < 10; i += 1 {
        let lower = math::int_from_float(expected * (1.0 - tolerance))
        let upper = math::int_from_float(expected * (1.0 + tolerance))
        try testing::expect(histogram[i] >= lower)
        try testing::expect(histogram[i] <= upper)
    }
    .ok
}

test "uniform" {
    const iterations = 1_000_000
    const lower = -10.0
    const upper = 10.0

    let mut rng = Xoshiro128::from_seed(0)

    while let mut i = 0; i < iterations; i += 1 {
        let value = rng.>uniform(lower, upper)
        
        try testing::expect(value >= lower)
        try testing::expect(value <= upper)
    }
    .ok
}

test "normal" with core::IO {
    let mut rng = Xoshiro128::from_seed(0)

    let mut min = 1000.0
    let mut max = -1000.0

    while let mut i = 0; i < 1_000_000; i += 1 {
        let x = rng.>normal()
        if x < min { min = x }
        if x > max { max = x }
    }
    
    try testing::expect(min < -1.0)
    try testing::expect(max > 1.0)

    .ok
}