import debug
import ffi

fn new[T]() -> ()!&mut T with core::Allocating {
    match core::Allocating.alloc.>alloc(@sizeof(T)) {
        .some(bytes) => ffi::ref_from_ptr_mut[T](bytes as [*mut]T)
        .none => .err
    }
}

fn make[T](length: Int) -> ()![mut]T with core::Allocating {
    match core::Allocating.alloc.>alloc(@sizeof(T) * length) {
        .some(bytes) => .ok(mut_slice_from_parts[T](bytes as [*mut]T, length))
        .none => .err
    }
}

fn destroy[T](slice: [mut]T) with core::Allocating {
    core::Allocating.alloc.>free(slice.data as [*mut]Byte)
}

fn mut_slice_from_parts[T](data: [*mut]T, length: Int) -> [mut]T {
    let mut retval: [mut]T = undefined
    retval.data = data
    retval.length = length
    retval
}

fn slice_from_parts[T](data: [*]T, length: Int) -> []T {
    let mut retval: []T = undefined
    retval.data = data
    retval.length = length
    retval
}

fn eql(a: String, b: String) -> Bool {
    if a.length != b.length {return false}

    for i in 0...a.length {
        if a[i] != b[i] {return false}
    }

    true
}

fn starts_with(haystack: []Byte, needle: []Byte) -> Bool {
    if needle.length > haystack.length {
        false
    } else {
        eql(haystack[..needle.length], needle)
    }
}

fn copy[T](dest: [mut]T, src: []T) {
    for i in 0...src.length {
        dest[i] = src[i]
    }
}

fn index_of(haystack: []Byte, needle: []Byte) -> ?Int {
    if needle.length == 0 {
        return .some(0)
    }

    if needle.length > haystack.length {
        return .none
    }

    while let mut i = 0; i <= haystack.length - needle.length; i += 1 {
        let mut found = true

        for j in 0...needle.length {
            if haystack[i + j] != needle[j] {
                found = false
                break
            }
        }

        if found {
            return .some(i)
        }
    }

    .none
}

fn replacement_size(input: []Byte, needle: []Byte, replacement: []Byte) -> Int {
    debug::assert(needle.length > 0, .some("mem::replacement_size: empty needle"))

    let mut size = input.length
    while let mut i = 0; i < input.length {
        if starts_with(input[i..], needle) {
            size = size - needle.length + replacement.length
            i += needle.length
        } else {
            i += 1
        }
    }

    size
}

fn replace(input: []Byte, needle: []Byte, replacement: []Byte, output: [mut]Byte) -> Int {
    debug::assert(needle.length > 0, .some("mem::replacement: empty needle"))
    
    let mut slide = 0
    let mut replacements = 0
    while let mut i = 0; slide < input.length {
        if starts_with(input[slide..], needle) {
            copy[Byte](output[i..][0..replacement.length], replacement)
            i += replacement.length
            slide += needle.length
            replacements += 1
        } else {
            output[i] = input[slide]
            i += 1
            slide += 1
        }
    }

    replacements
}

fn reverse(items: [mut]Byte) {
    let end = items.length / 2
    for i in 0...end {
        let tmp = items[i]
        items[i] = items[items.length - i - 1]
        items[items.length - i - 1] = tmp
    }
}