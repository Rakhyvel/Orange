import debug
import ffi
import testing

fn new[T: core::Sized]() -> ()!&mut T with core::Allocating {
    match core::Allocating.alloc.>alloc(T::size) {
        .some(bytes) => ffi::ref_from_ptr_mut[T](bytes as [*mut]T)
        .none => .err
    }
}

fn make[T: core::Sized](length: Int) -> ()![mut]T with core::Allocating {
    match core::Allocating.alloc.>alloc(T::size * length) {
        .some(bytes) => .ok(mut_slice_from_parts[T](bytes as [*mut]T, length))
        .none => .err
    }
}

fn destroy[T](slice: [mut]T) with core::Allocating {
    core::Allocating.alloc.>free(slice.data as [*mut]Byte)
}

fn mut_slice_from_parts[T](data: [*mut]T, length: Int) -> [mut]T {
    let mut retval: [mut]T = undefined
    retval.data = data
    retval.length = length
    retval
}

fn slice_from_parts[T](data: [*]T, length: Int) -> []T {
    let mut retval: []T = undefined
    retval.data = data
    retval.length = length
    retval
}

fn eql(a: String, b: String) -> Bool {
    if a.length != b.length {return false}

    for i in 0...a.length {
        if a[i] != b[i] {return false}
    }

    true
}

fn starts_with(haystack: []Byte, needle: []Byte) -> Bool {
    if needle.length > haystack.length {
        false
    } else {
        eql(haystack[..needle.length], needle)
    }
}

fn copy[T](dest: [mut]T, src: []T) {
    for i in 0...src.length {
        dest[i] = src[i]
    }
}

fn index_of(haystack: []Byte, needle: []Byte) -> ?Int {
    if needle.length == 0 {
        return .some(0)
    }

    if needle.length > haystack.length {
        return .none
    }

    while let mut i = 0; i <= haystack.length - needle.length; i += 1 {
        let mut found = true

        for j in 0...needle.length {
            if haystack[i + j] != needle[j] {
                found = false
                break
            }
        }

        if found {
            return .some(i)
        }
    }

    .none
}

fn replacement_size(input: []Byte, needle: []Byte, replacement: []Byte) -> Int {
    debug::assert(needle.length > 0, .some("mem::replacement_size: empty needle"))

    let mut size = input.length
    while let mut i = 0; i < input.length {
        if starts_with(input[i..], needle) {
            size = size - needle.length + replacement.length
            i += needle.length
        } else {
            i += 1
        }
    }

    size
}

fn replace(input: []Byte, needle: []Byte, replacement: []Byte, output: [mut]Byte) -> Int {
    debug::assert(needle.length > 0, .some("mem::replacement: empty needle"))
    
    let mut slide = 0
    let mut replacements = 0
    while let mut i = 0; slide < input.length {
        if starts_with(input[slide..], needle) {
            copy[Byte](output[i..][0..replacement.length], replacement)
            i += replacement.length
            slide += needle.length
            replacements += 1
        } else {
            output[i] = input[slide]
            i += 1
            slide += 1
        }
    }

    replacements
}

fn reverse(items: [mut]Byte) {
    let end = items.length / 2
    for i in 0...end {
        let tmp = items[i]
        items[i] = items[items.length - i - 1]
        items[items.length - i - 1] = tmp
    }
}

struct Delimiter_Iterator {
    data: []Byte
    delimiter: Byte
    cursor: Int = -1
}

impl core::Iterator for Delimiter_Iterator {
    type Item = []Byte

    fn next(&mut self) -> ?Self::Item {
        if self.cursor >= self.data.length {
            return .none
        }

        self.cursor += 1

        let prev = self.cursor

        while self.cursor < self.data.length and self.data[self.cursor] != self.delimiter {
            self.cursor += 1
        }

        .some(self.data[prev..self.cursor])
    }
}

test "delimiter iterator" {
    let bytes = "a,b,c"
    let mut delim_iter = Delimiter_Iterator(.data = bytes, .delimiter = ',')

    try testing::expect(eql("a", delim_iter.>next().some))
    try testing::expect(eql("b", delim_iter.>next().some))
    try testing::expect(eql("c", delim_iter.>next().some))
    try testing::expect(delim_iter.>next() == .none)

    .ok
}
