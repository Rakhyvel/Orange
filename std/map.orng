import mem
import testing

struct Map[K: core::Hash + core::Eq, V] {
    hashes: [mut]Word64
    keys: [mut]K
    values: [mut]V
    capacity: Int
    alloc: &mut dyn core::Allocator
}

struct Map_Iterator[K, V] {
    hashes: []Word64
    keys: []K
    values: []V
    counter: Int = 0
}

struct Map_Mut_Iterator[K, V] {
    hashes: []Word64
    keys: []K
    values: [mut]V
    counter: Int = 0
}

struct Hash_Iterator[T] {
    hashes: []Word64
    items: []T
    counter: Int = 0
}

struct Mut_Hash_Iterator[T] {
    hashes: []Word64
    items: [mut]T
    counter: Int = 0
}

enum Error {
    out_of_memory
}

impl[K: core::Hash + core::Eq + core::Sized, V: core::Sized] for Map[K, V] {
    fn init() -> Self with core::Allocating {
        Self(
            .hashes = mem::mut_slice_from_parts[Word64](0 as [*mut]Word64, 0),
            .keys = mem::mut_slice_from_parts[K](0 as [*mut]K, 0),
            .values = mem::mut_slice_from_parts[V](0 as [*mut]V, 0),
            .capacity = 0,
            .alloc = core::Allocating.alloc,
        )
    }

    fn init_from_slice(pairs: [](K, V)) -> Error!Self with core::Allocating {
        let mut retval = Self::init()

        for i in 0...pairs.length {
            try retval.>put(pairs[i][0], pairs[i][1])
        }

        .ok(retval)
    }

    fn deinit(&mut self) {
        self.alloc.>free(self.hashes.data as [*mut]Byte)
        self.alloc.>free(self.keys.data as [*mut]Byte)
        self.alloc.>free(self.values.data as [*mut]Byte)
    }

    fn clone(&self) -> Error!Self with core::Allocating {
        let mut retval = Self::init()

        for i in 0...self.>count() {
            try retval.>put(self.keys[i], self.values[i])
        }

        .ok(retval)
    }

    fn count(&self) -> Int {
        self.hashes.length
    }

    fn get(&self, key: K) -> ?&V {
        let hash = key.>hash() | 1

        for i in 0...self.hashes.length {
            if self.hashes[i] == hash {
                if self.keys[i].>eq(key) {
                    return .some(&self.values[i])
                }
            }
        }

        .none
    }

    fn get_mut(&self, key: K) -> ?&mut V {
        let hash = key.>hash() | 1

        for i in 0...self.hashes.length {
            if self.hashes[i] == hash {
                if self.keys[i].>eq(key) {
                    return .some(&mut self.values[i])
                }
            }
        }

        .none
    }

    fn contains(&self, key: K) -> Bool {
        match self.>get(key) {
            .some(_) => true
            .none    => false
        }
    }

    fn keys(&self) -> Hash_Iterator[K] {
        Hash_Iterator[K](
            .hashes = self.hashes,
            .items = self.keys,
        )
    }

    fn values(&self) -> Hash_Iterator[V] {
        Hash_Iterator[V](
            .hashes = self.hashes,
            .items = self.values,
        )
    }

    fn values_mut(&self) -> Mut_Hash_Iterator[V] {
        Mut_Hash_Iterator[V](
            .hashes = self.hashes,
            .items = self.values,
        )
    }

    fn iter_mut(&mut self) -> Map_Mut_Iterator[K, V] {
        Map_Mut_Iterator[K, V](
            .hashes = self.hashes,
            .keys = self.keys,
            .values = self.values,
        )
    }

    fn clear(&mut self) {
        self.hashes.length = 0
        self.keys.length = 0
        self.values.length = 0
    }

    fn put(&mut self, key: K, value: V) -> Error!() {
        let hash = key.>hash() | 1

        for i in 0...self.hashes.length {
            if self.hashes[i] == hash and self.keys[i].>eq(key) {
                self.values[i] = value
                return .ok
            }
        }

        try self.>ensure_length(self.hashes.length + 1)

        self.hashes[self.hashes.length - 1] = hash
        self.keys[self.keys.length - 1] = key
        self.values[self.values.length - 1] = value

        .ok
    }

    fn remove(&mut self, key: K) {
        let hash = key.>hash() | 1

        for i in 0...self.hashes.length {
            if self.hashes[i] == hash and self.keys[i].>eq(key) {
                let last = self.hashes.length - 1

                self.hashes[i] = self.hashes[last]
                self.keys[i] = self.keys[last]
                self.values[i] = self.values[last]

                self.hashes.length -= 1
                self.keys.length -= 1
                self.values.length -= 1

                return
            }
        }
    }

    fn ensure_length(&mut self, new_length: Int) -> Error!() {
        if new_length > self.capacity {
            let new_cap_elements = new_length * 2

            self.hashes.data = (self.alloc.>realloc(
                self.hashes.data as [*mut]Byte,
                new_cap_elements * @sizeof(Word64)
            ) orelse {
                return .err(.out_of_memory)
            }) as [*mut]Word64

            if K::size > 0 {
                self.keys.data = (self.alloc.>realloc(
                    self.keys.data as [*mut]Byte,
                    new_cap_elements * K::size
                ) orelse {
                    return .err(.out_of_memory)
                }) as [*mut]K
            }

            if V::size > 0 {
                self.values.data = (self.alloc.>realloc(
                    self.values.data as [*mut]Byte,
                    new_cap_elements * V::size
                ) orelse {
                    return .err(.out_of_memory)
                }) as [*mut]V
            }

            self.capacity = new_cap_elements
        }

        self.hashes.length = new_length
        self.keys.length = new_length
        self.values.length = new_length

        .ok
    }
}

impl[K, V] core::Iterator for Map_Iterator[K, V] {
    type Item = (&K, &V)

    fn next(&mut self) -> ?Self::Item {
        if self.counter >= self.hashes.length {
            return .none
        }
        while self.hashes[self.counter] == 0; self.counter += 1 {}
        let retval: ?Self::Item = .some((&self.keys[self.counter], &self.values[self.counter]))
        self.counter += 1
        retval
    }
}

impl[K, V] core::Iterator for Map_Mut_Iterator[K, V] {
    type Item = (&K, &mut V)

    fn next(&mut self) -> ?Self::Item {
        if self.counter >= self.hashes.length {
            return .none
        }
        while self.hashes[self.counter] == 0; self.counter += 1 {}
        let retval: ?Self::Item = .some((&self.keys[self.counter], &mut self.values[self.counter]))
        self.counter += 1
        retval
    }
}

impl[T] core::Iterator for Hash_Iterator[T] {
    type Item = &T

    fn next(&mut self) -> ?Self::Item {
        if self.counter >= self.hashes.length {
            return .none
        }
        while self.hashes[self.counter] == 0; self.counter += 1 {}
        let retval: ?Self::Item = .some(&self.items[self.counter])
        self.counter += 1
        retval
    }
}

impl[T] core::Iterator for Mut_Hash_Iterator[T] {
    type Item = &mut T

    fn next(&mut self) -> ?Self::Item {
        if self.counter >= self.hashes.length {
            return .none
        }
        while self.hashes[self.counter] == 0; self.counter += 1 {}
        let retval: ?Self::Item = .some(&mut self.items[self.counter])
        self.counter += 1
        retval
    }
}

impl[K: core::Hash + core::Eq, V] core::Into_Iterator for Map[K, V] {
    type Item = (&K, &V)
    type Iter = Map_Iterator[K, V]

    fn into_iter(self) -> Self::Iter {
        Self::Iter(
            .hashes = self.hashes,
            .keys = self.keys,
            .values = self.values
        )
    }
}

test "init_from_slice" with core::Allocating {
    let mut map = Map[String, Int]::init_from_slice([][("a", 1), ("b", 2), ("c", 3)]) catch {return .err}
    defer map.>deinit()
    
    try testing::expect(map.>count() == 3)
    try testing::expect(map.>get("a").some^ == 1)
    try testing::expect(map.>get("b").some^ == 2)
    try testing::expect(map.>get("c").some^ == 3)

    .ok
}

test "clone" with core::Allocating {
    let mut map = Map[String, Int]::init_from_slice([][("a", 1), ("b", 2), ("c", 3)]) catch {return .err}
    defer map.>deinit()
    let mut clone = map.>clone() catch {return .err}
    defer clone.>deinit()
    
    try testing::expect(clone.>count() == 3)
    try testing::expect(clone.>get("a").some^ == 1)
    try testing::expect(clone.>get("b").some^ == 2)
    try testing::expect(clone.>get("c").some^ == 3)

    .ok
}

test "get none" with core::Allocating {
    let mut map = Map[String, Int]::init()
    defer map.>deinit()

    match map.>get("Hello!") {
        .some(_) => .err
        .none    => .ok
    }
}

test "get mut" with core::Allocating {
    let mut map = Map[String, Int]::init()
    defer map.>deinit()

    map.>put("Hello", 5) catch {return .err}

    let ref = map.>get_mut("Hello").some
    ref^ = 100

    try testing::expect(map.>count() == 1)
    try testing::expect(map.>get("Hello").some^ == 100)

    .ok
}

test "clear" with core::Allocating {
    let mut map = Map[String, Int]::init_from_slice([][("a", 1), ("b", 2), ("c", 3)]) catch {return .err}
    defer map.>deinit()

    map.>clear()
    
    try testing::expect(map.>count() == 0)
    try testing::expect(not map.>contains("a"))
    try testing::expect(not map.>contains("b"))
    try testing::expect(not map.>contains("c"))

    .ok
}

test "put" with core::Allocating {
    let mut map = Map[String, Int]::init()
    defer map.>deinit()

    map.>put("Hello", 5) catch {return .err}

    try testing::expect(map.>count() == 1)
    try testing::expect(map.>get("Hello").some^ == 5)

    .ok
}

test "put reset" with core::Allocating {
    let mut map = Map[String, Int]::init()
    defer map.>deinit()

    map.>put("Hello", 6) catch {return .err}
    map.>put("Hello", 7) catch {return .err}

    try testing::expect(map.>count() == 1)
    try testing::expect(map.>get("Hello").some^ == 7)

    .ok
}

test "remove" with core::Allocating {
    let mut map = Map[String, Int]::init()
    defer map.>deinit()

    map.>put("a", 1) catch {return .err}
    map.>put("b", 2) catch {return .err}
    map.>put("c", 3) catch {return .err}

    map.>remove("b")

    try testing::expect(map.>count() == 2)
    try testing::expect(map.>get("a").some^ == 1)
    try testing::expect(not map.>contains("b"))
    try testing::expect(map.>get("c").some^ == 3)

    .ok
}

test "set" with core::Allocating {
    let mut set = Map[String, ()]::init()

    set.>put("a", {}) catch {return .err}
    set.>put("b", {}) catch {return .err}
    set.>put("c", {}) catch {return .err}

    set.>remove("b")

    try testing::expect(set.>count() == 2)
    try testing::expect(set.>contains("a"))
    try testing::expect(not set.>contains("b"))
    try testing::expect(set.>contains("c"))

    .ok
}

test "into_iter" with core::Allocating {
    let mut map = Map[String, Int]::init_from_slice([][("a", 1), ("b", 2), ("c", 3)]) catch {return .err}
    defer map.>deinit()
    
    let mut iter = map.>into_iter()

    let mut item = iter.>next()
    try testing::expect(mem::eql(item.some[0]^, "a"))
    try testing::expect(item.some[1]^ == 1)

    item = iter.>next()
    try testing::expect(mem::eql(item.some[0]^, "b"))
    try testing::expect(item.some[1]^ == 2)

    item = iter.>next()
    try testing::expect(mem::eql(item.some[0]^, "c"))
    try testing::expect(item.some[1]^ == 3)

    item = iter.>next()
    try testing::expect(item == .none)

    .ok
}

test "keys" with core::Allocating {
    let mut map = Map[String, Int]::init_from_slice([][("a", 1), ("b", 2), ("c", 3)]) catch {return .err}
    defer map.>deinit()
    
    let mut iter = map.>keys()

    let mut item = iter.>next()
    try testing::expect(mem::eql(item.some^, "a"))

    item = iter.>next()
    try testing::expect(mem::eql(item.some^, "b"))

    item = iter.>next()
    try testing::expect(mem::eql(item.some^, "c"))

    item = iter.>next()
    try testing::expect(item == .none)

    .ok
}

test "values" with core::Allocating {
    let mut map = Map[String, Int]::init_from_slice([][("a", 1), ("b", 2), ("c", 3)]) catch {return .err}
    defer map.>deinit()
    
    let mut iter = map.>values()

    let mut item = iter.>next()
    try testing::expect(item.some^ == 1)

    item = iter.>next()
    try testing::expect(item.some^ == 2)

    item = iter.>next()
    try testing::expect(item.some^ == 3)

    item = iter.>next()
    try testing::expect(item == .none)

    .ok
}

test "values_mut" with core::Allocating {
    let mut map = Map[String, Int]::init_from_slice([][("a", 1), ("b", 2), ("c", 3)]) catch {return .err}
    defer map.>deinit()

    for v in map.>values_mut() {
        v^ *= 2
    }

    try testing::expect(map.>get("a").some^ == 2)
    try testing::expect(map.>get("b").some^ == 4)
    try testing::expect(map.>get("c").some^ == 6)

    .ok
}

test "iter_mut" with core::Allocating {
    let mut map = Map[String, Int]::init_from_slice([][("a", 1), ("b", 2), ("c", 3)]) catch {return .err}
    defer map.>deinit()

    for (k, v) in map.>iter_mut() {
        if mem::eql(k^, "b") {
            v^ *= 2
        }
    }

    try testing::expect(map.>get("a").some^ == 1)
    try testing::expect(map.>get("b").some^ == 4)
    try testing::expect(map.>get("c").some^ == 3)

    .ok
}
