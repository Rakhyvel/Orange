# https://github.com/proebsting/rdgen
# used just to check for ambiguity
# python3.10 ../rdgen/main.py create --input orng.ebnf --output parser.py

program: top_level_declaration {top_level_declaration}.

top_level_declaration: (fn_declaration | const_declaration).

non_fn_declaration: let_declaration | const_declaration.

const_declaration: "const" ident [":" arrowExpr] "=" expr "\n". # Note: For practicality, newline can be omitted if EOF matches the next token

let_declaration: "let" ["mut"] ident (":" arrowExpr ["=" expr] | "=" expr).

fn_declaration: "fn" [ident ":"] paramlist "->" arrowExpr ["where" arrowExpr] "=" expr.
paramlist: "(" [param {"," param}] ")".
param: ["mut" | "const"] ident ":" annotExpr. # cannot be productExpr, otherwise ambiguous with ,

statement: non_fn_declaration # (inner named and anon fns are decalred as exprs)
         | "defer" expr       # defer
         | "errdefer" expr    # error-defer
         | expr [("=" | "+=" | "-=" | "*=" | "/=" | "%=" | "**=") expr] # Must be able to do expr as a statement, for functions, cond, case, etc
         .


expr: "cond" condExpr
    | "case" caseExpr
    | fn_declaration
    | sumExpr
    .

sumExpr: productExpr {"|" ident [":" productExpr]}. # (lhs of | must be ident or annotExpr with proper pattern left of the :)

productExpr: annotExpr {"," annotExpr}.

annotExpr: arrowExpr [":" arrowExpr ["where" arrowExpr] ["\\" arrowExpr]]. # (lhs of : must be ident or other TBD patterns)

arrowExpr: boolExpr {"->" boolExpr}.

boolExpr: neqExpr {("and" | "or") neqExpr}.

neqExpr: conditionalExpr ["!=" conditionalExpr].

conditionalExpr: deltaExpr {("==" | "<" | "<=" | ">" | ">=") deltaExpr}.

deltaExpr: coalesceExpr {"|>" coalesceExpr}. # (rhs must be a call expr)

coalesceExpr: intExpr {("orelse" | "catch") intExpr}.

intExpr: termExpr {("+" | "-" | "!") termExpr}.

termExpr: exponentExpr {("*" | "/" | "%" | "<>" | "++" | "--" | "||") exponentExpr}.

exponentExpr: prefixExpr {"**" prefixExpr}.

prefixExpr: "!" prependExpr                         # inferred error union
          | "not" prependExpr                       # boolean not
          | "-" prependExpr                         # negation
          | "&" ["mut"] prefixExpr                  # address-of
          | "[" ["mut" | expr | "*"] "]" prefixExpr # slice-of/tuple-of/multi-pointer
          | "?" prependExpr                         # optional
          | "try" prependExpr                       # error coalesce orelese return
          | "." ident ["<-" prefixExpr | parens]     # infered member/named argument/named field
          | prependExpr
          .

prependExpr: postfixExpr {".>" postfixExpr}.

postfixExpr: factor {parens | ("[" [expr] [".." [expr]] "]") | ("." ident) | (".?") | ("^")}.

factor: ident
      | int
      | hex
      | octal
      | bin
      | real
      | char
      | string
      | blockExpr
      | ifExpr
      | whileExpr
      | forExpr
      | "unreachable"
      | parens
      .


indentBlockExpr: indent [statement {"\n" statement}] [("throw" expr) | ("return" [expr]) | ("continue") | ("break")] dedent.
braceBlockExpr: "{" [statement {";" statement}] [("throw" expr) | ("return" [expr]) | ("continue") | ("break")] "}".
blockExpr: indentBlockExpr | braceBlockExpr.

ifExpr: "if" [non_fn_declaration ";"] expr blockExpr ["else" blockExpr].

whileExpr: "while" [non_fn_declaration ";"] expr [";" statement ] blockExpr ["else" blockExpr].

forExpr: "for" ["mut"] ident "in" expr blockExpr ["else" blockExpr].

barClause: annotExpr ["=>" annotExpr]. # for barClauses in case statements, if the lhs of has a pattern, => must be present
barElse: "else" "=>" annotExpr.
barListMiddle: barClause ["|" (barElse | barListMiddle)].
barList: "|" barListMiddle.

condExpr: [non_fn_declaration ";"] barList.

caseExpr: [non_fn_declaration ";"] productExpr barList.

parens: "(" expr ")".