var data = {lines:[
{"lineNum":"    1","line":"const errs = @import(\"errors.zig\");"},
{"lineNum":"    2","line":"const _token = @import(\"token.zig\");"},
{"lineNum":"    3","line":"const Token = _token.Token;"},
{"lineNum":"    4","line":"const std = @import(\"std\");"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"// Removes any newlines after the first newline in a series of newline tokens"},
{"lineNum":"    7","line":"pub fn condenseNewLines(tokens: *std.ArrayList(Token)) void {","class":"lineCov","hits":"1","order":"1224","possible_hits":"1",},
{"lineNum":"    8","line":"    var i: usize = 0;","class":"lineCov","hits":"1","order":"1225","possible_hits":"1",},
{"lineNum":"    9","line":"    while (i < tokens.items.len - 1) : (i += 1) {","class":"lineCov","hits":"3","order":"1226","possible_hits":"3",},
{"lineNum":"   10","line":"        var token = tokens.items[i];","class":"lineCov","hits":"2","order":"1227","possible_hits":"2",},
{"lineNum":"   11","line":"        if (token.kind != .NEWLINE) {","class":"lineCov","hits":"1","order":"1228","possible_hits":"1",},
{"lineNum":"   12","line":"            continue;","class":"lineCov","hits":"1","order":"1231","possible_hits":"1",},
{"lineNum":"   13","line":"        }"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"        while (i > 0 and tokens.items[i + 1].kind == .NEWLINE) {","class":"lineCov","hits":"1","order":"1229","possible_hits":"1",},
{"lineNum":"   16","line":"            _ = tokens.orderedRemove(i + 1);","class":"lineCov","hits":"2","order":"1747","possible_hits":"2",},
{"lineNum":"   17","line":"            i -= 1;","class":"lineCov","hits":"2","order":"1230","possible_hits":"2",},
{"lineNum":"   18","line":"        }"},
{"lineNum":"   19","line":"    }"},
{"lineNum":"   20","line":"}"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"// function where newlines are pre-empted by binary operators and other newlines"},
{"lineNum":"   23","line":"pub fn preemptBinaryOperator(tokens: *std.ArrayList(Token)) void {","class":"lineCov","hits":"1","order":"1233","possible_hits":"1",},
{"lineNum":"   24","line":"    // Loop through list of tokens..."},
{"lineNum":"   25","line":"    var i: usize = 0;","class":"lineCov","hits":"1","order":"1234","possible_hits":"1",},
{"lineNum":"   26","line":"    while (i < tokens.items.len - 1) : (i += 1) {","class":"lineCov","hits":"3","order":"1235","possible_hits":"3",},
{"lineNum":"   27","line":"        // If token at `i` is a newline, ..."},
{"lineNum":"   28","line":"        var token = tokens.items[i];","class":"lineCov","hits":"2","order":"1236","possible_hits":"2",},
{"lineNum":"   29","line":"        if (token.kind != .NEWLINE) {","class":"lineCov","hits":"1","order":"1237","possible_hits":"1",},
{"lineNum":"   30","line":"            continue;","class":"lineCov","hits":"1","order":"1242","possible_hits":"1",},
{"lineNum":"   31","line":"        }"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"        var next = tokens.items[i + 1];","class":"lineCov","hits":"1","order":"1238","possible_hits":"1",},
{"lineNum":"   34","line":"        for (_token.binaryOperators) |binopKind| {","class":"lineCov","hits":"1","order":"1239","possible_hits":"1",},
{"lineNum":"   35","line":"            if (next.kind == binopKind) {","class":"lineCov","hits":"1","order":"1240","possible_hits":"1",},
{"lineNum":"   36","line":"                // But the next token is a binary operator, remove the newline."},
{"lineNum":"   37","line":"                _ = tokens.orderedRemove(i);","class":"lineCov","hits":"1","order":"1769","possible_hits":"1",},
{"lineNum":"   38","line":"                i -= 1;","class":"lineCov","hits":"2","order":"1770","possible_hits":"2",},
{"lineNum":"   39","line":"                break;","class":"lineCov","hits":"3","order":"1241","possible_hits":"3",},
{"lineNum":"   40","line":"            }"},
{"lineNum":"   41","line":"        }"},
{"lineNum":"   42","line":"    }"},
{"lineNum":"   43","line":"}"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"// converts newlines to indent/dedent tokens"},
{"lineNum":"   46","line":"// a newline follows a sequence of one or more dedents"},
{"lineNum":"   47","line":"pub fn insertIndentDedents(tokens: *std.ArrayList(Token)) !void {","class":"lineCov","hits":"1","order":"1244","possible_hits":"1",},
{"lineNum":"   48","line":"    // Setup a stack of indentation sizes"},
{"lineNum":"   49","line":"    // This is like a precedence stack for infix => postfix transformation"},
{"lineNum":"   50","line":"    var stack: std.ArrayList(usize) = std.ArrayList(usize).init(tokens.allocator);","class":"lineCov","hits":"1","order":"1245","possible_hits":"1",},
{"lineNum":"   51","line":"    defer stack.deinit();","class":"linePartCov","hits":"1","order":"1266","possible_hits":"6",},
{"lineNum":"   52","line":"    try stack.append(1);","class":"linePartCov","hits":"1","order":"1246","possible_hits":"2",},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"    // Go through tokens and convert some newlines to INDENT and DEDENT tokens"},
{"lineNum":"   55","line":"    var i: usize = 0;","class":"lineCov","hits":"1","order":"1256","possible_hits":"1",},
{"lineNum":"   56","line":"    while (i < tokens.items.len) : (i += 1) {","class":"lineCov","hits":"3","order":"1257","possible_hits":"3",},
{"lineNum":"   57","line":"        var token = tokens.items[i];","class":"lineCov","hits":"2","order":"1258","possible_hits":"2",},
{"lineNum":"   58","line":"        switch (token.kind) {","class":"lineCov","hits":"2","order":"1259","possible_hits":"2",},
{"lineNum":"   59","line":"            .NEWLINE => {"},
{"lineNum":"   60","line":"                if (token.data.len == stack.getLast()) {","class":"lineCov","hits":"1","order":"1260","possible_hits":"1",},
{"lineNum":"   61","line":"                    // If token spaces == peek spaces => do nothing"},
{"lineNum":"   62","line":"                    // This implies this new line is a separator, not an indentor"},
{"lineNum":"   63","line":"                } else if (token.data.len > stack.getLast()) {","class":"lineCov","hits":"1","order":"1786","possible_hits":"1",},
{"lineNum":"   64","line":"                    // If token spaces >  peek spaces => append token spaces, replace with indent"},
{"lineNum":"   65","line":"                    try stack.append(token.data.len);","class":"linePartCov","hits":"1","order":"1787","possible_hits":"2",},
{"lineNum":"   66","line":"                    var slice: [1]Token = undefined;","class":"lineCov","hits":"1","order":"1788","possible_hits":"1",},
{"lineNum":"   67","line":"                    slice[0] = Token.create(\"\", .INDENT, token.span.line, token.span.col);","class":"lineCov","hits":"1","order":"1789","possible_hits":"1",},
{"lineNum":"   68","line":"                    try tokens.replaceRange(i, 1, &slice);","class":"linePartCov","hits":"1","order":"1790","possible_hits":"2",},
{"lineNum":"   69","line":"                } else if (token.data.len < stack.getLast()) {","class":"lineCov","hits":"1","order":"1796","possible_hits":"1",},
{"lineNum":"   70","line":"                    // If token spaces <  peek spaces => while token spaces < peek spaces {pop, replace with dedent}"},
{"lineNum":"   71","line":"                    _ = stack.pop();","class":"lineCov","hits":"1","order":"1797","possible_hits":"1",},
{"lineNum":"   72","line":"                    var slice: [2]Token = undefined;","class":"lineCov","hits":"1","order":"1802","possible_hits":"1",},
{"lineNum":"   73","line":"                    slice[0] = Token.create(\"\", .DEDENT, token.span.line, token.span.col);","class":"lineCov","hits":"1","order":"1803","possible_hits":"1",},
{"lineNum":"   74","line":"                    slice[1] = token;","class":"lineCov","hits":"1","order":"1804","possible_hits":"1",},
{"lineNum":"   75","line":"                    try tokens.replaceRange(i, 1, &slice);","class":"linePartCov","hits":"1","order":"1805","possible_hits":"2",},
{"lineNum":"   76","line":"                }"},
{"lineNum":"   77","line":"            },"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"            // Ignore other tokens besides newlines"},
{"lineNum":"   80","line":"            else => {},"},
{"lineNum":"   81","line":"        }"},
{"lineNum":"   82","line":"    }"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"    // The file might not end in a newline. If this is the case, the stack will"},
{"lineNum":"   85","line":"    // not be empty, and not enough dedents will be inserted."},
{"lineNum":"   86","line":"    // Insert one less than the stack length dedents before the EOF"},
{"lineNum":"   87","line":"    if (stack.items.len > 1) {","class":"lineCov","hits":"1","order":"1264","possible_hits":"1",},
{"lineNum":"   88","line":"        const lastToken = tokens.getLast();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   89","line":"        var dedents_to_insert: usize = stack.items.len - 1;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   90","line":"        while (dedents_to_insert > 0) : (dedents_to_insert -= 1) {","class":"linePartCov","hits":"1","order":"1265","possible_hits":"4",},
{"lineNum":"   91","line":"            try tokens.insert(tokens.items.len - 1, Token.create(\"\", .DEDENT, lastToken.span.line, lastToken.span.col));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   92","line":"        }"},
{"lineNum":"   93","line":"    }"},
{"lineNum":"   94","line":"}"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"pub fn doLayout(tokens: *std.ArrayList(Token)) !void {","class":"lineCov","hits":"1","order":"1222","possible_hits":"1",},
{"lineNum":"   97","line":"    condenseNewLines(tokens);","class":"lineCov","hits":"1","order":"1223","possible_hits":"1",},
{"lineNum":"   98","line":"    preemptBinaryOperator(tokens);","class":"lineCov","hits":"1","order":"1232","possible_hits":"1",},
{"lineNum":"   99","line":"    try insertIndentDedents(tokens);","class":"lineCov","hits":"1","order":"1243","possible_hits":"1",},
{"lineNum":"  100","line":"}"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"//////////////////////"},
{"lineNum":"  103","line":"// TESTS BEGIN HERE //"},
{"lineNum":"  104","line":"//////////////////////"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"test \"condenseNewLines\" {","class":"lineCov","hits":"1","order":"1737","possible_hits":"1",},
{"lineNum":"  107","line":"    const lexer = @import(\"lexer.zig\");"},
{"lineNum":"  108","line":"    var errors = errs.Errors.init(std.testing.allocator);","class":"lineCov","hits":"1","order":"1738","possible_hits":"1",},
{"lineNum":"  109","line":"    defer errors.deinit();","class":"linePartCov","hits":"1","order":"1764","possible_hits":"7",},
{"lineNum":"  110","line":"    var tokens = try lexer.getTokens(\"{\\n //comment\\n  \\n   }\", &errors, std.testing.allocator);","class":"linePartCov","hits":"1","order":"1739","possible_hits":"2",},
{"lineNum":"  111","line":"    defer tokens.deinit();","class":"linePartCov","hits":"1","order":"1763","possible_hits":"6",},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"    condenseNewLines(&tokens);","class":"lineCov","hits":"1","order":"1746","possible_hits":"1",},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    try std.testing.expectEqual(@as(usize, 4), tokens.items.len);","class":"linePartCov","hits":"1","order":"1756","possible_hits":"2",},
{"lineNum":"  116","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .L_BRACE), tokens.items[0].kind);","class":"linePartCov","hits":"1","order":"1759","possible_hits":"2",},
{"lineNum":"  117","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .NEWLINE), tokens.items[1].kind);","class":"linePartCov","hits":"1","order":"1760","possible_hits":"2",},
{"lineNum":"  118","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .R_BRACE), tokens.items[2].kind);","class":"linePartCov","hits":"1","order":"1761","possible_hits":"2",},
{"lineNum":"  119","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .EOF), tokens.items[3].kind);","class":"linePartCov","hits":"1","order":"1762","possible_hits":"2",},
{"lineNum":"  120","line":"}"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"test \"preemptBinaryOperator\" {","class":"lineCov","hits":"1","order":"1765","possible_hits":"1",},
{"lineNum":"  123","line":"    const lexer = @import(\"lexer.zig\");"},
{"lineNum":"  124","line":"    var errors = errs.Errors.init(std.testing.allocator);","class":"lineCov","hits":"1","order":"1766","possible_hits":"1",},
{"lineNum":"  125","line":"    defer errors.deinit();","class":"linePartCov","hits":"1","order":"1781","possible_hits":"11",},
{"lineNum":"  126","line":"    var tokens = try lexer.getTokens(\"x \\n + y \\n (y)\", &errors, std.testing.allocator);","class":"linePartCov","hits":"1","order":"1767","possible_hits":"2",},
{"lineNum":"  127","line":"    defer tokens.deinit();","class":"linePartCov","hits":"1","order":"1780","possible_hits":"10",},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    preemptBinaryOperator(&tokens);","class":"lineCov","hits":"1","order":"1768","possible_hits":"1",},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"    try std.testing.expectEqual(@as(usize, 8), tokens.items.len);","class":"linePartCov","hits":"1","order":"1771","possible_hits":"2",},
{"lineNum":"  132","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .IDENTIFIER), tokens.items[0].kind);","class":"linePartCov","hits":"1","order":"1772","possible_hits":"2",},
{"lineNum":"  133","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .PLUS), tokens.items[1].kind);","class":"linePartCov","hits":"1","order":"1773","possible_hits":"2",},
{"lineNum":"  134","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .IDENTIFIER), tokens.items[2].kind);","class":"linePartCov","hits":"1","order":"1774","possible_hits":"2",},
{"lineNum":"  135","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .NEWLINE), tokens.items[3].kind);","class":"linePartCov","hits":"1","order":"1775","possible_hits":"2",},
{"lineNum":"  136","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .L_PAREN), tokens.items[4].kind);","class":"linePartCov","hits":"1","order":"1776","possible_hits":"2",},
{"lineNum":"  137","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .IDENTIFIER), tokens.items[5].kind);","class":"linePartCov","hits":"1","order":"1777","possible_hits":"2",},
{"lineNum":"  138","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .R_PAREN), tokens.items[6].kind);","class":"linePartCov","hits":"1","order":"1778","possible_hits":"2",},
{"lineNum":"  139","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .EOF), tokens.items[7].kind);","class":"linePartCov","hits":"1","order":"1779","possible_hits":"2",},
{"lineNum":"  140","line":"}"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"test \"indentation\" {","class":"lineCov","hits":"1","order":"1782","possible_hits":"1",},
{"lineNum":"  143","line":"    const lexer = @import(\"lexer.zig\");"},
{"lineNum":"  144","line":"    var errors = errs.Errors.init(std.testing.allocator);","class":"lineCov","hits":"1","order":"1783","possible_hits":"1",},
{"lineNum":"  145","line":"    defer errors.deinit();","class":"linePartCov","hits":"1","order":"1834","possible_hits":"14",},
{"lineNum":"  146","line":"    var tokens = try lexer.getTokens(\"x\\n    y\\n        z\\na\", &errors, std.testing.allocator);","class":"linePartCov","hits":"1","order":"1784","possible_hits":"2",},
{"lineNum":"  147","line":"    defer tokens.deinit();","class":"linePartCov","hits":"1","order":"1833","possible_hits":"13",},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"    try insertIndentDedents(&tokens);","class":"linePartCov","hits":"1","order":"1785","possible_hits":"2",},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"    try std.testing.expectEqual(@as(usize, 10), tokens.items.len);","class":"linePartCov","hits":"1","order":"1822","possible_hits":"2",},
{"lineNum":"  152","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .IDENTIFIER), tokens.items[0].kind);","class":"linePartCov","hits":"1","order":"1823","possible_hits":"2",},
{"lineNum":"  153","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .INDENT), tokens.items[1].kind);","class":"linePartCov","hits":"1","order":"1824","possible_hits":"2",},
{"lineNum":"  154","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .IDENTIFIER), tokens.items[2].kind);","class":"linePartCov","hits":"1","order":"1825","possible_hits":"2",},
{"lineNum":"  155","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .INDENT), tokens.items[3].kind);","class":"linePartCov","hits":"1","order":"1826","possible_hits":"2",},
{"lineNum":"  156","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .IDENTIFIER), tokens.items[4].kind);","class":"linePartCov","hits":"1","order":"1827","possible_hits":"2",},
{"lineNum":"  157","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .DEDENT), tokens.items[5].kind);","class":"linePartCov","hits":"1","order":"1828","possible_hits":"2",},
{"lineNum":"  158","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .DEDENT), tokens.items[6].kind);","class":"linePartCov","hits":"1","order":"1829","possible_hits":"2",},
{"lineNum":"  159","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .NEWLINE), tokens.items[7].kind);","class":"linePartCov","hits":"1","order":"1830","possible_hits":"2",},
{"lineNum":"  160","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .IDENTIFIER), tokens.items[8].kind);","class":"linePartCov","hits":"1","order":"1831","possible_hits":"2",},
{"lineNum":"  161","line":"    try std.testing.expectEqual(@as(_token.TokenKind, .EOF), tokens.items[9].kind);","class":"linePartCov","hits":"1","order":"1832","possible_hits":"2",},
{"lineNum":"  162","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 93, "covered" : 90,};
var merged_data = [];
