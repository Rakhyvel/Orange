var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"../std.zig\");"},
{"lineNum":"    2","line":"const assert = std.debug.assert;"},
{"lineNum":"    3","line":"const mem = std.mem;"},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"pub fn Writer("},
{"lineNum":"    6","line":"    comptime Context: type,"},
{"lineNum":"    7","line":"    comptime WriteError: type,"},
{"lineNum":"    8","line":"    comptime writeFn: fn (context: Context, bytes: []const u8) WriteError!usize,"},
{"lineNum":"    9","line":") type {"},
{"lineNum":"   10","line":"    return struct {"},
{"lineNum":"   11","line":"        context: Context,"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"        const Self = @This();"},
{"lineNum":"   14","line":"        pub const Error = WriteError;"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"        pub fn write(self: Self, bytes: []const u8) Error!usize {","class":"lineCov","hits":"3","order":"620","possible_hits":"3",},
{"lineNum":"   17","line":"            return writeFn(self.context, bytes);","class":"lineCov","hits":"3","order":"621","possible_hits":"3",},
{"lineNum":"   18","line":"        }"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"        pub fn writeAll(self: Self, bytes: []const u8) Error!void {","class":"lineCov","hits":"3","order":"616","possible_hits":"3",},
{"lineNum":"   21","line":"            var index: usize = 0;","class":"lineCov","hits":"3","order":"617","possible_hits":"3",},
{"lineNum":"   22","line":"            while (index != bytes.len) {","class":"lineCov","hits":"3","order":"618","possible_hits":"3",},
{"lineNum":"   23","line":"                index += try self.write(bytes[index..]);","class":"lineCov","hits":"3","order":"619","possible_hits":"3",},
{"lineNum":"   24","line":"            }"},
{"lineNum":"   25","line":"        }"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"        pub fn print(self: Self, comptime format: []const u8, args: anytype) Error!void {","class":"linePartCov","hits":"1","order":"2089","possible_hits":"50",},
{"lineNum":"   28","line":"            return std.fmt.format(self, format, args);","class":"linePartCov","hits":"1","order":"2090","possible_hits":"50",},
{"lineNum":"   29","line":"        }"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"        pub fn writeByte(self: Self, byte: u8) Error!void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   32","line":"            const array = [1]u8{byte};","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   33","line":"            return self.writeAll(&array);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   34","line":"        }"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"        pub fn writeByteNTimes(self: Self, byte: u8, n: usize) Error!void {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   37","line":"            var bytes: [256]u8 = undefined;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   38","line":"            mem.set(u8, bytes[0..], byte);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"            var remaining: usize = n;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   41","line":"            while (remaining > 0) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   42","line":"                const to_write = std.math.min(remaining, bytes.len);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   43","line":"                try self.writeAll(bytes[0..to_write]);","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   44","line":"                remaining -= to_write;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   45","line":"            }"},
{"lineNum":"   46","line":"        }"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"        /// Write a native-endian integer."},
{"lineNum":"   49","line":"        /// TODO audit non-power-of-two int sizes"},
{"lineNum":"   50","line":"        pub fn writeIntNative(self: Self, comptime T: type, value: T) Error!void {"},
{"lineNum":"   51","line":"            var bytes: [(@typeInfo(T).Int.bits + 7) / 8]u8 = undefined;"},
{"lineNum":"   52","line":"            mem.writeIntNative(T, &bytes, value);"},
{"lineNum":"   53","line":"            return self.writeAll(&bytes);"},
{"lineNum":"   54","line":"        }"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"        /// Write a foreign-endian integer."},
{"lineNum":"   57","line":"        /// TODO audit non-power-of-two int sizes"},
{"lineNum":"   58","line":"        pub fn writeIntForeign(self: Self, comptime T: type, value: T) Error!void {"},
{"lineNum":"   59","line":"            var bytes: [(@typeInfo(T).Int.bits + 7) / 8]u8 = undefined;"},
{"lineNum":"   60","line":"            mem.writeIntForeign(T, &bytes, value);"},
{"lineNum":"   61","line":"            return self.writeAll(&bytes);"},
{"lineNum":"   62","line":"        }"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"        /// TODO audit non-power-of-two int sizes"},
{"lineNum":"   65","line":"        pub fn writeIntLittle(self: Self, comptime T: type, value: T) Error!void {"},
{"lineNum":"   66","line":"            var bytes: [(@typeInfo(T).Int.bits + 7) / 8]u8 = undefined;"},
{"lineNum":"   67","line":"            mem.writeIntLittle(T, &bytes, value);"},
{"lineNum":"   68","line":"            return self.writeAll(&bytes);"},
{"lineNum":"   69","line":"        }"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"        /// TODO audit non-power-of-two int sizes"},
{"lineNum":"   72","line":"        pub fn writeIntBig(self: Self, comptime T: type, value: T) Error!void {"},
{"lineNum":"   73","line":"            var bytes: [(@typeInfo(T).Int.bits + 7) / 8]u8 = undefined;"},
{"lineNum":"   74","line":"            mem.writeIntBig(T, &bytes, value);"},
{"lineNum":"   75","line":"            return self.writeAll(&bytes);"},
{"lineNum":"   76","line":"        }"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"        /// TODO audit non-power-of-two int sizes"},
{"lineNum":"   79","line":"        pub fn writeInt(self: Self, comptime T: type, value: T, endian: std.builtin.Endian) Error!void {"},
{"lineNum":"   80","line":"            var bytes: [(@typeInfo(T).Int.bits + 7) / 8]u8 = undefined;"},
{"lineNum":"   81","line":"            mem.writeInt(T, &bytes, value, endian);"},
{"lineNum":"   82","line":"            return self.writeAll(&bytes);"},
{"lineNum":"   83","line":"        }"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"        pub fn writeStruct(self: Self, value: anytype) Error!void {"},
{"lineNum":"   86","line":"            // Only extern and packed structs have defined in-memory layout."},
{"lineNum":"   87","line":"            comptime assert(@typeInfo(@TypeOf(value)).Struct.layout != .Auto);"},
{"lineNum":"   88","line":"            return self.writeAll(mem.asBytes(&value));"},
{"lineNum":"   89","line":"        }"},
{"lineNum":"   90","line":"    };"},
{"lineNum":"   91","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 19, "covered" : 8,};
var merged_data = [];
