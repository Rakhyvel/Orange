var data = {lines:[
{"lineNum":"    1","line":"// This file is included in the compilation unit when exporting an executable."},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"const root = @import(\"root\");"},
{"lineNum":"    4","line":"const std = @import(\"std.zig\");"},
{"lineNum":"    5","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    6","line":"const assert = std.debug.assert;"},
{"lineNum":"    7","line":"const uefi = std.os.uefi;"},
{"lineNum":"    8","line":"const elf = std.elf;"},
{"lineNum":"    9","line":"const tlcsprng = @import(\"crypto/tlcsprng.zig\");"},
{"lineNum":"   10","line":"const native_arch = builtin.cpu.arch;"},
{"lineNum":"   11","line":"const native_os = builtin.os.tag;"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"var argc_argv_ptr: [*]usize = undefined;"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"const start_sym_name = if (native_arch.isMIPS()) \"__start\" else \"_start\";"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"// The self-hosted compiler is not fully capable of handling all of this start.zig file."},
{"lineNum":"   18","line":"// Until then, we have simplified logic here for self-hosted. TODO remove this once"},
{"lineNum":"   19","line":"// self-hosted is capable enough to handle all of the real start.zig logic."},
{"lineNum":"   20","line":"pub const simplified_logic ="},
{"lineNum":"   21","line":"    (builtin.zig_backend == .stage2_x86_64 and (builtin.link_libc or builtin.os.tag == .plan9)) or"},
{"lineNum":"   22","line":"    builtin.zig_backend == .stage2_x86 or"},
{"lineNum":"   23","line":"    builtin.zig_backend == .stage2_aarch64 or"},
{"lineNum":"   24","line":"    builtin.zig_backend == .stage2_arm or"},
{"lineNum":"   25","line":"    builtin.zig_backend == .stage2_riscv64 or"},
{"lineNum":"   26","line":"    builtin.zig_backend == .stage2_sparc64 or"},
{"lineNum":"   27","line":"    builtin.cpu.arch == .spirv32 or"},
{"lineNum":"   28","line":"    builtin.cpu.arch == .spirv64;"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"comptime {"},
{"lineNum":"   31","line":"    // No matter what, we import the root file, so that any export, test, comptime"},
{"lineNum":"   32","line":"    // decls there get run."},
{"lineNum":"   33","line":"    _ = root;"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"    if (simplified_logic) {"},
{"lineNum":"   36","line":"        if (builtin.output_mode == .Exe) {"},
{"lineNum":"   37","line":"            if ((builtin.link_libc or builtin.object_format == .c) and @hasDecl(root, \"main\")) {"},
{"lineNum":"   38","line":"                if (@typeInfo(@TypeOf(root.main)).Fn.calling_convention != .C) {"},
{"lineNum":"   39","line":"                    @export(main2, .{ .name = \"main\" });"},
{"lineNum":"   40","line":"                }"},
{"lineNum":"   41","line":"            } else if (builtin.os.tag == .windows) {"},
{"lineNum":"   42","line":"                if (!@hasDecl(root, \"wWinMainCRTStartup\") and !@hasDecl(root, \"mainCRTStartup\")) {"},
{"lineNum":"   43","line":"                    @export(wWinMainCRTStartup2, .{ .name = \"wWinMainCRTStartup\" });"},
{"lineNum":"   44","line":"                }"},
{"lineNum":"   45","line":"            } else if (builtin.os.tag == .opencl) {"},
{"lineNum":"   46","line":"                if (@hasDecl(root, \"main\"))"},
{"lineNum":"   47","line":"                    @export(spirvMain2, .{ .name = \"main\" });"},
{"lineNum":"   48","line":"            } else {"},
{"lineNum":"   49","line":"                if (!@hasDecl(root, \"_start\")) {"},
{"lineNum":"   50","line":"                    @export(_start2, .{ .name = \"_start\" });"},
{"lineNum":"   51","line":"                }"},
{"lineNum":"   52","line":"            }"},
{"lineNum":"   53","line":"        }"},
{"lineNum":"   54","line":"    } else {"},
{"lineNum":"   55","line":"        if (builtin.output_mode == .Lib and builtin.link_mode == .Dynamic) {"},
{"lineNum":"   56","line":"            if (native_os == .windows and !@hasDecl(root, \"_DllMainCRTStartup\")) {"},
{"lineNum":"   57","line":"                @export(_DllMainCRTStartup, .{ .name = \"_DllMainCRTStartup\" });"},
{"lineNum":"   58","line":"            }"},
{"lineNum":"   59","line":"        } else if (builtin.output_mode == .Exe or @hasDecl(root, \"main\")) {"},
{"lineNum":"   60","line":"            if (builtin.link_libc and @hasDecl(root, \"main\")) {"},
{"lineNum":"   61","line":"                if (native_arch.isWasm()) {"},
{"lineNum":"   62","line":"                    @export(mainWithoutEnv, .{ .name = \"main\" });"},
{"lineNum":"   63","line":"                } else if (@typeInfo(@TypeOf(root.main)).Fn.calling_convention != .C) {"},
{"lineNum":"   64","line":"                    @export(main, .{ .name = \"main\" });"},
{"lineNum":"   65","line":"                }"},
{"lineNum":"   66","line":"            } else if (native_os == .windows) {"},
{"lineNum":"   67","line":"                if (!@hasDecl(root, \"WinMain\") and !@hasDecl(root, \"WinMainCRTStartup\") and"},
{"lineNum":"   68","line":"                    !@hasDecl(root, \"wWinMain\") and !@hasDecl(root, \"wWinMainCRTStartup\"))"},
{"lineNum":"   69","line":"                {"},
{"lineNum":"   70","line":"                    @export(WinStartup, .{ .name = \"wWinMainCRTStartup\" });"},
{"lineNum":"   71","line":"                } else if (@hasDecl(root, \"WinMain\") and !@hasDecl(root, \"WinMainCRTStartup\") and"},
{"lineNum":"   72","line":"                    !@hasDecl(root, \"wWinMain\") and !@hasDecl(root, \"wWinMainCRTStartup\"))"},
{"lineNum":"   73","line":"                {"},
{"lineNum":"   74","line":"                    @compileError(\"WinMain not supported; declare wWinMain or main instead\");"},
{"lineNum":"   75","line":"                } else if (@hasDecl(root, \"wWinMain\") and !@hasDecl(root, \"wWinMainCRTStartup\") and"},
{"lineNum":"   76","line":"                    !@hasDecl(root, \"WinMain\") and !@hasDecl(root, \"WinMainCRTStartup\"))"},
{"lineNum":"   77","line":"                {"},
{"lineNum":"   78","line":"                    @export(wWinMainCRTStartup, .{ .name = \"wWinMainCRTStartup\" });"},
{"lineNum":"   79","line":"                }"},
{"lineNum":"   80","line":"            } else if (native_os == .uefi) {"},
{"lineNum":"   81","line":"                if (!@hasDecl(root, \"EfiMain\")) @export(EfiMain, .{ .name = \"EfiMain\" });"},
{"lineNum":"   82","line":"            } else if (native_os == .wasi) {"},
{"lineNum":"   83","line":"                const wasm_start_sym = switch (builtin.wasi_exec_model) {"},
{"lineNum":"   84","line":"                    .reactor => \"_initialize\","},
{"lineNum":"   85","line":"                    .command => \"_start\","},
{"lineNum":"   86","line":"                };"},
{"lineNum":"   87","line":"                if (!@hasDecl(root, wasm_start_sym)) {"},
{"lineNum":"   88","line":"                    @export(wasi_start, .{ .name = wasm_start_sym });"},
{"lineNum":"   89","line":"                }"},
{"lineNum":"   90","line":"            } else if (native_arch.isWasm() and native_os == .freestanding) {"},
{"lineNum":"   91","line":"                if (!@hasDecl(root, start_sym_name)) @export(wasm_freestanding_start, .{ .name = start_sym_name });"},
{"lineNum":"   92","line":"            } else if (native_os != .other and native_os != .freestanding) {"},
{"lineNum":"   93","line":"                if (!@hasDecl(root, start_sym_name)) @export(_start, .{ .name = start_sym_name });"},
{"lineNum":"   94","line":"            }"},
{"lineNum":"   95","line":"        }"},
{"lineNum":"   96","line":"    }"},
{"lineNum":"   97","line":"}"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"// Simplified start code for stage2 until it supports more language features ///"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"fn main2() callconv(.C) c_int {"},
{"lineNum":"  102","line":"    root.main();"},
{"lineNum":"  103","line":"    return 0;"},
{"lineNum":"  104","line":"}"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"fn _start2() callconv(.Naked) noreturn {"},
{"lineNum":"  107","line":"    callMain2();"},
{"lineNum":"  108","line":"}"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"fn callMain2() noreturn {"},
{"lineNum":"  111","line":"    @setAlignStack(16);"},
{"lineNum":"  112","line":"    root.main();"},
{"lineNum":"  113","line":"    exit2(0);"},
{"lineNum":"  114","line":"}"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"fn spirvMain2() callconv(.Kernel) void {"},
{"lineNum":"  117","line":"    root.main();"},
{"lineNum":"  118","line":"}"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"fn wWinMainCRTStartup2() callconv(.C) noreturn {"},
{"lineNum":"  121","line":"    root.main();"},
{"lineNum":"  122","line":"    exit2(0);"},
{"lineNum":"  123","line":"}"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"fn exit2(code: usize) noreturn {"},
{"lineNum":"  126","line":"    switch (native_os) {"},
{"lineNum":"  127","line":"        .linux => switch (builtin.cpu.arch) {"},
{"lineNum":"  128","line":"            .x86_64 => {"},
{"lineNum":"  129","line":"                asm volatile (\"syscall\""},
{"lineNum":"  130","line":"                    :"},
{"lineNum":"  131","line":"                    : [number] \"{rax}\" (231),"},
{"lineNum":"  132","line":"                      [arg1] \"{rdi}\" (code),"},
{"lineNum":"  133","line":"                    : \"rcx\", \"r11\", \"memory\""},
{"lineNum":"  134","line":"                );"},
{"lineNum":"  135","line":"            },"},
{"lineNum":"  136","line":"            .arm => {"},
{"lineNum":"  137","line":"                asm volatile (\"svc #0\""},
{"lineNum":"  138","line":"                    :"},
{"lineNum":"  139","line":"                    : [number] \"{r7}\" (1),"},
{"lineNum":"  140","line":"                      [arg1] \"{r0}\" (code),"},
{"lineNum":"  141","line":"                    : \"memory\""},
{"lineNum":"  142","line":"                );"},
{"lineNum":"  143","line":"            },"},
{"lineNum":"  144","line":"            .aarch64 => {"},
{"lineNum":"  145","line":"                asm volatile (\"svc #0\""},
{"lineNum":"  146","line":"                    :"},
{"lineNum":"  147","line":"                    : [number] \"{x8}\" (93),"},
{"lineNum":"  148","line":"                      [arg1] \"{x0}\" (code),"},
{"lineNum":"  149","line":"                    : \"memory\", \"cc\""},
{"lineNum":"  150","line":"                );"},
{"lineNum":"  151","line":"            },"},
{"lineNum":"  152","line":"            .riscv64 => {"},
{"lineNum":"  153","line":"                asm volatile (\"ecall\""},
{"lineNum":"  154","line":"                    :"},
{"lineNum":"  155","line":"                    : [number] \"{a7}\" (94),"},
{"lineNum":"  156","line":"                      [arg1] \"{a0}\" (0),"},
{"lineNum":"  157","line":"                    : \"rcx\", \"r11\", \"memory\""},
{"lineNum":"  158","line":"                );"},
{"lineNum":"  159","line":"            },"},
{"lineNum":"  160","line":"            .sparc64 => {"},
{"lineNum":"  161","line":"                asm volatile (\"ta 0x6d\""},
{"lineNum":"  162","line":"                    :"},
{"lineNum":"  163","line":"                    : [number] \"{g1}\" (1),"},
{"lineNum":"  164","line":"                      [arg1] \"{o0}\" (code),"},
{"lineNum":"  165","line":"                    : \"o0\", \"o1\", \"o2\", \"o3\", \"o4\", \"o5\", \"o6\", \"o7\", \"memory\""},
{"lineNum":"  166","line":"                );"},
{"lineNum":"  167","line":"            },"},
{"lineNum":"  168","line":"            else => @compileError(\"TODO\"),"},
{"lineNum":"  169","line":"        },"},
{"lineNum":"  170","line":"        // exits(0)"},
{"lineNum":"  171","line":"        .plan9 => switch (builtin.cpu.arch) {"},
{"lineNum":"  172","line":"            .x86_64 => {"},
{"lineNum":"  173","line":"                asm volatile ("},
{"lineNum":"  174","line":"                    \\\\push $0"},
{"lineNum":"  175","line":"                    \\\\push $0"},
{"lineNum":"  176","line":"                    \\\\syscall"},
{"lineNum":"  177","line":"                    :"},
{"lineNum":"  178","line":"                    : [syscall_number] \"{rbp}\" (8),"},
{"lineNum":"  179","line":"                    : \"rcx\", \"r11\", \"memory\""},
{"lineNum":"  180","line":"                );"},
{"lineNum":"  181","line":"            },"},
{"lineNum":"  182","line":"            // TODO once we get stack setting with assembly on"},
{"lineNum":"  183","line":"            // arm, exit with 0 instead of stack garbage"},
{"lineNum":"  184","line":"            .aarch64 => {"},
{"lineNum":"  185","line":"                asm volatile (\"svc #0\""},
{"lineNum":"  186","line":"                    :"},
{"lineNum":"  187","line":"                    : [exit] \"{x0}\" (0x08),"},
{"lineNum":"  188","line":"                    : \"memory\", \"cc\""},
{"lineNum":"  189","line":"                );"},
{"lineNum":"  190","line":"            },"},
{"lineNum":"  191","line":"            else => @compileError(\"TODO\"),"},
{"lineNum":"  192","line":"        },"},
{"lineNum":"  193","line":"        .windows => {"},
{"lineNum":"  194","line":"            ExitProcess(@truncate(u32, code));"},
{"lineNum":"  195","line":"        },"},
{"lineNum":"  196","line":"        else => @compileError(\"TODO\"),"},
{"lineNum":"  197","line":"    }"},
{"lineNum":"  198","line":"    unreachable;"},
{"lineNum":"  199","line":"}"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"extern \"kernel32\" fn ExitProcess(exit_code: u32) callconv(.C) noreturn;"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"////////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"fn _DllMainCRTStartup("},
{"lineNum":"  206","line":"    hinstDLL: std.os.windows.HINSTANCE,"},
{"lineNum":"  207","line":"    fdwReason: std.os.windows.DWORD,"},
{"lineNum":"  208","line":"    lpReserved: std.os.windows.LPVOID,"},
{"lineNum":"  209","line":") callconv(std.os.windows.WINAPI) std.os.windows.BOOL {"},
{"lineNum":"  210","line":"    if (!builtin.single_threaded and !builtin.link_libc) {"},
{"lineNum":"  211","line":"        _ = @import(\"start_windows_tls.zig\");"},
{"lineNum":"  212","line":"    }"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"    if (@hasDecl(root, \"DllMain\")) {"},
{"lineNum":"  215","line":"        return root.DllMain(hinstDLL, fdwReason, lpReserved);"},
{"lineNum":"  216","line":"    }"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"    return std.os.windows.TRUE;"},
{"lineNum":"  219","line":"}"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"fn wasm_freestanding_start() callconv(.C) void {"},
{"lineNum":"  222","line":"    // This is marked inline because for some reason LLVM in"},
{"lineNum":"  223","line":"    // release mode fails to inline it, and we want fewer call frames in stack traces."},
{"lineNum":"  224","line":"    _ = @call(.always_inline, callMain, .{});"},
{"lineNum":"  225","line":"}"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"fn wasi_start() callconv(.C) void {"},
{"lineNum":"  228","line":"    // The function call is marked inline because for some reason LLVM in"},
{"lineNum":"  229","line":"    // release mode fails to inline it, and we want fewer call frames in stack traces."},
{"lineNum":"  230","line":"    switch (builtin.wasi_exec_model) {"},
{"lineNum":"  231","line":"        .reactor => _ = @call(.always_inline, callMain, .{}),"},
{"lineNum":"  232","line":"        .command => std.os.wasi.proc_exit(@call(.always_inline, callMain, .{})),"},
{"lineNum":"  233","line":"    }"},
{"lineNum":"  234","line":"}"},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"fn EfiMain(handle: uefi.Handle, system_table: *uefi.tables.SystemTable) callconv(.C) usize {"},
{"lineNum":"  237","line":"    uefi.handle = handle;"},
{"lineNum":"  238","line":"    uefi.system_table = system_table;"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"    switch (@typeInfo(@TypeOf(root.main)).Fn.return_type.?) {"},
{"lineNum":"  241","line":"        noreturn => {"},
{"lineNum":"  242","line":"            root.main();"},
{"lineNum":"  243","line":"        },"},
{"lineNum":"  244","line":"        void => {"},
{"lineNum":"  245","line":"            root.main();"},
{"lineNum":"  246","line":"            return 0;"},
{"lineNum":"  247","line":"        },"},
{"lineNum":"  248","line":"        usize => {"},
{"lineNum":"  249","line":"            return root.main();"},
{"lineNum":"  250","line":"        },"},
{"lineNum":"  251","line":"        uefi.Status => {"},
{"lineNum":"  252","line":"            return @enumToInt(root.main());"},
{"lineNum":"  253","line":"        },"},
{"lineNum":"  254","line":"        else => @compileError(\"expected return type of main to be \'void\', \'noreturn\', \'usize\', or \'std.os.uefi.Status\'\"),"},
{"lineNum":"  255","line":"    }"},
{"lineNum":"  256","line":"}"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"fn _start() callconv(.Naked) noreturn {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  259","line":"    switch (builtin.zig_backend) {"},
{"lineNum":"  260","line":"        .stage2_c => {"},
{"lineNum":"  261","line":"            @export(argc_argv_ptr, .{ .name = \"argc_argv_ptr\" });"},
{"lineNum":"  262","line":"            @export(posixCallMainAndExit, .{ .name = \"_posixCallMainAndExit\" });"},
{"lineNum":"  263","line":"            switch (native_arch) {"},
{"lineNum":"  264","line":"                .x86_64 => asm volatile ("},
{"lineNum":"  265","line":"                    \\\\ xorl %%ebp, %%ebp"},
{"lineNum":"  266","line":"                    \\\\ movq %%rsp, argc_argv_ptr"},
{"lineNum":"  267","line":"                    \\\\ andq $-16, %%rsp"},
{"lineNum":"  268","line":"                    \\\\ call _posixCallMainAndExit"},
{"lineNum":"  269","line":"                ),"},
{"lineNum":"  270","line":"                .x86 => asm volatile ("},
{"lineNum":"  271","line":"                    \\\\ xorl %%ebp, %%ebp"},
{"lineNum":"  272","line":"                    \\\\ movl %%esp, argc_argv_ptr"},
{"lineNum":"  273","line":"                    \\\\ andl $-16, %%esp"},
{"lineNum":"  274","line":"                    \\\\ jmp _posixCallMainAndExit"},
{"lineNum":"  275","line":"                ),"},
{"lineNum":"  276","line":"                .aarch64, .aarch64_be => asm volatile ("},
{"lineNum":"  277","line":"                    \\\\ mov fp, #0"},
{"lineNum":"  278","line":"                    \\\\ mov lr, #0"},
{"lineNum":"  279","line":"                    \\\\ mov x0, sp"},
{"lineNum":"  280","line":"                    \\\\ adrp x1, argc_argv_ptr"},
{"lineNum":"  281","line":"                    \\\\ str x0, [x1, :lo12:argc_argv_ptr]"},
{"lineNum":"  282","line":"                    \\\\ b _posixCallMainAndExit"},
{"lineNum":"  283","line":"                ),"},
{"lineNum":"  284","line":"                .arm, .armeb, .thumb => asm volatile ("},
{"lineNum":"  285","line":"                    \\\\ mov fp, #0"},
{"lineNum":"  286","line":"                    \\\\ mov lr, #0"},
{"lineNum":"  287","line":"                    \\\\ str sp, argc_argv_ptr"},
{"lineNum":"  288","line":"                    \\\\ and sp, #-16"},
{"lineNum":"  289","line":"                    \\\\ b _posixCallMainAndExit"},
{"lineNum":"  290","line":"                ),"},
{"lineNum":"  291","line":"                else => @compileError(\"unsupported arch\"),"},
{"lineNum":"  292","line":"            }"},
{"lineNum":"  293","line":"            unreachable;"},
{"lineNum":"  294","line":"        },"},
{"lineNum":"  295","line":"        else => switch (native_arch) {"},
{"lineNum":"  296","line":"            .x86_64 => {"},
{"lineNum":"  297","line":"                argc_argv_ptr = asm volatile (","class":"lineCov","hits":"1","order":"1","possible_hits":"1",},
{"lineNum":"  298","line":"                    \\\\ xor %%ebp, %%ebp"},
{"lineNum":"  299","line":"                    : [argc] \"={rsp}\" (-> [*]usize),"},
{"lineNum":"  300","line":"                );"},
{"lineNum":"  301","line":"            },"},
{"lineNum":"  302","line":"            .x86 => {"},
{"lineNum":"  303","line":"                argc_argv_ptr = asm volatile ("},
{"lineNum":"  304","line":"                    \\\\ xor %%ebp, %%ebp"},
{"lineNum":"  305","line":"                    : [argc] \"={esp}\" (-> [*]usize),"},
{"lineNum":"  306","line":"                );"},
{"lineNum":"  307","line":"            },"},
{"lineNum":"  308","line":"            .aarch64, .aarch64_be, .arm, .armeb, .thumb => {"},
{"lineNum":"  309","line":"                argc_argv_ptr = asm volatile ("},
{"lineNum":"  310","line":"                    \\\\ mov fp, #0"},
{"lineNum":"  311","line":"                    \\\\ mov lr, #0"},
{"lineNum":"  312","line":"                    : [argc] \"={sp}\" (-> [*]usize),"},
{"lineNum":"  313","line":"                );"},
{"lineNum":"  314","line":"            },"},
{"lineNum":"  315","line":"            .riscv64 => {"},
{"lineNum":"  316","line":"                argc_argv_ptr = asm volatile ("},
{"lineNum":"  317","line":"                    \\\\ li s0, 0"},
{"lineNum":"  318","line":"                    \\\\ li ra, 0"},
{"lineNum":"  319","line":"                    : [argc] \"={sp}\" (-> [*]usize),"},
{"lineNum":"  320","line":"                );"},
{"lineNum":"  321","line":"            },"},
{"lineNum":"  322","line":"            .mips, .mipsel, .mips64, .mips64el => {"},
{"lineNum":"  323","line":"                // The lr is already zeroed on entry, as specified by the ABI."},
{"lineNum":"  324","line":"                argc_argv_ptr = asm volatile ("},
{"lineNum":"  325","line":"                    \\\\ move $fp, $0"},
{"lineNum":"  326","line":"                    : [argc] \"={sp}\" (-> [*]usize),"},
{"lineNum":"  327","line":"                );"},
{"lineNum":"  328","line":"            },"},
{"lineNum":"  329","line":"            .powerpc => {"},
{"lineNum":"  330","line":"                // Setup the initial stack frame and clear the back chain pointer."},
{"lineNum":"  331","line":"                argc_argv_ptr = asm volatile ("},
{"lineNum":"  332","line":"                    \\\\ mr 4, 1"},
{"lineNum":"  333","line":"                    \\\\ li 0, 0"},
{"lineNum":"  334","line":"                    \\\\ stwu 1,-16(1)"},
{"lineNum":"  335","line":"                    \\\\ stw 0, 0(1)"},
{"lineNum":"  336","line":"                    \\\\ mtlr 0"},
{"lineNum":"  337","line":"                    : [argc] \"={r4}\" (-> [*]usize),"},
{"lineNum":"  338","line":"                    :"},
{"lineNum":"  339","line":"                    : \"r0\""},
{"lineNum":"  340","line":"                );"},
{"lineNum":"  341","line":"            },"},
{"lineNum":"  342","line":"            .powerpc64le => {"},
{"lineNum":"  343","line":"                // Setup the initial stack frame and clear the back chain pointer."},
{"lineNum":"  344","line":"                // TODO: Support powerpc64 (big endian) on ELFv2."},
{"lineNum":"  345","line":"                argc_argv_ptr = asm volatile ("},
{"lineNum":"  346","line":"                    \\\\ mr 4, 1"},
{"lineNum":"  347","line":"                    \\\\ li 0, 0"},
{"lineNum":"  348","line":"                    \\\\ stdu 0, -32(1)"},
{"lineNum":"  349","line":"                    \\\\ mtlr 0"},
{"lineNum":"  350","line":"                    : [argc] \"={r4}\" (-> [*]usize),"},
{"lineNum":"  351","line":"                    :"},
{"lineNum":"  352","line":"                    : \"r0\""},
{"lineNum":"  353","line":"                );"},
{"lineNum":"  354","line":"            },"},
{"lineNum":"  355","line":"            .sparc64 => {"},
{"lineNum":"  356","line":"                // argc is stored after a register window (16 registers) plus stack bias"},
{"lineNum":"  357","line":"                argc_argv_ptr = asm ("},
{"lineNum":"  358","line":"                    \\\\ mov %%g0, %%i6"},
{"lineNum":"  359","line":"                    \\\\ add %%o6, 2175, %[argc]"},
{"lineNum":"  360","line":"                    : [argc] \"=r\" (-> [*]usize),"},
{"lineNum":"  361","line":"                );"},
{"lineNum":"  362","line":"            },"},
{"lineNum":"  363","line":"            else => @compileError(\"unsupported arch\"),"},
{"lineNum":"  364","line":"        },"},
{"lineNum":"  365","line":"    }"},
{"lineNum":"  366","line":"    // If LLVM inlines stack variables into _start, they will overwrite"},
{"lineNum":"  367","line":"    // the command line argument data."},
{"lineNum":"  368","line":"    @call(.never_inline, posixCallMainAndExit, .{});","class":"lineCov","hits":"1","order":"2","possible_hits":"1",},
{"lineNum":"  369","line":"}"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"fn WinStartup() callconv(std.os.windows.WINAPI) noreturn {"},
{"lineNum":"  372","line":"    @setAlignStack(16);"},
{"lineNum":"  373","line":"    if (!builtin.single_threaded and !builtin.link_libc) {"},
{"lineNum":"  374","line":"        _ = @import(\"start_windows_tls.zig\");"},
{"lineNum":"  375","line":"    }"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"    std.debug.maybeEnableSegfaultHandler();"},
{"lineNum":"  378","line":""},
{"lineNum":"  379","line":"    std.os.windows.kernel32.ExitProcess(initEventLoopAndCallMain());"},
{"lineNum":"  380","line":"}"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"fn wWinMainCRTStartup() callconv(std.os.windows.WINAPI) noreturn {"},
{"lineNum":"  383","line":"    @setAlignStack(16);"},
{"lineNum":"  384","line":"    if (!builtin.single_threaded and !builtin.link_libc) {"},
{"lineNum":"  385","line":"        _ = @import(\"start_windows_tls.zig\");"},
{"lineNum":"  386","line":"    }"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"    std.debug.maybeEnableSegfaultHandler();"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"    const result: std.os.windows.INT = initEventLoopAndCallWinMain();"},
{"lineNum":"  391","line":"    std.os.windows.kernel32.ExitProcess(@bitCast(std.os.windows.UINT, result));"},
{"lineNum":"  392","line":"}"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"fn posixCallMainAndExit() callconv(.C) noreturn {","class":"lineCov","hits":"1","order":"3","possible_hits":"1",},
{"lineNum":"  395","line":"    @setAlignStack(16);"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"    const argc = argc_argv_ptr[0];","class":"lineCov","hits":"1","order":"4","possible_hits":"1",},
{"lineNum":"  398","line":"    const argv = @ptrCast([*][*:0]u8, argc_argv_ptr + 1);","class":"lineCov","hits":"1","order":"5","possible_hits":"1",},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"    const envp_optional = @ptrCast([*:null]?[*:0]u8, @alignCast(@alignOf(usize), argv + argc + 1));","class":"lineCov","hits":"1","order":"6","possible_hits":"1",},
{"lineNum":"  401","line":"    var envp_count: usize = 0;","class":"lineCov","hits":"1","order":"7","possible_hits":"1",},
{"lineNum":"  402","line":"    while (envp_optional[envp_count]) |_| : (envp_count += 1) {}","class":"lineCov","hits":"1","order":"8","possible_hits":"1",},
{"lineNum":"  403","line":"    const envp = @ptrCast([*][*:0]u8, envp_optional)[0..envp_count];","class":"lineCov","hits":"1","order":"9","possible_hits":"1",},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"    if (native_os == .linux) {"},
{"lineNum":"  406","line":"        // Find the beginning of the auxiliary vector"},
{"lineNum":"  407","line":"        const auxv = @ptrCast([*]elf.Auxv, @alignCast(@alignOf(usize), envp.ptr + envp_count + 1));","class":"lineCov","hits":"1","order":"10","possible_hits":"1",},
{"lineNum":"  408","line":"        std.os.linux.elf_aux_maybe = auxv;","class":"lineCov","hits":"1","order":"11","possible_hits":"1",},
{"lineNum":"  409","line":""},
{"lineNum":"  410","line":"        var at_hwcap: usize = 0;","class":"lineCov","hits":"1","order":"12","possible_hits":"1",},
{"lineNum":"  411","line":"        const phdrs = init: {"},
{"lineNum":"  412","line":"            var i: usize = 0;","class":"lineCov","hits":"1","order":"13","possible_hits":"1",},
{"lineNum":"  413","line":"            var at_phdr: usize = 0;","class":"lineCov","hits":"1","order":"14","possible_hits":"1",},
{"lineNum":"  414","line":"            var at_phnum: usize = 0;","class":"lineCov","hits":"1","order":"15","possible_hits":"1",},
{"lineNum":"  415","line":"            while (auxv[i].a_type != elf.AT_NULL) : (i += 1) {","class":"lineCov","hits":"3","order":"16","possible_hits":"3",},
{"lineNum":"  416","line":"                switch (auxv[i].a_type) {","class":"lineCov","hits":"1","order":"17","possible_hits":"1",},
{"lineNum":"  417","line":"                    elf.AT_PHNUM => at_phnum = auxv[i].a_un.a_val,","class":"lineCov","hits":"1","order":"20","possible_hits":"1",},
{"lineNum":"  418","line":"                    elf.AT_PHDR => at_phdr = auxv[i].a_un.a_val,","class":"lineCov","hits":"1","order":"19","possible_hits":"1",},
{"lineNum":"  419","line":"                    elf.AT_HWCAP => at_hwcap = auxv[i].a_un.a_val,","class":"lineCov","hits":"2","order":"18","possible_hits":"2",},
{"lineNum":"  420","line":"                    else => continue,"},
{"lineNum":"  421","line":"                }"},
{"lineNum":"  422","line":"            }"},
{"lineNum":"  423","line":"            break :init @intToPtr([*]elf.Phdr, at_phdr)[0..at_phnum];","class":"lineCov","hits":"1","order":"21","possible_hits":"1",},
{"lineNum":"  424","line":"        };"},
{"lineNum":"  425","line":""},
{"lineNum":"  426","line":"        // Apply the initial relocations as early as possible in the startup"},
{"lineNum":"  427","line":"        // process."},
{"lineNum":"  428","line":"        if (builtin.position_independent_executable) {"},
{"lineNum":"  429","line":"            std.os.linux.pie.relocate(phdrs);"},
{"lineNum":"  430","line":"        }"},
{"lineNum":"  431","line":""},
{"lineNum":"  432","line":"        if (!builtin.single_threaded) {"},
{"lineNum":"  433","line":"            // ARMv6 targets (and earlier) have no support for TLS in hardware."},
{"lineNum":"  434","line":"            // FIXME: Elide the check for targets >= ARMv7 when the target feature API"},
{"lineNum":"  435","line":"            // becomes less verbose (and more usable)."},
{"lineNum":"  436","line":"            if (comptime native_arch.isARM()) {"},
{"lineNum":"  437","line":"                if (at_hwcap & std.os.linux.HWCAP.TLS == 0) {"},
{"lineNum":"  438","line":"                    // FIXME: Make __aeabi_read_tp call the kernel helper kuser_get_tls"},
{"lineNum":"  439","line":"                    // For the time being use a simple abort instead of a @panic call to"},
{"lineNum":"  440","line":"                    // keep the binary bloat under control."},
{"lineNum":"  441","line":"                    std.os.abort();"},
{"lineNum":"  442","line":"                }"},
{"lineNum":"  443","line":"            }"},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":"            // Initialize the TLS area."},
{"lineNum":"  446","line":"            std.os.linux.tls.initStaticTLS(phdrs);","class":"lineCov","hits":"1","order":"22","possible_hits":"1",},
{"lineNum":"  447","line":"        }"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"        // The way Linux executables represent stack size is via the PT_GNU_STACK"},
{"lineNum":"  450","line":"        // program header. However the kernel does not recognize it; it always gives 8 MiB."},
{"lineNum":"  451","line":"        // Here we look for the stack size in our program headers and use setrlimit"},
{"lineNum":"  452","line":"        // to ask for more stack space."},
{"lineNum":"  453","line":"        expandStackSize(phdrs);","class":"lineCov","hits":"1","order":"94","possible_hits":"1",},
{"lineNum":"  454","line":"    }"},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"    std.os.exit(@call(.always_inline, callMainWithArgs, .{ argc, argv, envp }));","class":"lineCov","hits":"1","order":"116","possible_hits":"1",},
{"lineNum":"  457","line":"}"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"fn expandStackSize(phdrs: []elf.Phdr) void {","class":"lineCov","hits":"1","order":"95","possible_hits":"1",},
{"lineNum":"  460","line":"    for (phdrs) |*phdr| {","class":"lineCov","hits":"1","order":"96","possible_hits":"1",},
{"lineNum":"  461","line":"        switch (phdr.p_type) {","class":"lineCov","hits":"1","order":"97","possible_hits":"1",},
{"lineNum":"  462","line":"            elf.PT_GNU_STACK => {"},
{"lineNum":"  463","line":"                const wanted_stack_size = phdr.p_memsz;","class":"lineCov","hits":"1","order":"98","possible_hits":"1",},
{"lineNum":"  464","line":"                assert(wanted_stack_size % std.mem.page_size == 0);","class":"lineCov","hits":"1","order":"99","possible_hits":"1",},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"                std.os.setrlimit(.STACK, .{","class":"lineCov","hits":"1","order":"100","possible_hits":"1",},
{"lineNum":"  467","line":"                    .cur = wanted_stack_size,"},
{"lineNum":"  468","line":"                    .max = wanted_stack_size,"},
{"lineNum":"  469","line":"                }) catch {"},
{"lineNum":"  470","line":"                    // Because we could not increase the stack size to the upper bound,"},
{"lineNum":"  471","line":"                    // depending on what happens at runtime, a stack overflow may occur."},
{"lineNum":"  472","line":"                    // However it would cause a segmentation fault, thanks to stack probing,"},
{"lineNum":"  473","line":"                    // so we do not have a memory safety issue here."},
{"lineNum":"  474","line":"                    // This is intentional silent failure."},
{"lineNum":"  475","line":"                    // This logic should be revisited when the following issues are addressed:"},
{"lineNum":"  476","line":"                    // https://github.com/ziglang/zig/issues/157"},
{"lineNum":"  477","line":"                    // https://github.com/ziglang/zig/issues/1006"},
{"lineNum":"  478","line":"                };"},
{"lineNum":"  479","line":"                break;","class":"linePartCov","hits":"1","order":"115","possible_hits":"2",},
{"lineNum":"  480","line":"            },"},
{"lineNum":"  481","line":"            else => {},"},
{"lineNum":"  482","line":"        }"},
{"lineNum":"  483","line":"    }"},
{"lineNum":"  484","line":"}"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"fn callMainWithArgs(argc: usize, argv: [*][*:0]u8, envp: [][*:0]u8) u8 {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  487","line":"    std.os.argv = argv[0..argc];","class":"linePartCov","hits":"1","order":"117","possible_hits":"2",},
{"lineNum":"  488","line":"    std.os.environ = envp;","class":"linePartCov","hits":"1","order":"118","possible_hits":"2",},
{"lineNum":"  489","line":""},
{"lineNum":"  490","line":"    std.debug.maybeEnableSegfaultHandler();","class":"linePartCov","hits":"1","order":"119","possible_hits":"2",},
{"lineNum":"  491","line":"    std.os.maybeIgnoreSigpipe();","class":"linePartCov","hits":"1","order":"153","possible_hits":"2",},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"    return initEventLoopAndCallMain();","class":"linePartCov","hits":"1","order":"2096","possible_hits":"2",},
{"lineNum":"  494","line":"}"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"fn main(c_argc: c_int, c_argv: [*][*:0]c_char, c_envp: [*:null]?[*:0]c_char) callconv(.C) c_int {"},
{"lineNum":"  497","line":"    var env_count: usize = 0;"},
{"lineNum":"  498","line":"    while (c_envp[env_count] != null) : (env_count += 1) {}"},
{"lineNum":"  499","line":"    const envp = @ptrCast([*][*:0]u8, c_envp)[0..env_count];"},
{"lineNum":"  500","line":""},
{"lineNum":"  501","line":"    if (builtin.os.tag == .linux) {"},
{"lineNum":"  502","line":"        const at_phdr = std.c.getauxval(elf.AT_PHDR);"},
{"lineNum":"  503","line":"        const at_phnum = std.c.getauxval(elf.AT_PHNUM);"},
{"lineNum":"  504","line":"        const phdrs = (@intToPtr([*]elf.Phdr, at_phdr))[0..at_phnum];"},
{"lineNum":"  505","line":"        expandStackSize(phdrs);"},
{"lineNum":"  506","line":"    }"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"    return @call(.always_inline, callMainWithArgs, .{ @intCast(usize, c_argc), @ptrCast([*][*:0]u8, c_argv), envp });"},
{"lineNum":"  509","line":"}"},
{"lineNum":"  510","line":""},
{"lineNum":"  511","line":"fn mainWithoutEnv(c_argc: c_int, c_argv: [*][*:0]c_char) callconv(.C) c_int {"},
{"lineNum":"  512","line":"    std.os.argv = @ptrCast([*][*:0]u8, c_argv)[0..@intCast(usize, c_argc)];"},
{"lineNum":"  513","line":"    return @call(.always_inline, callMain, .{});"},
{"lineNum":"  514","line":"}"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"// General error message for a malformed return type"},
{"lineNum":"  517","line":"const bad_main_ret = \"expected return type of main to be \'void\', \'!void\', \'noreturn\', \'u8\', or \'!u8\'\";"},
{"lineNum":"  518","line":""},
{"lineNum":"  519","line":"// This is marked inline because for some reason LLVM in release mode fails to inline it,"},
{"lineNum":"  520","line":"// and we want fewer call frames in stack traces."},
{"lineNum":"  521","line":"inline fn initEventLoopAndCallMain() u8 {"},
{"lineNum":"  522","line":"    if (std.event.Loop.instance) |loop| {"},
{"lineNum":"  523","line":"        if (loop == std.event.Loop.default_instance) {"},
{"lineNum":"  524","line":"            loop.init() catch |err| {"},
{"lineNum":"  525","line":"                std.log.err(\"{s}\", .{@errorName(err)});"},
{"lineNum":"  526","line":"                if (@errorReturnTrace()) |trace| {"},
{"lineNum":"  527","line":"                    std.debug.dumpStackTrace(trace.*);"},
{"lineNum":"  528","line":"                }"},
{"lineNum":"  529","line":"                return 1;"},
{"lineNum":"  530","line":"            };"},
{"lineNum":"  531","line":"            defer loop.deinit();"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"            var result: u8 = undefined;"},
{"lineNum":"  534","line":"            var frame: @Frame(callMainAsync) = undefined;"},
{"lineNum":"  535","line":"            _ = @asyncCall(&frame, &result, callMainAsync, .{loop});"},
{"lineNum":"  536","line":"            loop.run();"},
{"lineNum":"  537","line":"            return result;"},
{"lineNum":"  538","line":"        }"},
{"lineNum":"  539","line":"    }"},
{"lineNum":"  540","line":""},
{"lineNum":"  541","line":"    // This is marked inline because for some reason LLVM in release mode fails to inline it,"},
{"lineNum":"  542","line":"    // and we want fewer call frames in stack traces."},
{"lineNum":"  543","line":"    return @call(.always_inline, callMain, .{});","class":"linePartCov","hits":"1","order":"2095","possible_hits":"2",},
{"lineNum":"  544","line":"}"},
{"lineNum":"  545","line":""},
{"lineNum":"  546","line":"// This is marked inline because for some reason LLVM in release mode fails to inline it,"},
{"lineNum":"  547","line":"// and we want fewer call frames in stack traces."},
{"lineNum":"  548","line":"// TODO This function is duplicated from initEventLoopAndCallMain instead of using generics"},
{"lineNum":"  549","line":"// because it is working around stage1 compiler bugs."},
{"lineNum":"  550","line":"inline fn initEventLoopAndCallWinMain() std.os.windows.INT {"},
{"lineNum":"  551","line":"    if (std.event.Loop.instance) |loop| {"},
{"lineNum":"  552","line":"        if (loop == std.event.Loop.default_instance) {"},
{"lineNum":"  553","line":"            loop.init() catch |err| {"},
{"lineNum":"  554","line":"                std.log.err(\"{s}\", .{@errorName(err)});"},
{"lineNum":"  555","line":"                if (@errorReturnTrace()) |trace| {"},
{"lineNum":"  556","line":"                    std.debug.dumpStackTrace(trace.*);"},
{"lineNum":"  557","line":"                }"},
{"lineNum":"  558","line":"                return 1;"},
{"lineNum":"  559","line":"            };"},
{"lineNum":"  560","line":"            defer loop.deinit();"},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"            var result: std.os.windows.INT = undefined;"},
{"lineNum":"  563","line":"            var frame: @Frame(callWinMainAsync) = undefined;"},
{"lineNum":"  564","line":"            _ = @asyncCall(&frame, &result, callWinMainAsync, .{loop});"},
{"lineNum":"  565","line":"            loop.run();"},
{"lineNum":"  566","line":"            return result;"},
{"lineNum":"  567","line":"        }"},
{"lineNum":"  568","line":"    }"},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":"    // This is marked inline because for some reason LLVM in release mode fails to inline it,"},
{"lineNum":"  571","line":"    // and we want fewer call frames in stack traces."},
{"lineNum":"  572","line":"    return @call(.always_inline, call_wWinMain, .{});"},
{"lineNum":"  573","line":"}"},
{"lineNum":"  574","line":""},
{"lineNum":"  575","line":"fn callMainAsync(loop: *std.event.Loop) callconv(.Async) u8 {"},
{"lineNum":"  576","line":"    // This prevents the event loop from terminating at least until main() has returned."},
{"lineNum":"  577","line":"    // TODO This shouldn\'t be needed here; it should be in the event loop code."},
{"lineNum":"  578","line":"    loop.beginOneEvent();"},
{"lineNum":"  579","line":"    defer loop.finishOneEvent();"},
{"lineNum":"  580","line":"    return callMain();"},
{"lineNum":"  581","line":"}"},
{"lineNum":"  582","line":""},
{"lineNum":"  583","line":"fn callWinMainAsync(loop: *std.event.Loop) callconv(.Async) std.os.windows.INT {"},
{"lineNum":"  584","line":"    // This prevents the event loop from terminating at least until main() has returned."},
{"lineNum":"  585","line":"    // TODO This shouldn\'t be needed here; it should be in the event loop code."},
{"lineNum":"  586","line":"    loop.beginOneEvent();"},
{"lineNum":"  587","line":"    defer loop.finishOneEvent();"},
{"lineNum":"  588","line":"    return call_wWinMain();"},
{"lineNum":"  589","line":"}"},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":"// This is not marked inline because it is called with @asyncCall when"},
{"lineNum":"  592","line":"// there is an event loop."},
{"lineNum":"  593","line":"pub fn callMain() u8 {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  594","line":"    switch (@typeInfo(@typeInfo(@TypeOf(root.main)).Fn.return_type.?)) {"},
{"lineNum":"  595","line":"        .NoReturn => {"},
{"lineNum":"  596","line":"            root.main();"},
{"lineNum":"  597","line":"        },"},
{"lineNum":"  598","line":"        .Void => {"},
{"lineNum":"  599","line":"            root.main();","class":"linePartCov","hits":"1","order":"156","possible_hits":"3",},
{"lineNum":"  600","line":"            return 0;","class":"linePartCov","hits":"1","order":"2094","possible_hits":"3",},
{"lineNum":"  601","line":"        },"},
{"lineNum":"  602","line":"        .Int => |info| {"},
{"lineNum":"  603","line":"            if (info.bits != 8 or info.signedness == .signed) {"},
{"lineNum":"  604","line":"                @compileError(bad_main_ret);"},
{"lineNum":"  605","line":"            }"},
{"lineNum":"  606","line":"            return root.main();"},
{"lineNum":"  607","line":"        },"},
{"lineNum":"  608","line":"        .ErrorUnion => {"},
{"lineNum":"  609","line":"            const result = root.main() catch |err| {"},
{"lineNum":"  610","line":"                std.log.err(\"{s}\", .{@errorName(err)});"},
{"lineNum":"  611","line":"                if (@errorReturnTrace()) |trace| {"},
{"lineNum":"  612","line":"                    std.debug.dumpStackTrace(trace.*);"},
{"lineNum":"  613","line":"                }"},
{"lineNum":"  614","line":"                return 1;"},
{"lineNum":"  615","line":"            };"},
{"lineNum":"  616","line":"            switch (@typeInfo(@TypeOf(result))) {"},
{"lineNum":"  617","line":"                .Void => return 0,"},
{"lineNum":"  618","line":"                .Int => |info| {"},
{"lineNum":"  619","line":"                    if (info.bits != 8 or info.signedness == .signed) {"},
{"lineNum":"  620","line":"                        @compileError(bad_main_ret);"},
{"lineNum":"  621","line":"                    }"},
{"lineNum":"  622","line":"                    return result;"},
{"lineNum":"  623","line":"                },"},
{"lineNum":"  624","line":"                else => @compileError(bad_main_ret),"},
{"lineNum":"  625","line":"            }"},
{"lineNum":"  626","line":"        },"},
{"lineNum":"  627","line":"        else => @compileError(bad_main_ret),"},
{"lineNum":"  628","line":"    }"},
{"lineNum":"  629","line":"}"},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"pub fn call_wWinMain() std.os.windows.INT {"},
{"lineNum":"  632","line":"    const MAIN_HINSTANCE = @typeInfo(@TypeOf(root.wWinMain)).Fn.params[0].type.?;"},
{"lineNum":"  633","line":"    const hInstance = @ptrCast(MAIN_HINSTANCE, std.os.windows.kernel32.GetModuleHandleW(null).?);"},
{"lineNum":"  634","line":"    const lpCmdLine = std.os.windows.kernel32.GetCommandLineW();"},
{"lineNum":"  635","line":""},
{"lineNum":"  636","line":"    // There\'s no (documented) way to get the nCmdShow parameter, so we\'re"},
{"lineNum":"  637","line":"    // using this fairly standard default."},
{"lineNum":"  638","line":"    const nCmdShow = std.os.windows.user32.SW_SHOW;"},
{"lineNum":"  639","line":""},
{"lineNum":"  640","line":"    // second parameter hPrevInstance, MSDN: \"This parameter is always NULL\""},
{"lineNum":"  641","line":"    return root.wWinMain(hInstance, null, lpCmdLine, nCmdShow);"},
{"lineNum":"  642","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 42, "covered" : 39,};
var merged_data = [];
