var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"../std.zig\");"},
{"lineNum":"    2","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"const testing = std.testing;"},
{"lineNum":"    5","line":"const Ordering = std.atomic.Ordering;"},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"pub fn Atomic(comptime T: type) type {"},
{"lineNum":"    8","line":"    return extern struct {"},
{"lineNum":"    9","line":"        value: T,"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"        const Self = @This();"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"        pub fn init(value: T) Self {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   14","line":"            return .{ .value = value };","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   15","line":"        }"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"        /// Perform an atomic fence which uses the atomic value as a hint for the modification order."},
{"lineNum":"   18","line":"        /// Use this when you want to imply a fence on an atomic variable without necessarily performing a memory access."},
{"lineNum":"   19","line":"        ///"},
{"lineNum":"   20","line":"        /// Example:"},
{"lineNum":"   21","line":"        /// ```"},
{"lineNum":"   22","line":"        /// const RefCount = struct {"},
{"lineNum":"   23","line":"        ///     count: Atomic(usize),"},
{"lineNum":"   24","line":"        ///     dropFn: *const fn(*RefCount) void,"},
{"lineNum":"   25","line":"        ///"},
{"lineNum":"   26","line":"        ///     fn ref(self: *RefCount) void {"},
{"lineNum":"   27","line":"        ///         _ =  self.count.fetchAdd(1, .Monotonic); // no ordering necessary, just updating a counter"},
{"lineNum":"   28","line":"        ///     }"},
{"lineNum":"   29","line":"        ///"},
{"lineNum":"   30","line":"        ///     fn unref(self: *RefCount) void {"},
{"lineNum":"   31","line":"        ///         // Release ensures code before unref() happens-before the count is decremented as dropFn could be called by then."},
{"lineNum":"   32","line":"        ///         if (self.count.fetchSub(1, .Release)) {"},
{"lineNum":"   33","line":"        ///             // Acquire ensures count decrement and code before previous unrefs()s happens-before we call dropFn below."},
{"lineNum":"   34","line":"        ///             // NOTE: another alterative is to use .AcqRel on the fetchSub count decrement but it\'s extra barrier in possibly hot path."},
{"lineNum":"   35","line":"        ///             self.count.fence(.Acquire);"},
{"lineNum":"   36","line":"        ///             (self.dropFn)(self);"},
{"lineNum":"   37","line":"        ///         }"},
{"lineNum":"   38","line":"        ///     }"},
{"lineNum":"   39","line":"        /// };"},
{"lineNum":"   40","line":"        /// ```"},
{"lineNum":"   41","line":"        pub inline fn fence(self: *Self, comptime ordering: Ordering) void {"},
{"lineNum":"   42","line":"            // LLVM\'s ThreadSanitizer doesn\'t support the normal fences so we specialize for it."},
{"lineNum":"   43","line":"            if (builtin.sanitize_thread) {"},
{"lineNum":"   44","line":"                const tsan = struct {"},
{"lineNum":"   45","line":"                    extern \"c\" fn __tsan_acquire(addr: *anyopaque) void;"},
{"lineNum":"   46","line":"                    extern \"c\" fn __tsan_release(addr: *anyopaque) void;"},
{"lineNum":"   47","line":"                };"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"                const addr = @ptrCast(*anyopaque, self);"},
{"lineNum":"   50","line":"                return switch (ordering) {"},
{"lineNum":"   51","line":"                    .Unordered, .Monotonic => @compileError(@tagName(ordering) ++ \" only applies to atomic loads and stores\"),"},
{"lineNum":"   52","line":"                    .Acquire => tsan.__tsan_acquire(addr),"},
{"lineNum":"   53","line":"                    .Release => tsan.__tsan_release(addr),"},
{"lineNum":"   54","line":"                    .AcqRel, .SeqCst => {"},
{"lineNum":"   55","line":"                        tsan.__tsan_acquire(addr);"},
{"lineNum":"   56","line":"                        tsan.__tsan_release(addr);"},
{"lineNum":"   57","line":"                    },"},
{"lineNum":"   58","line":"                };"},
{"lineNum":"   59","line":"            }"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"            return std.atomic.fence(ordering);"},
{"lineNum":"   62","line":"        }"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"        /// Non-atomically load from the atomic value without synchronization."},
{"lineNum":"   65","line":"        /// Care must be taken to avoid data-races when interacting with other atomic operations."},
{"lineNum":"   66","line":"        pub inline fn loadUnchecked(self: Self) T {"},
{"lineNum":"   67","line":"            return self.value;"},
{"lineNum":"   68","line":"        }"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"        /// Non-atomically store to the atomic value without synchronization."},
{"lineNum":"   71","line":"        /// Care must be taken to avoid data-races when interacting with other atomic operations."},
{"lineNum":"   72","line":"        pub inline fn storeUnchecked(self: *Self, value: T) void {"},
{"lineNum":"   73","line":"            self.value = value;"},
{"lineNum":"   74","line":"        }"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"        pub inline fn load(self: *const Self, comptime ordering: Ordering) T {"},
{"lineNum":"   77","line":"            return switch (ordering) {","class":"linePartCov","hits":"4","order":"559","possible_hits":"6",},
{"lineNum":"   78","line":"                .AcqRel => @compileError(@tagName(ordering) ++ \" implies \" ++ @tagName(Ordering.Release) ++ \" which is only allowed on atomic stores\"),"},
{"lineNum":"   79","line":"                .Release => @compileError(@tagName(ordering) ++ \" is only allowed on atomic stores\"),"},
{"lineNum":"   80","line":"                else => @atomicLoad(T, &self.value, ordering),","class":"linePartCov","hits":"2","order":"560","possible_hits":"3",},
{"lineNum":"   81","line":"            };"},
{"lineNum":"   82","line":"        }"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"        pub inline fn store(self: *Self, value: T, comptime ordering: Ordering) void {"},
{"lineNum":"   85","line":"            return switch (ordering) {","class":"lineCov","hits":"5","order":"525","possible_hits":"5",},
{"lineNum":"   86","line":"                .AcqRel => @compileError(@tagName(ordering) ++ \" implies \" ++ @tagName(Ordering.Acquire) ++ \" which is only allowed on atomic loads\"),"},
{"lineNum":"   87","line":"                .Acquire => @compileError(@tagName(ordering) ++ \" is only allowed on atomic loads\"),"},
{"lineNum":"   88","line":"                else => @atomicStore(T, &self.value, value, ordering),","class":"lineCov","hits":"3","order":"526","possible_hits":"3",},
{"lineNum":"   89","line":"            };"},
{"lineNum":"   90","line":"        }"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"        pub inline fn swap(self: *Self, value: T, comptime ordering: Ordering) T {"},
{"lineNum":"   93","line":"            return self.rmw(.Xchg, value, ordering);","class":"linePartCov","hits":"2","order":"565","possible_hits":"4",},
{"lineNum":"   94","line":"        }"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"        pub inline fn compareAndSwap("},
{"lineNum":"   97","line":"            self: *Self,"},
{"lineNum":"   98","line":"            compare: T,"},
{"lineNum":"   99","line":"            exchange: T,"},
{"lineNum":"  100","line":"            comptime success: Ordering,"},
{"lineNum":"  101","line":"            comptime failure: Ordering,"},
{"lineNum":"  102","line":"        ) ?T {"},
{"lineNum":"  103","line":"            return self.cmpxchg(true, compare, exchange, success, failure);"},
{"lineNum":"  104","line":"        }"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"        pub inline fn tryCompareAndSwap("},
{"lineNum":"  107","line":"            self: *Self,"},
{"lineNum":"  108","line":"            compare: T,"},
{"lineNum":"  109","line":"            exchange: T,"},
{"lineNum":"  110","line":"            comptime success: Ordering,"},
{"lineNum":"  111","line":"            comptime failure: Ordering,"},
{"lineNum":"  112","line":"        ) ?T {"},
{"lineNum":"  113","line":"            return self.cmpxchg(false, compare, exchange, success, failure);"},
{"lineNum":"  114","line":"        }"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"        inline fn cmpxchg("},
{"lineNum":"  117","line":"            self: *Self,"},
{"lineNum":"  118","line":"            comptime is_strong: bool,"},
{"lineNum":"  119","line":"            compare: T,"},
{"lineNum":"  120","line":"            exchange: T,"},
{"lineNum":"  121","line":"            comptime success: Ordering,"},
{"lineNum":"  122","line":"            comptime failure: Ordering,"},
{"lineNum":"  123","line":"        ) ?T {"},
{"lineNum":"  124","line":"            if (success == .Unordered or failure == .Unordered) {"},
{"lineNum":"  125","line":"                @compileError(@tagName(Ordering.Unordered) ++ \" is only allowed on atomic loads and stores\");"},
{"lineNum":"  126","line":"            }"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"            comptime var success_is_stronger = switch (failure) {"},
{"lineNum":"  129","line":"                .SeqCst => success == .SeqCst,"},
{"lineNum":"  130","line":"                .AcqRel => @compileError(@tagName(failure) ++ \" implies \" ++ @tagName(Ordering.Release) ++ \" which is only allowed on success\"),"},
{"lineNum":"  131","line":"                .Acquire => success == .SeqCst or success == .AcqRel or success == .Acquire,"},
{"lineNum":"  132","line":"                .Release => @compileError(@tagName(failure) ++ \" is only allowed on success\"),"},
{"lineNum":"  133","line":"                .Monotonic => true,"},
{"lineNum":"  134","line":"                .Unordered => unreachable,"},
{"lineNum":"  135","line":"            };"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"            if (!success_is_stronger) {"},
{"lineNum":"  138","line":"                @compileError(@tagName(success) ++ \" must be stronger than \" ++ @tagName(failure));"},
{"lineNum":"  139","line":"            }"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"            return switch (is_strong) {"},
{"lineNum":"  142","line":"                true => @cmpxchgStrong(T, &self.value, compare, exchange, success, failure),"},
{"lineNum":"  143","line":"                false => @cmpxchgWeak(T, &self.value, compare, exchange, success, failure),"},
{"lineNum":"  144","line":"            };"},
{"lineNum":"  145","line":"        }"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"        inline fn rmw("},
{"lineNum":"  148","line":"            self: *Self,"},
{"lineNum":"  149","line":"            comptime op: std.builtin.AtomicRmwOp,"},
{"lineNum":"  150","line":"            value: T,"},
{"lineNum":"  151","line":"            comptime ordering: Ordering,"},
{"lineNum":"  152","line":"        ) T {"},
{"lineNum":"  153","line":"            return @atomicRmw(T, &self.value, op, value, ordering);","class":"linePartCov","hits":"3","order":"510","possible_hits":"7",},
{"lineNum":"  154","line":"        }"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"        fn exportWhen(comptime condition: bool, comptime functions: type) type {"},
{"lineNum":"  157","line":"            return if (condition) functions else struct {};"},
{"lineNum":"  158","line":"        }"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"        pub usingnamespace exportWhen(std.meta.trait.isNumber(T), struct {"},
{"lineNum":"  161","line":"            pub inline fn fetchAdd(self: *Self, value: T, comptime ordering: Ordering) T {"},
{"lineNum":"  162","line":"                return self.rmw(.Add, value, ordering);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  163","line":"            }"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"            pub inline fn fetchSub(self: *Self, value: T, comptime ordering: Ordering) T {"},
{"lineNum":"  166","line":"                return self.rmw(.Sub, value, ordering);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  167","line":"            }"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"            pub inline fn fetchMin(self: *Self, value: T, comptime ordering: Ordering) T {"},
{"lineNum":"  170","line":"                return self.rmw(.Min, value, ordering);"},
{"lineNum":"  171","line":"            }"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"            pub inline fn fetchMax(self: *Self, value: T, comptime ordering: Ordering) T {"},
{"lineNum":"  174","line":"                return self.rmw(.Max, value, ordering);"},
{"lineNum":"  175","line":"            }"},
{"lineNum":"  176","line":"        });"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"        pub usingnamespace exportWhen(std.meta.trait.isIntegral(T), struct {"},
{"lineNum":"  179","line":"            pub inline fn fetchAnd(self: *Self, value: T, comptime ordering: Ordering) T {"},
{"lineNum":"  180","line":"                return self.rmw(.And, value, ordering);"},
{"lineNum":"  181","line":"            }"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"            pub inline fn fetchNand(self: *Self, value: T, comptime ordering: Ordering) T {"},
{"lineNum":"  184","line":"                return self.rmw(.Nand, value, ordering);"},
{"lineNum":"  185","line":"            }"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"            pub inline fn fetchOr(self: *Self, value: T, comptime ordering: Ordering) T {"},
{"lineNum":"  188","line":"                return self.rmw(.Or, value, ordering);","class":"lineCov","hits":"4","order":"509","possible_hits":"4",},
{"lineNum":"  189","line":"            }"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"            pub inline fn fetchXor(self: *Self, value: T, comptime ordering: Ordering) T {"},
{"lineNum":"  192","line":"                return self.rmw(.Xor, value, ordering);"},
{"lineNum":"  193","line":"            }"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"            const Bit = std.math.Log2Int(T);"},
{"lineNum":"  196","line":"            const BitRmwOp = enum {"},
{"lineNum":"  197","line":"                Set,"},
{"lineNum":"  198","line":"                Reset,"},
{"lineNum":"  199","line":"                Toggle,"},
{"lineNum":"  200","line":"            };"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"            pub inline fn bitSet(self: *Self, bit: Bit, comptime ordering: Ordering) u1 {"},
{"lineNum":"  203","line":"                return bitRmw(self, .Set, bit, ordering);","class":"lineCov","hits":"4","order":"505","possible_hits":"4",},
{"lineNum":"  204","line":"            }"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"            pub inline fn bitReset(self: *Self, bit: Bit, comptime ordering: Ordering) u1 {"},
{"lineNum":"  207","line":"                return bitRmw(self, .Reset, bit, ordering);"},
{"lineNum":"  208","line":"            }"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"            pub inline fn bitToggle(self: *Self, bit: Bit, comptime ordering: Ordering) u1 {"},
{"lineNum":"  211","line":"                return bitRmw(self, .Toggle, bit, ordering);"},
{"lineNum":"  212","line":"            }"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"            inline fn bitRmw(self: *Self, comptime op: BitRmwOp, bit: Bit, comptime ordering: Ordering) u1 {"},
{"lineNum":"  215","line":"                // x86 supports dedicated bitwise instructions"},
{"lineNum":"  216","line":"                if (comptime builtin.target.cpu.arch.isX86() and @sizeOf(T) >= 2 and @sizeOf(T) <= 8) {"},
{"lineNum":"  217","line":"                    // TODO: this causes std lib test failures when enabled"},
{"lineNum":"  218","line":"                    if (false) {"},
{"lineNum":"  219","line":"                        return x86BitRmw(self, op, bit, ordering);"},
{"lineNum":"  220","line":"                    }"},
{"lineNum":"  221","line":"                }"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"                const mask = @as(T, 1) << bit;","class":"lineCov","hits":"2","order":"506","possible_hits":"2",},
{"lineNum":"  224","line":"                const value = switch (op) {","class":"lineCov","hits":"2","order":"507","possible_hits":"2",},
{"lineNum":"  225","line":"                    .Set => self.fetchOr(mask, ordering),","class":"lineCov","hits":"2","order":"508","possible_hits":"2",},
{"lineNum":"  226","line":"                    .Reset => self.fetchAnd(~mask, ordering),"},
{"lineNum":"  227","line":"                    .Toggle => self.fetchXor(mask, ordering),"},
{"lineNum":"  228","line":"                };"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"                return @boolToInt(value & mask != 0);","class":"lineCov","hits":"2","order":"511","possible_hits":"2",},
{"lineNum":"  231","line":"            }"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"            inline fn x86BitRmw(self: *Self, comptime op: BitRmwOp, bit: Bit, comptime ordering: Ordering) u1 {"},
{"lineNum":"  234","line":"                const old_bit: u8 = switch (@sizeOf(T)) {"},
{"lineNum":"  235","line":"                    2 => switch (op) {"},
{"lineNum":"  236","line":"                        .Set => asm volatile (\"lock btsw %[bit], %[ptr]\""},
{"lineNum":"  237","line":"                            // LLVM doesn\'t support u1 flag register return values"},
{"lineNum":"  238","line":"                            : [result] \"={@ccc}\" (-> u8),"},
{"lineNum":"  239","line":"                            : [ptr] \"*m\" (&self.value),"},
{"lineNum":"  240","line":"                              [bit] \"X\" (@as(T, bit)),"},
{"lineNum":"  241","line":"                            : \"cc\", \"memory\""},
{"lineNum":"  242","line":"                        ),"},
{"lineNum":"  243","line":"                        .Reset => asm volatile (\"lock btrw %[bit], %[ptr]\""},
{"lineNum":"  244","line":"                            // LLVM doesn\'t support u1 flag register return values"},
{"lineNum":"  245","line":"                            : [result] \"={@ccc}\" (-> u8),"},
{"lineNum":"  246","line":"                            : [ptr] \"*m\" (&self.value),"},
{"lineNum":"  247","line":"                              [bit] \"X\" (@as(T, bit)),"},
{"lineNum":"  248","line":"                            : \"cc\", \"memory\""},
{"lineNum":"  249","line":"                        ),"},
{"lineNum":"  250","line":"                        .Toggle => asm volatile (\"lock btcw %[bit], %[ptr]\""},
{"lineNum":"  251","line":"                            // LLVM doesn\'t support u1 flag register return values"},
{"lineNum":"  252","line":"                            : [result] \"={@ccc}\" (-> u8),"},
{"lineNum":"  253","line":"                            : [ptr] \"*m\" (&self.value),"},
{"lineNum":"  254","line":"                              [bit] \"X\" (@as(T, bit)),"},
{"lineNum":"  255","line":"                            : \"cc\", \"memory\""},
{"lineNum":"  256","line":"                        ),"},
{"lineNum":"  257","line":"                    },"},
{"lineNum":"  258","line":"                    4 => switch (op) {"},
{"lineNum":"  259","line":"                        .Set => asm volatile (\"lock btsl %[bit], %[ptr]\""},
{"lineNum":"  260","line":"                            // LLVM doesn\'t support u1 flag register return values"},
{"lineNum":"  261","line":"                            : [result] \"={@ccc}\" (-> u8),"},
{"lineNum":"  262","line":"                            : [ptr] \"*m\" (&self.value),"},
{"lineNum":"  263","line":"                              [bit] \"X\" (@as(T, bit)),"},
{"lineNum":"  264","line":"                            : \"cc\", \"memory\""},
{"lineNum":"  265","line":"                        ),"},
{"lineNum":"  266","line":"                        .Reset => asm volatile (\"lock btrl %[bit], %[ptr]\""},
{"lineNum":"  267","line":"                            // LLVM doesn\'t support u1 flag register return values"},
{"lineNum":"  268","line":"                            : [result] \"={@ccc}\" (-> u8),"},
{"lineNum":"  269","line":"                            : [ptr] \"*m\" (&self.value),"},
{"lineNum":"  270","line":"                              [bit] \"X\" (@as(T, bit)),"},
{"lineNum":"  271","line":"                            : \"cc\", \"memory\""},
{"lineNum":"  272","line":"                        ),"},
{"lineNum":"  273","line":"                        .Toggle => asm volatile (\"lock btcl %[bit], %[ptr]\""},
{"lineNum":"  274","line":"                            // LLVM doesn\'t support u1 flag register return values"},
{"lineNum":"  275","line":"                            : [result] \"={@ccc}\" (-> u8),"},
{"lineNum":"  276","line":"                            : [ptr] \"*m\" (&self.value),"},
{"lineNum":"  277","line":"                              [bit] \"X\" (@as(T, bit)),"},
{"lineNum":"  278","line":"                            : \"cc\", \"memory\""},
{"lineNum":"  279","line":"                        ),"},
{"lineNum":"  280","line":"                    },"},
{"lineNum":"  281","line":"                    8 => switch (op) {"},
{"lineNum":"  282","line":"                        .Set => asm volatile (\"lock btsq %[bit], %[ptr]\""},
{"lineNum":"  283","line":"                            // LLVM doesn\'t support u1 flag register return values"},
{"lineNum":"  284","line":"                            : [result] \"={@ccc}\" (-> u8),"},
{"lineNum":"  285","line":"                            : [ptr] \"*m\" (&self.value),"},
{"lineNum":"  286","line":"                              [bit] \"X\" (@as(T, bit)),"},
{"lineNum":"  287","line":"                            : \"cc\", \"memory\""},
{"lineNum":"  288","line":"                        ),"},
{"lineNum":"  289","line":"                        .Reset => asm volatile (\"lock btrq %[bit], %[ptr]\""},
{"lineNum":"  290","line":"                            // LLVM doesn\'t support u1 flag register return values"},
{"lineNum":"  291","line":"                            : [result] \"={@ccc}\" (-> u8),"},
{"lineNum":"  292","line":"                            : [ptr] \"*m\" (&self.value),"},
{"lineNum":"  293","line":"                              [bit] \"X\" (@as(T, bit)),"},
{"lineNum":"  294","line":"                            : \"cc\", \"memory\""},
{"lineNum":"  295","line":"                        ),"},
{"lineNum":"  296","line":"                        .Toggle => asm volatile (\"lock btcq %[bit], %[ptr]\""},
{"lineNum":"  297","line":"                            // LLVM doesn\'t support u1 flag register return values"},
{"lineNum":"  298","line":"                            : [result] \"={@ccc}\" (-> u8),"},
{"lineNum":"  299","line":"                            : [ptr] \"*m\" (&self.value),"},
{"lineNum":"  300","line":"                              [bit] \"X\" (@as(T, bit)),"},
{"lineNum":"  301","line":"                            : \"cc\", \"memory\""},
{"lineNum":"  302","line":"                        ),"},
{"lineNum":"  303","line":"                    },"},
{"lineNum":"  304","line":"                    else => @compileError(\"Invalid atomic type \" ++ @typeName(T)),"},
{"lineNum":"  305","line":"                };"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"                // TODO: emit appropriate tsan fence if compiling with tsan"},
{"lineNum":"  308","line":"                _ = ordering;"},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"                return @intCast(u1, old_bit);"},
{"lineNum":"  311","line":"            }"},
{"lineNum":"  312","line":"        });"},
{"lineNum":"  313","line":"    };"},
{"lineNum":"  314","line":"}"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"test \"Atomic.fence\" {"},
{"lineNum":"  317","line":"    inline for (.{ .Acquire, .Release, .AcqRel, .SeqCst }) |ordering| {"},
{"lineNum":"  318","line":"        var x = Atomic(usize).init(0);"},
{"lineNum":"  319","line":"        x.fence(ordering);"},
{"lineNum":"  320","line":"    }"},
{"lineNum":"  321","line":"}"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"fn atomicIntTypes() []const type {"},
{"lineNum":"  324","line":"    comptime var bytes = 1;"},
{"lineNum":"  325","line":"    comptime var types: []const type = &[_]type{};"},
{"lineNum":"  326","line":"    inline while (bytes <= @sizeOf(usize)) : (bytes *= 2) {"},
{"lineNum":"  327","line":"        types = types ++ &[_]type{std.meta.Int(.unsigned, bytes * 8)};"},
{"lineNum":"  328","line":"    }"},
{"lineNum":"  329","line":"    return types;"},
{"lineNum":"  330","line":"}"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"test \"Atomic.loadUnchecked\" {"},
{"lineNum":"  333","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  334","line":"        var x = Atomic(Int).init(5);"},
{"lineNum":"  335","line":"        try testing.expectEqual(x.loadUnchecked(), 5);"},
{"lineNum":"  336","line":"    }"},
{"lineNum":"  337","line":"}"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"test \"Atomic.storeUnchecked\" {"},
{"lineNum":"  340","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  341","line":"        _ = Int;"},
{"lineNum":"  342","line":"        var x = Atomic(usize).init(5);"},
{"lineNum":"  343","line":"        x.storeUnchecked(10);"},
{"lineNum":"  344","line":"        try testing.expectEqual(x.loadUnchecked(), 10);"},
{"lineNum":"  345","line":"    }"},
{"lineNum":"  346","line":"}"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"test \"Atomic.load\" {"},
{"lineNum":"  349","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  350","line":"        inline for (.{ .Unordered, .Monotonic, .Acquire, .SeqCst }) |ordering| {"},
{"lineNum":"  351","line":"            var x = Atomic(Int).init(5);"},
{"lineNum":"  352","line":"            try testing.expectEqual(x.load(ordering), 5);"},
{"lineNum":"  353","line":"        }"},
{"lineNum":"  354","line":"    }"},
{"lineNum":"  355","line":"}"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"test \"Atomic.store\" {"},
{"lineNum":"  358","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  359","line":"        inline for (.{ .Unordered, .Monotonic, .Release, .SeqCst }) |ordering| {"},
{"lineNum":"  360","line":"            _ = Int;"},
{"lineNum":"  361","line":"            var x = Atomic(usize).init(5);"},
{"lineNum":"  362","line":"            x.store(10, ordering);"},
{"lineNum":"  363","line":"            try testing.expectEqual(x.load(.SeqCst), 10);"},
{"lineNum":"  364","line":"        }"},
{"lineNum":"  365","line":"    }"},
{"lineNum":"  366","line":"}"},
{"lineNum":"  367","line":""},
{"lineNum":"  368","line":"const atomic_rmw_orderings = [_]Ordering{"},
{"lineNum":"  369","line":"    .Monotonic,"},
{"lineNum":"  370","line":"    .Acquire,"},
{"lineNum":"  371","line":"    .Release,"},
{"lineNum":"  372","line":"    .AcqRel,"},
{"lineNum":"  373","line":"    .SeqCst,"},
{"lineNum":"  374","line":"};"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"test \"Atomic.swap\" {"},
{"lineNum":"  377","line":"    // TODO: Re-enable when LLVM is released with a bugfix for isel of"},
{"lineNum":"  378","line":"    //       atomic load (currently fixed on trunk, broken on 15.0.2)"},
{"lineNum":"  379","line":"    if (builtin.cpu.arch == .powerpc64le) return error.SkipZigTest;"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"    inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  382","line":"        var x = Atomic(usize).init(5);"},
{"lineNum":"  383","line":"        try testing.expectEqual(x.swap(10, ordering), 5);"},
{"lineNum":"  384","line":"        try testing.expectEqual(x.load(.SeqCst), 10);"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"        var y = Atomic(enum(usize) { a, b, c }).init(.c);"},
{"lineNum":"  387","line":"        try testing.expectEqual(y.swap(.a, ordering), .c);"},
{"lineNum":"  388","line":"        try testing.expectEqual(y.load(.SeqCst), .a);"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"        var z = Atomic(f32).init(5.0);"},
{"lineNum":"  391","line":"        try testing.expectEqual(z.swap(10.0, ordering), 5.0);"},
{"lineNum":"  392","line":"        try testing.expectEqual(z.load(.SeqCst), 10.0);"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"        var a = Atomic(bool).init(false);"},
{"lineNum":"  395","line":"        try testing.expectEqual(a.swap(true, ordering), false);"},
{"lineNum":"  396","line":"        try testing.expectEqual(a.load(.SeqCst), true);"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":"        var b = Atomic(?*u8).init(null);"},
{"lineNum":"  399","line":"        try testing.expectEqual(b.swap(@intToPtr(?*u8, @alignOf(u8)), ordering), null);"},
{"lineNum":"  400","line":"        try testing.expectEqual(b.load(.SeqCst), @intToPtr(?*u8, @alignOf(u8)));"},
{"lineNum":"  401","line":"    }"},
{"lineNum":"  402","line":"}"},
{"lineNum":"  403","line":""},
{"lineNum":"  404","line":"const atomic_cmpxchg_orderings = [_][2]Ordering{"},
{"lineNum":"  405","line":"    .{ .Monotonic, .Monotonic },"},
{"lineNum":"  406","line":"    .{ .Acquire, .Monotonic },"},
{"lineNum":"  407","line":"    .{ .Acquire, .Acquire },"},
{"lineNum":"  408","line":"    .{ .Release, .Monotonic },"},
{"lineNum":"  409","line":"    // Although accepted by LLVM, acquire failure implies AcqRel success"},
{"lineNum":"  410","line":"    // .{ .Release, .Acquire },"},
{"lineNum":"  411","line":"    .{ .AcqRel, .Monotonic },"},
{"lineNum":"  412","line":"    .{ .AcqRel, .Acquire },"},
{"lineNum":"  413","line":"    .{ .SeqCst, .Monotonic },"},
{"lineNum":"  414","line":"    .{ .SeqCst, .Acquire },"},
{"lineNum":"  415","line":"    .{ .SeqCst, .SeqCst },"},
{"lineNum":"  416","line":"};"},
{"lineNum":"  417","line":""},
{"lineNum":"  418","line":"test \"Atomic.compareAndSwap\" {"},
{"lineNum":"  419","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  420","line":"        inline for (atomic_cmpxchg_orderings) |ordering| {"},
{"lineNum":"  421","line":"            var x = Atomic(Int).init(0);"},
{"lineNum":"  422","line":"            try testing.expectEqual(x.compareAndSwap(1, 0, ordering[0], ordering[1]), 0);"},
{"lineNum":"  423","line":"            try testing.expectEqual(x.load(.SeqCst), 0);"},
{"lineNum":"  424","line":"            try testing.expectEqual(x.compareAndSwap(0, 1, ordering[0], ordering[1]), null);"},
{"lineNum":"  425","line":"            try testing.expectEqual(x.load(.SeqCst), 1);"},
{"lineNum":"  426","line":"            try testing.expectEqual(x.compareAndSwap(1, 0, ordering[0], ordering[1]), null);"},
{"lineNum":"  427","line":"            try testing.expectEqual(x.load(.SeqCst), 0);"},
{"lineNum":"  428","line":"        }"},
{"lineNum":"  429","line":"    }"},
{"lineNum":"  430","line":"}"},
{"lineNum":"  431","line":""},
{"lineNum":"  432","line":"test \"Atomic.tryCompareAndSwap\" {"},
{"lineNum":"  433","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  434","line":"        inline for (atomic_cmpxchg_orderings) |ordering| {"},
{"lineNum":"  435","line":"            var x = Atomic(Int).init(0);"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"            try testing.expectEqual(x.tryCompareAndSwap(1, 0, ordering[0], ordering[1]), 0);"},
{"lineNum":"  438","line":"            try testing.expectEqual(x.load(.SeqCst), 0);"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"            while (x.tryCompareAndSwap(0, 1, ordering[0], ordering[1])) |_| {}"},
{"lineNum":"  441","line":"            try testing.expectEqual(x.load(.SeqCst), 1);"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"            while (x.tryCompareAndSwap(1, 0, ordering[0], ordering[1])) |_| {}"},
{"lineNum":"  444","line":"            try testing.expectEqual(x.load(.SeqCst), 0);"},
{"lineNum":"  445","line":"        }"},
{"lineNum":"  446","line":"    }"},
{"lineNum":"  447","line":"}"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"test \"Atomic.fetchAdd\" {"},
{"lineNum":"  450","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  451","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  452","line":"            var x = Atomic(Int).init(5);"},
{"lineNum":"  453","line":"            try testing.expectEqual(x.fetchAdd(5, ordering), 5);"},
{"lineNum":"  454","line":"            try testing.expectEqual(x.load(.SeqCst), 10);"},
{"lineNum":"  455","line":"            try testing.expectEqual(x.fetchAdd(std.math.maxInt(Int), ordering), 10);"},
{"lineNum":"  456","line":"            try testing.expectEqual(x.load(.SeqCst), 9);"},
{"lineNum":"  457","line":"        }"},
{"lineNum":"  458","line":"    }"},
{"lineNum":"  459","line":"}"},
{"lineNum":"  460","line":""},
{"lineNum":"  461","line":"test \"Atomic.fetchSub\" {"},
{"lineNum":"  462","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  463","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  464","line":"            var x = Atomic(Int).init(5);"},
{"lineNum":"  465","line":"            try testing.expectEqual(x.fetchSub(5, ordering), 5);"},
{"lineNum":"  466","line":"            try testing.expectEqual(x.load(.SeqCst), 0);"},
{"lineNum":"  467","line":"            try testing.expectEqual(x.fetchSub(1, ordering), 0);"},
{"lineNum":"  468","line":"            try testing.expectEqual(x.load(.SeqCst), std.math.maxInt(Int));"},
{"lineNum":"  469","line":"        }"},
{"lineNum":"  470","line":"    }"},
{"lineNum":"  471","line":"}"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":"test \"Atomic.fetchMin\" {"},
{"lineNum":"  474","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  475","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  476","line":"            var x = Atomic(Int).init(5);"},
{"lineNum":"  477","line":"            try testing.expectEqual(x.fetchMin(0, ordering), 5);"},
{"lineNum":"  478","line":"            try testing.expectEqual(x.load(.SeqCst), 0);"},
{"lineNum":"  479","line":"            try testing.expectEqual(x.fetchMin(10, ordering), 0);"},
{"lineNum":"  480","line":"            try testing.expectEqual(x.load(.SeqCst), 0);"},
{"lineNum":"  481","line":"        }"},
{"lineNum":"  482","line":"    }"},
{"lineNum":"  483","line":"}"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"test \"Atomic.fetchMax\" {"},
{"lineNum":"  486","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  487","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  488","line":"            var x = Atomic(Int).init(5);"},
{"lineNum":"  489","line":"            try testing.expectEqual(x.fetchMax(10, ordering), 5);"},
{"lineNum":"  490","line":"            try testing.expectEqual(x.load(.SeqCst), 10);"},
{"lineNum":"  491","line":"            try testing.expectEqual(x.fetchMax(5, ordering), 10);"},
{"lineNum":"  492","line":"            try testing.expectEqual(x.load(.SeqCst), 10);"},
{"lineNum":"  493","line":"        }"},
{"lineNum":"  494","line":"    }"},
{"lineNum":"  495","line":"}"},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"test \"Atomic.fetchAnd\" {"},
{"lineNum":"  498","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  499","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  500","line":"            var x = Atomic(Int).init(0b11);"},
{"lineNum":"  501","line":"            try testing.expectEqual(x.fetchAnd(0b10, ordering), 0b11);"},
{"lineNum":"  502","line":"            try testing.expectEqual(x.load(.SeqCst), 0b10);"},
{"lineNum":"  503","line":"            try testing.expectEqual(x.fetchAnd(0b00, ordering), 0b10);"},
{"lineNum":"  504","line":"            try testing.expectEqual(x.load(.SeqCst), 0b00);"},
{"lineNum":"  505","line":"        }"},
{"lineNum":"  506","line":"    }"},
{"lineNum":"  507","line":"}"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"test \"Atomic.fetchNand\" {"},
{"lineNum":"  510","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  511","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  512","line":"            var x = Atomic(Int).init(0b11);"},
{"lineNum":"  513","line":"            try testing.expectEqual(x.fetchNand(0b10, ordering), 0b11);"},
{"lineNum":"  514","line":"            try testing.expectEqual(x.load(.SeqCst), ~@as(Int, 0b10));"},
{"lineNum":"  515","line":"            try testing.expectEqual(x.fetchNand(0b00, ordering), ~@as(Int, 0b10));"},
{"lineNum":"  516","line":"            try testing.expectEqual(x.load(.SeqCst), ~@as(Int, 0b00));"},
{"lineNum":"  517","line":"        }"},
{"lineNum":"  518","line":"    }"},
{"lineNum":"  519","line":"}"},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"test \"Atomic.fetchOr\" {"},
{"lineNum":"  522","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  523","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  524","line":"            var x = Atomic(Int).init(0b11);"},
{"lineNum":"  525","line":"            try testing.expectEqual(x.fetchOr(0b100, ordering), 0b11);"},
{"lineNum":"  526","line":"            try testing.expectEqual(x.load(.SeqCst), 0b111);"},
{"lineNum":"  527","line":"            try testing.expectEqual(x.fetchOr(0b010, ordering), 0b111);"},
{"lineNum":"  528","line":"            try testing.expectEqual(x.load(.SeqCst), 0b111);"},
{"lineNum":"  529","line":"        }"},
{"lineNum":"  530","line":"    }"},
{"lineNum":"  531","line":"}"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"test \"Atomic.fetchXor\" {"},
{"lineNum":"  534","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  535","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  536","line":"            var x = Atomic(Int).init(0b11);"},
{"lineNum":"  537","line":"            try testing.expectEqual(x.fetchXor(0b10, ordering), 0b11);"},
{"lineNum":"  538","line":"            try testing.expectEqual(x.load(.SeqCst), 0b01);"},
{"lineNum":"  539","line":"            try testing.expectEqual(x.fetchXor(0b01, ordering), 0b01);"},
{"lineNum":"  540","line":"            try testing.expectEqual(x.load(.SeqCst), 0b00);"},
{"lineNum":"  541","line":"        }"},
{"lineNum":"  542","line":"    }"},
{"lineNum":"  543","line":"}"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"test \"Atomic.bitSet\" {"},
{"lineNum":"  546","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  547","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  548","line":"            var x = Atomic(Int).init(0);"},
{"lineNum":"  549","line":"            const bit_array = @as([@bitSizeOf(Int)]void, undefined);"},
{"lineNum":"  550","line":""},
{"lineNum":"  551","line":"            for (bit_array, 0..) |_, bit_index| {"},
{"lineNum":"  552","line":"                const bit = @intCast(std.math.Log2Int(Int), bit_index);"},
{"lineNum":"  553","line":"                const mask = @as(Int, 1) << bit;"},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":"                // setting the bit should change the bit"},
{"lineNum":"  556","line":"                try testing.expect(x.load(.SeqCst) & mask == 0);"},
{"lineNum":"  557","line":"                try testing.expectEqual(x.bitSet(bit, ordering), 0);"},
{"lineNum":"  558","line":"                try testing.expect(x.load(.SeqCst) & mask != 0);"},
{"lineNum":"  559","line":""},
{"lineNum":"  560","line":"                // setting it again shouldn\'t change the bit"},
{"lineNum":"  561","line":"                try testing.expectEqual(x.bitSet(bit, ordering), 1);"},
{"lineNum":"  562","line":"                try testing.expect(x.load(.SeqCst) & mask != 0);"},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"                // all the previous bits should have not changed (still be set)"},
{"lineNum":"  565","line":"                for (bit_array[0..bit_index], 0..) |_, prev_bit_index| {"},
{"lineNum":"  566","line":"                    const prev_bit = @intCast(std.math.Log2Int(Int), prev_bit_index);"},
{"lineNum":"  567","line":"                    const prev_mask = @as(Int, 1) << prev_bit;"},
{"lineNum":"  568","line":"                    try testing.expect(x.load(.SeqCst) & prev_mask != 0);"},
{"lineNum":"  569","line":"                }"},
{"lineNum":"  570","line":"            }"},
{"lineNum":"  571","line":"        }"},
{"lineNum":"  572","line":"    }"},
{"lineNum":"  573","line":"}"},
{"lineNum":"  574","line":""},
{"lineNum":"  575","line":"test \"Atomic.bitReset\" {"},
{"lineNum":"  576","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  577","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  578","line":"            var x = Atomic(Int).init(0);"},
{"lineNum":"  579","line":"            const bit_array = @as([@bitSizeOf(Int)]void, undefined);"},
{"lineNum":"  580","line":""},
{"lineNum":"  581","line":"            for (bit_array, 0..) |_, bit_index| {"},
{"lineNum":"  582","line":"                const bit = @intCast(std.math.Log2Int(Int), bit_index);"},
{"lineNum":"  583","line":"                const mask = @as(Int, 1) << bit;"},
{"lineNum":"  584","line":"                x.storeUnchecked(x.loadUnchecked() | mask);"},
{"lineNum":"  585","line":""},
{"lineNum":"  586","line":"                // unsetting the bit should change the bit"},
{"lineNum":"  587","line":"                try testing.expect(x.load(.SeqCst) & mask != 0);"},
{"lineNum":"  588","line":"                try testing.expectEqual(x.bitReset(bit, ordering), 1);"},
{"lineNum":"  589","line":"                try testing.expect(x.load(.SeqCst) & mask == 0);"},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":"                // unsetting it again shouldn\'t change the bit"},
{"lineNum":"  592","line":"                try testing.expectEqual(x.bitReset(bit, ordering), 0);"},
{"lineNum":"  593","line":"                try testing.expect(x.load(.SeqCst) & mask == 0);"},
{"lineNum":"  594","line":""},
{"lineNum":"  595","line":"                // all the previous bits should have not changed (still be reset)"},
{"lineNum":"  596","line":"                for (bit_array[0..bit_index], 0..) |_, prev_bit_index| {"},
{"lineNum":"  597","line":"                    const prev_bit = @intCast(std.math.Log2Int(Int), prev_bit_index);"},
{"lineNum":"  598","line":"                    const prev_mask = @as(Int, 1) << prev_bit;"},
{"lineNum":"  599","line":"                    try testing.expect(x.load(.SeqCst) & prev_mask == 0);"},
{"lineNum":"  600","line":"                }"},
{"lineNum":"  601","line":"            }"},
{"lineNum":"  602","line":"        }"},
{"lineNum":"  603","line":"    }"},
{"lineNum":"  604","line":"}"},
{"lineNum":"  605","line":""},
{"lineNum":"  606","line":"test \"Atomic.bitToggle\" {"},
{"lineNum":"  607","line":"    inline for (atomicIntTypes()) |Int| {"},
{"lineNum":"  608","line":"        inline for (atomic_rmw_orderings) |ordering| {"},
{"lineNum":"  609","line":"            var x = Atomic(Int).init(0);"},
{"lineNum":"  610","line":"            const bit_array = @as([@bitSizeOf(Int)]void, undefined);"},
{"lineNum":"  611","line":""},
{"lineNum":"  612","line":"            for (bit_array, 0..) |_, bit_index| {"},
{"lineNum":"  613","line":"                const bit = @intCast(std.math.Log2Int(Int), bit_index);"},
{"lineNum":"  614","line":"                const mask = @as(Int, 1) << bit;"},
{"lineNum":"  615","line":""},
{"lineNum":"  616","line":"                // toggling the bit should change the bit"},
{"lineNum":"  617","line":"                try testing.expect(x.load(.SeqCst) & mask == 0);"},
{"lineNum":"  618","line":"                try testing.expectEqual(x.bitToggle(bit, ordering), 0);"},
{"lineNum":"  619","line":"                try testing.expect(x.load(.SeqCst) & mask != 0);"},
{"lineNum":"  620","line":""},
{"lineNum":"  621","line":"                // toggling it again *should* change the bit"},
{"lineNum":"  622","line":"                try testing.expectEqual(x.bitToggle(bit, ordering), 1);"},
{"lineNum":"  623","line":"                try testing.expect(x.load(.SeqCst) & mask == 0);"},
{"lineNum":"  624","line":""},
{"lineNum":"  625","line":"                // all the previous bits should have not changed (still be toggled back)"},
{"lineNum":"  626","line":"                for (bit_array[0..bit_index], 0..) |_, prev_bit_index| {"},
{"lineNum":"  627","line":"                    const prev_bit = @intCast(std.math.Log2Int(Int), prev_bit_index);"},
{"lineNum":"  628","line":"                    const prev_mask = @as(Int, 1) << prev_bit;"},
{"lineNum":"  629","line":"                    try testing.expect(x.load(.SeqCst) & prev_mask == 0);"},
{"lineNum":"  630","line":"                }"},
{"lineNum":"  631","line":"            }"},
{"lineNum":"  632","line":"        }"},
{"lineNum":"  633","line":"    }"},
{"lineNum":"  634","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 16, "covered" : 12,};
var merged_data = [];
