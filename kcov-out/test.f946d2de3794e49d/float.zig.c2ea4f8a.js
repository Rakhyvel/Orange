var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"../std.zig\");"},
{"lineNum":"    2","line":"const assert = std.debug.assert;"},
{"lineNum":"    3","line":"const expect = std.testing.expect;"},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"/// Creates a raw \"1.0\" mantissa for floating point type T. Used to dedupe f80 logic."},
{"lineNum":"    6","line":"inline fn mantissaOne(comptime T: type) comptime_int {"},
{"lineNum":"    7","line":"    return if (@typeInfo(T).Float.bits == 80) 1 << floatFractionalBits(T) else 0;"},
{"lineNum":"    8","line":"}"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"/// Creates floating point type T from an unbiased exponent and raw mantissa."},
{"lineNum":"   11","line":"inline fn reconstructFloat(comptime T: type, comptime exponent: comptime_int, comptime mantissa: comptime_int) T {"},
{"lineNum":"   12","line":"    const TBits = @Type(.{ .Int = .{ .signedness = .unsigned, .bits = @bitSizeOf(T) } });"},
{"lineNum":"   13","line":"    const biased_exponent = @as(TBits, exponent + floatExponentMax(T));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   14","line":"    return @bitCast(T, (biased_exponent << floatMantissaBits(T)) | @as(TBits, mantissa));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   15","line":"}"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"/// Returns the number of bits in the exponent of floating point type T."},
{"lineNum":"   18","line":"pub inline fn floatExponentBits(comptime T: type) comptime_int {"},
{"lineNum":"   19","line":"    comptime assert(@typeInfo(T) == .Float);"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"    return switch (@typeInfo(T).Float.bits) {"},
{"lineNum":"   22","line":"        16 => 5,"},
{"lineNum":"   23","line":"        32 => 8,"},
{"lineNum":"   24","line":"        64 => 11,"},
{"lineNum":"   25","line":"        80 => 15,"},
{"lineNum":"   26","line":"        128 => 15,"},
{"lineNum":"   27","line":"        else => @compileError(\"unknown floating point type \" ++ @typeName(T)),"},
{"lineNum":"   28","line":"    };"},
{"lineNum":"   29","line":"}"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"/// Returns the number of bits in the mantissa of floating point type T."},
{"lineNum":"   32","line":"pub inline fn floatMantissaBits(comptime T: type) comptime_int {"},
{"lineNum":"   33","line":"    comptime assert(@typeInfo(T) == .Float);"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"    return switch (@typeInfo(T).Float.bits) {"},
{"lineNum":"   36","line":"        16 => 10,"},
{"lineNum":"   37","line":"        32 => 23,"},
{"lineNum":"   38","line":"        64 => 52,"},
{"lineNum":"   39","line":"        80 => 64,"},
{"lineNum":"   40","line":"        128 => 112,"},
{"lineNum":"   41","line":"        else => @compileError(\"unknown floating point type \" ++ @typeName(T)),"},
{"lineNum":"   42","line":"    };"},
{"lineNum":"   43","line":"}"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"/// Returns the number of fractional bits in the mantissa of floating point type T."},
{"lineNum":"   46","line":"pub inline fn floatFractionalBits(comptime T: type) comptime_int {"},
{"lineNum":"   47","line":"    comptime assert(@typeInfo(T) == .Float);"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"    // standard IEEE floats have an implicit 0.m or 1.m integer part"},
{"lineNum":"   50","line":"    // f80 is special and has an explicitly stored bit in the MSB"},
{"lineNum":"   51","line":"    // this function corresponds to `MANT_DIG - 1\' from C"},
{"lineNum":"   52","line":"    return switch (@typeInfo(T).Float.bits) {"},
{"lineNum":"   53","line":"        16 => 10,"},
{"lineNum":"   54","line":"        32 => 23,"},
{"lineNum":"   55","line":"        64 => 52,"},
{"lineNum":"   56","line":"        80 => 63,"},
{"lineNum":"   57","line":"        128 => 112,"},
{"lineNum":"   58","line":"        else => @compileError(\"unknown floating point type \" ++ @typeName(T)),"},
{"lineNum":"   59","line":"    };"},
{"lineNum":"   60","line":"}"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"/// Returns the minimum exponent that can represent"},
{"lineNum":"   63","line":"/// a normalised value in floating point type T."},
{"lineNum":"   64","line":"pub inline fn floatExponentMin(comptime T: type) comptime_int {"},
{"lineNum":"   65","line":"    return -floatExponentMax(T) + 1;"},
{"lineNum":"   66","line":"}"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"/// Returns the maximum exponent that can represent"},
{"lineNum":"   69","line":"/// a normalised value in floating point type T."},
{"lineNum":"   70","line":"pub inline fn floatExponentMax(comptime T: type) comptime_int {"},
{"lineNum":"   71","line":"    return (1 << (floatExponentBits(T) - 1)) - 1;"},
{"lineNum":"   72","line":"}"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"/// Returns the smallest subnormal number representable in floating point type T."},
{"lineNum":"   75","line":"pub inline fn floatTrueMin(comptime T: type) T {"},
{"lineNum":"   76","line":"    return reconstructFloat(T, floatExponentMin(T) - 1, 1);"},
{"lineNum":"   77","line":"}"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"/// Returns the smallest normal number representable in floating point type T."},
{"lineNum":"   80","line":"pub inline fn floatMin(comptime T: type) T {"},
{"lineNum":"   81","line":"    return reconstructFloat(T, floatExponentMin(T), mantissaOne(T));"},
{"lineNum":"   82","line":"}"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"/// Returns the largest normal number representable in floating point type T."},
{"lineNum":"   85","line":"pub inline fn floatMax(comptime T: type) T {"},
{"lineNum":"   86","line":"    const all1s_mantissa = (1 << floatMantissaBits(T)) - 1;"},
{"lineNum":"   87","line":"    return reconstructFloat(T, floatExponentMax(T), all1s_mantissa);"},
{"lineNum":"   88","line":"}"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"/// Returns the machine epsilon of floating point type T."},
{"lineNum":"   91","line":"pub inline fn floatEps(comptime T: type) T {"},
{"lineNum":"   92","line":"    return reconstructFloat(T, -floatFractionalBits(T), mantissaOne(T));"},
{"lineNum":"   93","line":"}"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"/// Returns the value inf for floating point type T."},
{"lineNum":"   96","line":"pub inline fn inf(comptime T: type) T {"},
{"lineNum":"   97","line":"    return reconstructFloat(T, floatExponentMax(T) + 1, mantissaOne(T));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   98","line":"}"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"test \"float bits\" {"},
{"lineNum":"  101","line":"    inline for ([_]type{ f16, f32, f64, f80, f128, c_longdouble }) |T| {"},
{"lineNum":"  102","line":"        // (1 +) for the sign bit, since it is separate from the other bits"},
{"lineNum":"  103","line":"        const size = 1 + floatExponentBits(T) + floatMantissaBits(T);"},
{"lineNum":"  104","line":"        try expect(@bitSizeOf(T) == size);"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"        // for machine epsilon, assert expmin <= -prec <= expmax"},
{"lineNum":"  107","line":"        try expect(floatExponentMin(T) <= -floatFractionalBits(T));"},
{"lineNum":"  108","line":"        try expect(-floatFractionalBits(T) <= floatExponentMax(T));"},
{"lineNum":"  109","line":"    }"},
{"lineNum":"  110","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 3, "covered" : 0,};
var merged_data = [];
