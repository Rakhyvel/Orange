var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std\");"},
{"lineNum":"    2","line":"const math = std.math;"},
{"lineNum":"    3","line":"const common = @import(\"common.zig\");"},
{"lineNum":"    4","line":"const BiasedFp = common.BiasedFp;"},
{"lineNum":"    5","line":"const Decimal = @import(\"decimal.zig\").Decimal;"},
{"lineNum":"    6","line":"const mantissaType = common.mantissaType;"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"const max_shift = 60;"},
{"lineNum":"    9","line":"const num_powers = 19;"},
{"lineNum":"   10","line":"const powers = [_]u8{ 0, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36, 39, 43, 46, 49, 53, 56, 59 };"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"pub fn getShift(n: usize) usize {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   13","line":"    return if (n < num_powers) powers[n] else max_shift;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   14","line":"}"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"/// Parse the significant digits and biased, binary exponent of a float."},
{"lineNum":"   17","line":"///"},
{"lineNum":"   18","line":"/// This is a fallback algorithm that uses a big-integer representation"},
{"lineNum":"   19","line":"/// of the float, and therefore is considerably slower than faster"},
{"lineNum":"   20","line":"/// approximations. However, it will always determine how to round"},
{"lineNum":"   21","line":"/// the significant digits to the nearest machine float, allowing"},
{"lineNum":"   22","line":"/// use to handle near half-way cases."},
{"lineNum":"   23","line":"///"},
{"lineNum":"   24","line":"/// Near half-way cases are halfway between two consecutive machine floats."},
{"lineNum":"   25","line":"/// For example, the float `16777217.0` has a bitwise representation of"},
{"lineNum":"   26","line":"/// `100000000000000000000000 1`. Rounding to a single-precision float,"},
{"lineNum":"   27","line":"/// the trailing `1` is truncated. Using round-nearest, tie-even, any"},
{"lineNum":"   28","line":"/// value above `16777217.0` must be rounded up to `16777218.0`, while"},
{"lineNum":"   29","line":"/// any value before or equal to `16777217.0` must be rounded down"},
{"lineNum":"   30","line":"/// to `16777216.0`. These near-halfway conversions therefore may require"},
{"lineNum":"   31","line":"/// a large number of digits to unambiguously determine how to round."},
{"lineNum":"   32","line":"///"},
{"lineNum":"   33","line":"/// The algorithms described here are based on \"Processing Long Numbers Quickly\","},
{"lineNum":"   34","line":"/// available here: <https://arxiv.org/pdf/2101.11408.pdf#section.11>."},
{"lineNum":"   35","line":"pub fn convertSlow(comptime T: type, s: []const u8) BiasedFp(T) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   36","line":"    const MantissaT = mantissaType(T);"},
{"lineNum":"   37","line":"    const min_exponent = -(1 << (math.floatExponentBits(T) - 1)) + 1;"},
{"lineNum":"   38","line":"    const infinite_power = (1 << math.floatExponentBits(T)) - 1;"},
{"lineNum":"   39","line":"    const mantissa_explicit_bits = math.floatMantissaBits(T);"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"    var d = Decimal(T).parse(s); // no need to recheck underscores","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   42","line":"    if (d.num_digits == 0 or d.decimal_point < Decimal(T).min_exponent) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   43","line":"        return BiasedFp(T).zero();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   44","line":"    } else if (d.decimal_point >= Decimal(T).max_exponent) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   45","line":"        return BiasedFp(T).inf(T);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   46","line":"    }"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"    var exp2: i32 = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   49","line":"    // Shift right toward (1/2 .. 1]"},
{"lineNum":"   50","line":"    while (d.decimal_point > 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   51","line":"        const n = @intCast(usize, d.decimal_point);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   52","line":"        const shift = getShift(n);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   53","line":"        d.rightShift(shift);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   54","line":"        if (d.decimal_point < -Decimal(T).decimal_point_range) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   55","line":"            return BiasedFp(T).zero();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   56","line":"        }"},
{"lineNum":"   57","line":"        exp2 += @intCast(i32, shift);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   58","line":"    }"},
{"lineNum":"   59","line":"    //  Shift left toward (1/2 .. 1]"},
{"lineNum":"   60","line":"    while (d.decimal_point <= 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   61","line":"        const shift = blk: {"},
{"lineNum":"   62","line":"            if (d.decimal_point == 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   63","line":"                break :blk switch (d.digits[0]) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   64","line":"                    5...9 => break,"},
{"lineNum":"   65","line":"                    0, 1 => @as(usize, 2),"},
{"lineNum":"   66","line":"                    else => 1,"},
{"lineNum":"   67","line":"                };"},
{"lineNum":"   68","line":"            } else {"},
{"lineNum":"   69","line":"                const n = @intCast(usize, -d.decimal_point);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   70","line":"                break :blk getShift(n);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   71","line":"            }"},
{"lineNum":"   72","line":"        };"},
{"lineNum":"   73","line":"        d.leftShift(shift);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   74","line":"        if (d.decimal_point > Decimal(T).decimal_point_range) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   75","line":"            return BiasedFp(T).inf(T);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   76","line":"        }"},
{"lineNum":"   77","line":"        exp2 -= @intCast(i32, shift);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   78","line":"    }"},
{"lineNum":"   79","line":"    // We are now in the range [1/2 .. 1] but the binary format uses [1 .. 2]"},
{"lineNum":"   80","line":"    exp2 -= 1;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   81","line":"    while (min_exponent + 1 > exp2) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   82","line":"        var n = @intCast(usize, (min_exponent + 1) - exp2);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   83","line":"        if (n > max_shift) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   84","line":"            n = max_shift;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   85","line":"        }"},
{"lineNum":"   86","line":"        d.rightShift(n);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   87","line":"        exp2 += @intCast(i32, n);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   88","line":"    }"},
{"lineNum":"   89","line":"    if (exp2 - min_exponent >= infinite_power) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   90","line":"        return BiasedFp(T).inf(T);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   91","line":"    }"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"    // Shift the decimal to the hidden bit, and then round the value"},
{"lineNum":"   94","line":"    // to get the high mantissa+1 bits."},
{"lineNum":"   95","line":"    d.leftShift(mantissa_explicit_bits + 1);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   96","line":"    var mantissa = d.round();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   97","line":"    if (mantissa >= (@as(MantissaT, 1) << (mantissa_explicit_bits + 1))) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   98","line":"        // Rounding up overflowed to the carry bit, need to"},
{"lineNum":"   99","line":"        // shift back to the hidden bit."},
{"lineNum":"  100","line":"        d.rightShift(1);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  101","line":"        exp2 += 1;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  102","line":"        mantissa = d.round();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  103","line":"        if ((exp2 - min_exponent) >= infinite_power) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  104","line":"            return BiasedFp(T).inf(T);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  105","line":"        }"},
{"lineNum":"  106","line":"    }"},
{"lineNum":"  107","line":"    var power2 = exp2 - min_exponent;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  108","line":"    if (mantissa < (@as(MantissaT, 1) << mantissa_explicit_bits)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  109","line":"        power2 -= 1;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  110","line":"    }"},
{"lineNum":"  111","line":"    // Zero out all the bits above the explicit mantissa bits."},
{"lineNum":"  112","line":"    mantissa &= (@as(MantissaT, 1) << mantissa_explicit_bits) - 1;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  113","line":"    return .{ .f = mantissa, .e = power2 };","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  114","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 47, "covered" : 0,};
var merged_data = [];
