var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std.zig\");"},
{"lineNum":"    2","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    3","line":"const root = @import(\"root\");"},
{"lineNum":"    4","line":"const os = std.os;"},
{"lineNum":"    5","line":"const mem = std.mem;"},
{"lineNum":"    6","line":"const base64 = std.base64;"},
{"lineNum":"    7","line":"const crypto = std.crypto;"},
{"lineNum":"    8","line":"const Allocator = std.mem.Allocator;"},
{"lineNum":"    9","line":"const assert = std.debug.assert;"},
{"lineNum":"   10","line":"const math = std.math;"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"const is_darwin = builtin.os.tag.isDarwin();"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"pub const has_executable_bit = switch (builtin.os.tag) {"},
{"lineNum":"   15","line":"    .windows, .wasi => false,"},
{"lineNum":"   16","line":"    else => true,"},
{"lineNum":"   17","line":"};"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"pub const path = @import(\"fs/path.zig\");"},
{"lineNum":"   20","line":"pub const File = @import(\"fs/file.zig\").File;"},
{"lineNum":"   21","line":"pub const wasi = @import(\"fs/wasi.zig\");"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"// TODO audit these APIs with respect to Dir and absolute paths"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"pub const realpath = os.realpath;"},
{"lineNum":"   26","line":"pub const realpathZ = os.realpathZ;"},
{"lineNum":"   27","line":"pub const realpathW = os.realpathW;"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"pub const getAppDataDir = @import(\"fs/get_app_data_dir.zig\").getAppDataDir;"},
{"lineNum":"   30","line":"pub const GetAppDataDirError = @import(\"fs/get_app_data_dir.zig\").GetAppDataDirError;"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"pub const Watch = @import(\"fs/watch.zig\").Watch;"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"/// This represents the maximum size of a UTF-8 encoded file path that the"},
{"lineNum":"   35","line":"/// operating system will accept. Paths, including those returned from file"},
{"lineNum":"   36","line":"/// system operations, may be longer than this length, but such paths cannot"},
{"lineNum":"   37","line":"/// be successfully passed back in other file system operations. However,"},
{"lineNum":"   38","line":"/// all path components returned by file system operations are assumed to"},
{"lineNum":"   39","line":"/// fit into a UTF-8 encoded array of this length."},
{"lineNum":"   40","line":"/// The byte count includes room for a null sentinel byte."},
{"lineNum":"   41","line":"pub const MAX_PATH_BYTES = switch (builtin.os.tag) {"},
{"lineNum":"   42","line":"    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .haiku, .solaris => os.PATH_MAX,"},
{"lineNum":"   43","line":"    // Each UTF-16LE character may be expanded to 3 UTF-8 bytes."},
{"lineNum":"   44","line":"    // If it would require 4 UTF-8 bytes, then there would be a surrogate"},
{"lineNum":"   45","line":"    // pair in the UTF-16LE, and we (over)account 3 bytes for it that way."},
{"lineNum":"   46","line":"    // +1 for the null byte at the end, which can be encoded in 1 byte."},
{"lineNum":"   47","line":"    .windows => os.windows.PATH_MAX_WIDE * 3 + 1,"},
{"lineNum":"   48","line":"    // TODO work out what a reasonable value we should use here"},
{"lineNum":"   49","line":"    .wasi => 4096,"},
{"lineNum":"   50","line":"    else => if (@hasDecl(root, \"os\") and @hasDecl(root.os, \"PATH_MAX\"))"},
{"lineNum":"   51","line":"        root.os.PATH_MAX"},
{"lineNum":"   52","line":"    else"},
{"lineNum":"   53","line":"        @compileError(\"PATH_MAX not implemented for \" ++ @tagName(builtin.os.tag)),"},
{"lineNum":"   54","line":"};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"/// This represents the maximum size of a UTF-8 encoded file name component that"},
{"lineNum":"   57","line":"/// the platform\'s common file systems support. File name components returned by file system"},
{"lineNum":"   58","line":"/// operations are likely to fit into a UTF-8 encoded array of this length, but"},
{"lineNum":"   59","line":"/// (depending on the platform) this assumption may not hold for every configuration."},
{"lineNum":"   60","line":"/// The byte count does not include a null sentinel byte."},
{"lineNum":"   61","line":"pub const MAX_NAME_BYTES = switch (builtin.os.tag) {"},
{"lineNum":"   62","line":"    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly => os.NAME_MAX,"},
{"lineNum":"   63","line":"    // Haiku\'s NAME_MAX includes the null terminator, so subtract one."},
{"lineNum":"   64","line":"    .haiku => os.NAME_MAX - 1,"},
{"lineNum":"   65","line":"    .solaris => os.system.MAXNAMLEN,"},
{"lineNum":"   66","line":"    // Each UTF-16LE character may be expanded to 3 UTF-8 bytes."},
{"lineNum":"   67","line":"    // If it would require 4 UTF-8 bytes, then there would be a surrogate"},
{"lineNum":"   68","line":"    // pair in the UTF-16LE, and we (over)account 3 bytes for it that way."},
{"lineNum":"   69","line":"    .windows => os.windows.NAME_MAX * 3,"},
{"lineNum":"   70","line":"    // For WASI, the MAX_NAME will depend on the host OS, so it needs to be"},
{"lineNum":"   71","line":"    // as large as the largest MAX_NAME_BYTES (Windows) in order to work on any host OS."},
{"lineNum":"   72","line":"    // TODO determine if this is a reasonable approach"},
{"lineNum":"   73","line":"    .wasi => os.windows.NAME_MAX * 3,"},
{"lineNum":"   74","line":"    else => if (@hasDecl(root, \"os\") and @hasDecl(root.os, \"NAME_MAX\"))"},
{"lineNum":"   75","line":"        root.os.NAME_MAX"},
{"lineNum":"   76","line":"    else"},
{"lineNum":"   77","line":"        @compileError(\"NAME_MAX not implemented for \" ++ @tagName(builtin.os.tag)),"},
{"lineNum":"   78","line":"};"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"pub const base64_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".*;"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"/// Base64 encoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem."},
{"lineNum":"   83","line":"pub const base64_encoder = base64.Base64Encoder.init(base64_alphabet, null);"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"/// Base64 decoder, replacing the standard `+/` with `-_` so that it can be used in a file name on any filesystem."},
{"lineNum":"   86","line":"pub const base64_decoder = base64.Base64Decoder.init(base64_alphabet, null);"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"/// Whether or not async file system syscalls need a dedicated thread because the operating"},
{"lineNum":"   89","line":"/// system does not support non-blocking I/O on the file system."},
{"lineNum":"   90","line":"pub const need_async_thread = std.io.is_async and switch (builtin.os.tag) {"},
{"lineNum":"   91","line":"    .windows, .other => false,"},
{"lineNum":"   92","line":"    else => true,"},
{"lineNum":"   93","line":"};"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"/// TODO remove the allocator requirement from this API"},
{"lineNum":"   96","line":"pub fn atomicSymLink(allocator: Allocator, existing_path: []const u8, new_path: []const u8) !void {"},
{"lineNum":"   97","line":"    if (cwd().symLink(existing_path, new_path, .{})) {"},
{"lineNum":"   98","line":"        return;"},
{"lineNum":"   99","line":"    } else |err| switch (err) {"},
{"lineNum":"  100","line":"        error.PathAlreadyExists => {},"},
{"lineNum":"  101","line":"        else => return err, // TODO zig should know this set does not include PathAlreadyExists"},
{"lineNum":"  102","line":"    }"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"    const dirname = path.dirname(new_path) orelse \".\";"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"    var rand_buf: [AtomicFile.RANDOM_BYTES]u8 = undefined;"},
{"lineNum":"  107","line":"    const tmp_path = try allocator.alloc(u8, dirname.len + 1 + base64_encoder.calcSize(rand_buf.len));"},
{"lineNum":"  108","line":"    defer allocator.free(tmp_path);"},
{"lineNum":"  109","line":"    mem.copy(u8, tmp_path[0..], dirname);"},
{"lineNum":"  110","line":"    tmp_path[dirname.len] = path.sep;"},
{"lineNum":"  111","line":"    while (true) {"},
{"lineNum":"  112","line":"        crypto.random.bytes(rand_buf[0..]);"},
{"lineNum":"  113","line":"        _ = base64_encoder.encode(tmp_path[dirname.len + 1 ..], &rand_buf);"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"        if (cwd().symLink(existing_path, tmp_path, .{})) {"},
{"lineNum":"  116","line":"            return cwd().rename(tmp_path, new_path);"},
{"lineNum":"  117","line":"        } else |err| switch (err) {"},
{"lineNum":"  118","line":"            error.PathAlreadyExists => continue,"},
{"lineNum":"  119","line":"            else => return err, // TODO zig should know this set does not include PathAlreadyExists"},
{"lineNum":"  120","line":"        }"},
{"lineNum":"  121","line":"    }"},
{"lineNum":"  122","line":"}"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"pub const PrevStatus = enum {"},
{"lineNum":"  125","line":"    stale,"},
{"lineNum":"  126","line":"    fresh,"},
{"lineNum":"  127","line":"};"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"pub const CopyFileOptions = struct {"},
{"lineNum":"  130","line":"    /// When this is `null` the mode is copied from the source file."},
{"lineNum":"  131","line":"    override_mode: ?File.Mode = null,"},
{"lineNum":"  132","line":"};"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"/// Same as `Dir.updateFile`, except asserts that both `source_path` and `dest_path`"},
{"lineNum":"  135","line":"/// are absolute. See `Dir.updateFile` for a function that operates on both"},
{"lineNum":"  136","line":"/// absolute and relative paths."},
{"lineNum":"  137","line":"pub fn updateFileAbsolute("},
{"lineNum":"  138","line":"    source_path: []const u8,"},
{"lineNum":"  139","line":"    dest_path: []const u8,"},
{"lineNum":"  140","line":"    args: CopyFileOptions,"},
{"lineNum":"  141","line":") !PrevStatus {"},
{"lineNum":"  142","line":"    assert(path.isAbsolute(source_path));"},
{"lineNum":"  143","line":"    assert(path.isAbsolute(dest_path));"},
{"lineNum":"  144","line":"    const my_cwd = cwd();"},
{"lineNum":"  145","line":"    return Dir.updateFile(my_cwd, source_path, my_cwd, dest_path, args);"},
{"lineNum":"  146","line":"}"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"/// Same as `Dir.copyFile`, except asserts that both `source_path` and `dest_path`"},
{"lineNum":"  149","line":"/// are absolute. See `Dir.copyFile` for a function that operates on both"},
{"lineNum":"  150","line":"/// absolute and relative paths."},
{"lineNum":"  151","line":"pub fn copyFileAbsolute(source_path: []const u8, dest_path: []const u8, args: CopyFileOptions) !void {"},
{"lineNum":"  152","line":"    assert(path.isAbsolute(source_path));"},
{"lineNum":"  153","line":"    assert(path.isAbsolute(dest_path));"},
{"lineNum":"  154","line":"    const my_cwd = cwd();"},
{"lineNum":"  155","line":"    return Dir.copyFile(my_cwd, source_path, my_cwd, dest_path, args);"},
{"lineNum":"  156","line":"}"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"pub const AtomicFile = struct {"},
{"lineNum":"  159","line":"    file: File,"},
{"lineNum":"  160","line":"    // TODO either replace this with rand_buf or use []u16 on Windows"},
{"lineNum":"  161","line":"    tmp_path_buf: [TMP_PATH_LEN:0]u8,"},
{"lineNum":"  162","line":"    dest_basename: []const u8,"},
{"lineNum":"  163","line":"    file_open: bool,"},
{"lineNum":"  164","line":"    file_exists: bool,"},
{"lineNum":"  165","line":"    close_dir_on_deinit: bool,"},
{"lineNum":"  166","line":"    dir: Dir,"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"    const InitError = File.OpenError;"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"    const RANDOM_BYTES = 12;"},
{"lineNum":"  171","line":"    const TMP_PATH_LEN = base64_encoder.calcSize(RANDOM_BYTES);"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"    /// Note that the `Dir.atomicFile` API may be more handy than this lower-level function."},
{"lineNum":"  174","line":"    pub fn init("},
{"lineNum":"  175","line":"        dest_basename: []const u8,"},
{"lineNum":"  176","line":"        mode: File.Mode,"},
{"lineNum":"  177","line":"        dir: Dir,"},
{"lineNum":"  178","line":"        close_dir_on_deinit: bool,"},
{"lineNum":"  179","line":"    ) InitError!AtomicFile {"},
{"lineNum":"  180","line":"        var rand_buf: [RANDOM_BYTES]u8 = undefined;"},
{"lineNum":"  181","line":"        var tmp_path_buf: [TMP_PATH_LEN:0]u8 = undefined;"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"        while (true) {"},
{"lineNum":"  184","line":"            crypto.random.bytes(rand_buf[0..]);"},
{"lineNum":"  185","line":"            const tmp_path = base64_encoder.encode(&tmp_path_buf, &rand_buf);"},
{"lineNum":"  186","line":"            tmp_path_buf[tmp_path.len] = 0;"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"            const file = dir.createFile("},
{"lineNum":"  189","line":"                tmp_path,"},
{"lineNum":"  190","line":"                .{ .mode = mode, .exclusive = true },"},
{"lineNum":"  191","line":"            ) catch |err| switch (err) {"},
{"lineNum":"  192","line":"                error.PathAlreadyExists => continue,"},
{"lineNum":"  193","line":"                else => |e| return e,"},
{"lineNum":"  194","line":"            };"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"            return AtomicFile{"},
{"lineNum":"  197","line":"                .file = file,"},
{"lineNum":"  198","line":"                .tmp_path_buf = tmp_path_buf,"},
{"lineNum":"  199","line":"                .dest_basename = dest_basename,"},
{"lineNum":"  200","line":"                .file_open = true,"},
{"lineNum":"  201","line":"                .file_exists = true,"},
{"lineNum":"  202","line":"                .close_dir_on_deinit = close_dir_on_deinit,"},
{"lineNum":"  203","line":"                .dir = dir,"},
{"lineNum":"  204","line":"            };"},
{"lineNum":"  205","line":"        }"},
{"lineNum":"  206","line":"    }"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"    /// always call deinit, even after successful finish()"},
{"lineNum":"  209","line":"    pub fn deinit(self: *AtomicFile) void {"},
{"lineNum":"  210","line":"        if (self.file_open) {"},
{"lineNum":"  211","line":"            self.file.close();"},
{"lineNum":"  212","line":"            self.file_open = false;"},
{"lineNum":"  213","line":"        }"},
{"lineNum":"  214","line":"        if (self.file_exists) {"},
{"lineNum":"  215","line":"            self.dir.deleteFile(&self.tmp_path_buf) catch {};"},
{"lineNum":"  216","line":"            self.file_exists = false;"},
{"lineNum":"  217","line":"        }"},
{"lineNum":"  218","line":"        if (self.close_dir_on_deinit) {"},
{"lineNum":"  219","line":"            self.dir.close();"},
{"lineNum":"  220","line":"        }"},
{"lineNum":"  221","line":"        self.* = undefined;"},
{"lineNum":"  222","line":"    }"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"    pub const FinishError = std.os.RenameError;"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"    pub fn finish(self: *AtomicFile) FinishError!void {"},
{"lineNum":"  227","line":"        assert(self.file_exists);"},
{"lineNum":"  228","line":"        if (self.file_open) {"},
{"lineNum":"  229","line":"            self.file.close();"},
{"lineNum":"  230","line":"            self.file_open = false;"},
{"lineNum":"  231","line":"        }"},
{"lineNum":"  232","line":"        try os.renameat(self.dir.fd, self.tmp_path_buf[0..], self.dir.fd, self.dest_basename);"},
{"lineNum":"  233","line":"        self.file_exists = false;"},
{"lineNum":"  234","line":"    }"},
{"lineNum":"  235","line":"};"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"const default_new_dir_mode = 0o755;"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"/// Create a new directory, based on an absolute path."},
{"lineNum":"  240","line":"/// Asserts that the path is absolute. See `Dir.makeDir` for a function that operates"},
{"lineNum":"  241","line":"/// on both absolute and relative paths."},
{"lineNum":"  242","line":"pub fn makeDirAbsolute(absolute_path: []const u8) !void {"},
{"lineNum":"  243","line":"    assert(path.isAbsolute(absolute_path));"},
{"lineNum":"  244","line":"    return os.mkdir(absolute_path, default_new_dir_mode);"},
{"lineNum":"  245","line":"}"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"/// Same as `makeDirAbsolute` except the parameter is a null-terminated UTF8-encoded string."},
{"lineNum":"  248","line":"pub fn makeDirAbsoluteZ(absolute_path_z: [*:0]const u8) !void {"},
{"lineNum":"  249","line":"    assert(path.isAbsoluteZ(absolute_path_z));"},
{"lineNum":"  250","line":"    return os.mkdirZ(absolute_path_z, default_new_dir_mode);"},
{"lineNum":"  251","line":"}"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"/// Same as `makeDirAbsolute` except the parameter is a null-terminated WTF-16 encoded string."},
{"lineNum":"  254","line":"pub fn makeDirAbsoluteW(absolute_path_w: [*:0]const u16) !void {"},
{"lineNum":"  255","line":"    assert(path.isAbsoluteWindowsW(absolute_path_w));"},
{"lineNum":"  256","line":"    return os.mkdirW(absolute_path_w, default_new_dir_mode);"},
{"lineNum":"  257","line":"}"},
{"lineNum":"  258","line":""},
{"lineNum":"  259","line":"/// Same as `Dir.deleteDir` except the path is absolute."},
{"lineNum":"  260","line":"pub fn deleteDirAbsolute(dir_path: []const u8) !void {"},
{"lineNum":"  261","line":"    assert(path.isAbsolute(dir_path));"},
{"lineNum":"  262","line":"    return os.rmdir(dir_path);"},
{"lineNum":"  263","line":"}"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"/// Same as `deleteDirAbsolute` except the path parameter is null-terminated."},
{"lineNum":"  266","line":"pub fn deleteDirAbsoluteZ(dir_path: [*:0]const u8) !void {"},
{"lineNum":"  267","line":"    assert(path.isAbsoluteZ(dir_path));"},
{"lineNum":"  268","line":"    return os.rmdirZ(dir_path);"},
{"lineNum":"  269","line":"}"},
{"lineNum":"  270","line":""},
{"lineNum":"  271","line":"/// Same as `deleteDirAbsolute` except the path parameter is WTF-16 and target OS is assumed Windows."},
{"lineNum":"  272","line":"pub fn deleteDirAbsoluteW(dir_path: [*:0]const u16) !void {"},
{"lineNum":"  273","line":"    assert(path.isAbsoluteWindowsW(dir_path));"},
{"lineNum":"  274","line":"    return os.rmdirW(dir_path);"},
{"lineNum":"  275","line":"}"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"/// Same as `Dir.rename` except the paths are absolute."},
{"lineNum":"  278","line":"pub fn renameAbsolute(old_path: []const u8, new_path: []const u8) !void {"},
{"lineNum":"  279","line":"    assert(path.isAbsolute(old_path));"},
{"lineNum":"  280","line":"    assert(path.isAbsolute(new_path));"},
{"lineNum":"  281","line":"    return os.rename(old_path, new_path);"},
{"lineNum":"  282","line":"}"},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"/// Same as `renameAbsolute` except the path parameters are null-terminated."},
{"lineNum":"  285","line":"pub fn renameAbsoluteZ(old_path: [*:0]const u8, new_path: [*:0]const u8) !void {"},
{"lineNum":"  286","line":"    assert(path.isAbsoluteZ(old_path));"},
{"lineNum":"  287","line":"    assert(path.isAbsoluteZ(new_path));"},
{"lineNum":"  288","line":"    return os.renameZ(old_path, new_path);"},
{"lineNum":"  289","line":"}"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"/// Same as `renameAbsolute` except the path parameters are WTF-16 and target OS is assumed Windows."},
{"lineNum":"  292","line":"pub fn renameAbsoluteW(old_path: [*:0]const u16, new_path: [*:0]const u16) !void {"},
{"lineNum":"  293","line":"    assert(path.isAbsoluteWindowsW(old_path));"},
{"lineNum":"  294","line":"    assert(path.isAbsoluteWindowsW(new_path));"},
{"lineNum":"  295","line":"    return os.renameW(old_path, new_path);"},
{"lineNum":"  296","line":"}"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"/// Same as `Dir.rename`, except `new_sub_path` is relative to `new_dir`"},
{"lineNum":"  299","line":"pub fn rename(old_dir: Dir, old_sub_path: []const u8, new_dir: Dir, new_sub_path: []const u8) !void {"},
{"lineNum":"  300","line":"    return os.renameat(old_dir.fd, old_sub_path, new_dir.fd, new_sub_path);"},
{"lineNum":"  301","line":"}"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"/// Same as `rename` except the parameters are null-terminated."},
{"lineNum":"  304","line":"pub fn renameZ(old_dir: Dir, old_sub_path_z: [*:0]const u8, new_dir: Dir, new_sub_path_z: [*:0]const u8) !void {"},
{"lineNum":"  305","line":"    return os.renameatZ(old_dir.fd, old_sub_path_z, new_dir.fd, new_sub_path_z);"},
{"lineNum":"  306","line":"}"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"/// Same as `rename` except the parameters are UTF16LE, NT prefixed."},
{"lineNum":"  309","line":"/// This function is Windows-only."},
{"lineNum":"  310","line":"pub fn renameW(old_dir: Dir, old_sub_path_w: []const u16, new_dir: Dir, new_sub_path_w: []const u16) !void {"},
{"lineNum":"  311","line":"    return os.renameatW(old_dir.fd, old_sub_path_w, new_dir.fd, new_sub_path_w);"},
{"lineNum":"  312","line":"}"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"/// A directory that can be iterated. It is *NOT* legal to initialize this with a regular `Dir`"},
{"lineNum":"  315","line":"/// that has been opened without iteration permission."},
{"lineNum":"  316","line":"pub const IterableDir = struct {"},
{"lineNum":"  317","line":"    dir: Dir,"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"    pub const Entry = struct {"},
{"lineNum":"  320","line":"        name: []const u8,"},
{"lineNum":"  321","line":"        kind: Kind,"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"        pub const Kind = File.Kind;"},
{"lineNum":"  324","line":"    };"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"    const IteratorError = error{ AccessDenied, SystemResources } || os.UnexpectedError;"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"    pub const Iterator = switch (builtin.os.tag) {"},
{"lineNum":"  329","line":"        .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris => struct {"},
{"lineNum":"  330","line":"            dir: Dir,"},
{"lineNum":"  331","line":"            seek: i64,"},
{"lineNum":"  332","line":"            buf: [1024]u8, // TODO align(@alignOf(os.system.dirent)),"},
{"lineNum":"  333","line":"            index: usize,"},
{"lineNum":"  334","line":"            end_index: usize,"},
{"lineNum":"  335","line":"            first_iter: bool,"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"            const Self = @This();"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"            pub const Error = IteratorError;"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"            /// Memory such as file names referenced in this returned entry becomes invalid"},
{"lineNum":"  342","line":"            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized."},
{"lineNum":"  343","line":"            pub fn next(self: *Self) Error!?Entry {"},
{"lineNum":"  344","line":"                switch (builtin.os.tag) {"},
{"lineNum":"  345","line":"                    .macos, .ios => return self.nextDarwin(),"},
{"lineNum":"  346","line":"                    .freebsd, .netbsd, .dragonfly, .openbsd => return self.nextBsd(),"},
{"lineNum":"  347","line":"                    .solaris => return self.nextSolaris(),"},
{"lineNum":"  348","line":"                    else => @compileError(\"unimplemented\"),"},
{"lineNum":"  349","line":"                }"},
{"lineNum":"  350","line":"            }"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"            fn nextDarwin(self: *Self) !?Entry {"},
{"lineNum":"  353","line":"                start_over: while (true) {"},
{"lineNum":"  354","line":"                    if (self.index >= self.end_index) {"},
{"lineNum":"  355","line":"                        if (self.first_iter) {"},
{"lineNum":"  356","line":"                            std.os.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions"},
{"lineNum":"  357","line":"                            self.first_iter = false;"},
{"lineNum":"  358","line":"                        }"},
{"lineNum":"  359","line":"                        const rc = os.system.__getdirentries64("},
{"lineNum":"  360","line":"                            self.dir.fd,"},
{"lineNum":"  361","line":"                            &self.buf,"},
{"lineNum":"  362","line":"                            self.buf.len,"},
{"lineNum":"  363","line":"                            &self.seek,"},
{"lineNum":"  364","line":"                        );"},
{"lineNum":"  365","line":"                        if (rc == 0) return null;"},
{"lineNum":"  366","line":"                        if (rc < 0) {"},
{"lineNum":"  367","line":"                            switch (os.errno(rc)) {"},
{"lineNum":"  368","line":"                                .BADF => unreachable, // Dir is invalid or was opened without iteration ability"},
{"lineNum":"  369","line":"                                .FAULT => unreachable,"},
{"lineNum":"  370","line":"                                .NOTDIR => unreachable,"},
{"lineNum":"  371","line":"                                .INVAL => unreachable,"},
{"lineNum":"  372","line":"                                else => |err| return os.unexpectedErrno(err),"},
{"lineNum":"  373","line":"                            }"},
{"lineNum":"  374","line":"                        }"},
{"lineNum":"  375","line":"                        self.index = 0;"},
{"lineNum":"  376","line":"                        self.end_index = @intCast(usize, rc);"},
{"lineNum":"  377","line":"                    }"},
{"lineNum":"  378","line":"                    const darwin_entry = @ptrCast(*align(1) os.system.dirent, &self.buf[self.index]);"},
{"lineNum":"  379","line":"                    const next_index = self.index + darwin_entry.reclen();"},
{"lineNum":"  380","line":"                    self.index = next_index;"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"                    const name = @ptrCast([*]u8, &darwin_entry.d_name)[0..darwin_entry.d_namlen];"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\") or (darwin_entry.d_ino == 0)) {"},
{"lineNum":"  385","line":"                        continue :start_over;"},
{"lineNum":"  386","line":"                    }"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"                    const entry_kind = switch (darwin_entry.d_type) {"},
{"lineNum":"  389","line":"                        os.DT.BLK => Entry.Kind.BlockDevice,"},
{"lineNum":"  390","line":"                        os.DT.CHR => Entry.Kind.CharacterDevice,"},
{"lineNum":"  391","line":"                        os.DT.DIR => Entry.Kind.Directory,"},
{"lineNum":"  392","line":"                        os.DT.FIFO => Entry.Kind.NamedPipe,"},
{"lineNum":"  393","line":"                        os.DT.LNK => Entry.Kind.SymLink,"},
{"lineNum":"  394","line":"                        os.DT.REG => Entry.Kind.File,"},
{"lineNum":"  395","line":"                        os.DT.SOCK => Entry.Kind.UnixDomainSocket,"},
{"lineNum":"  396","line":"                        os.DT.WHT => Entry.Kind.Whiteout,"},
{"lineNum":"  397","line":"                        else => Entry.Kind.Unknown,"},
{"lineNum":"  398","line":"                    };"},
{"lineNum":"  399","line":"                    return Entry{"},
{"lineNum":"  400","line":"                        .name = name,"},
{"lineNum":"  401","line":"                        .kind = entry_kind,"},
{"lineNum":"  402","line":"                    };"},
{"lineNum":"  403","line":"                }"},
{"lineNum":"  404","line":"            }"},
{"lineNum":"  405","line":""},
{"lineNum":"  406","line":"            fn nextSolaris(self: *Self) !?Entry {"},
{"lineNum":"  407","line":"                start_over: while (true) {"},
{"lineNum":"  408","line":"                    if (self.index >= self.end_index) {"},
{"lineNum":"  409","line":"                        if (self.first_iter) {"},
{"lineNum":"  410","line":"                            std.os.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions"},
{"lineNum":"  411","line":"                            self.first_iter = false;"},
{"lineNum":"  412","line":"                        }"},
{"lineNum":"  413","line":"                        const rc = os.system.getdents(self.dir.fd, &self.buf, self.buf.len);"},
{"lineNum":"  414","line":"                        switch (os.errno(rc)) {"},
{"lineNum":"  415","line":"                            .SUCCESS => {},"},
{"lineNum":"  416","line":"                            .BADF => unreachable, // Dir is invalid or was opened without iteration ability"},
{"lineNum":"  417","line":"                            .FAULT => unreachable,"},
{"lineNum":"  418","line":"                            .NOTDIR => unreachable,"},
{"lineNum":"  419","line":"                            .INVAL => unreachable,"},
{"lineNum":"  420","line":"                            else => |err| return os.unexpectedErrno(err),"},
{"lineNum":"  421","line":"                        }"},
{"lineNum":"  422","line":"                        if (rc == 0) return null;"},
{"lineNum":"  423","line":"                        self.index = 0;"},
{"lineNum":"  424","line":"                        self.end_index = @intCast(usize, rc);"},
{"lineNum":"  425","line":"                    }"},
{"lineNum":"  426","line":"                    const entry = @ptrCast(*align(1) os.system.dirent, &self.buf[self.index]);"},
{"lineNum":"  427","line":"                    const next_index = self.index + entry.reclen();"},
{"lineNum":"  428","line":"                    self.index = next_index;"},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"                    const name = mem.sliceTo(@ptrCast([*:0]u8, &entry.d_name), 0);"},
{"lineNum":"  431","line":"                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\"))"},
{"lineNum":"  432","line":"                        continue :start_over;"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"                    // Solaris dirent doesn\'t expose d_type, so we have to call stat to get it."},
{"lineNum":"  435","line":"                    const stat_info = os.fstatat("},
{"lineNum":"  436","line":"                        self.dir.fd,"},
{"lineNum":"  437","line":"                        name,"},
{"lineNum":"  438","line":"                        os.AT.SYMLINK_NOFOLLOW,"},
{"lineNum":"  439","line":"                    ) catch |err| switch (err) {"},
{"lineNum":"  440","line":"                        error.NameTooLong => unreachable,"},
{"lineNum":"  441","line":"                        error.SymLinkLoop => unreachable,"},
{"lineNum":"  442","line":"                        error.FileNotFound => unreachable, // lost the race"},
{"lineNum":"  443","line":"                        else => |e| return e,"},
{"lineNum":"  444","line":"                    };"},
{"lineNum":"  445","line":"                    const entry_kind = switch (stat_info.mode & os.S.IFMT) {"},
{"lineNum":"  446","line":"                        os.S.IFIFO => Entry.Kind.NamedPipe,"},
{"lineNum":"  447","line":"                        os.S.IFCHR => Entry.Kind.CharacterDevice,"},
{"lineNum":"  448","line":"                        os.S.IFDIR => Entry.Kind.Directory,"},
{"lineNum":"  449","line":"                        os.S.IFBLK => Entry.Kind.BlockDevice,"},
{"lineNum":"  450","line":"                        os.S.IFREG => Entry.Kind.File,"},
{"lineNum":"  451","line":"                        os.S.IFLNK => Entry.Kind.SymLink,"},
{"lineNum":"  452","line":"                        os.S.IFSOCK => Entry.Kind.UnixDomainSocket,"},
{"lineNum":"  453","line":"                        os.S.IFDOOR => Entry.Kind.Door,"},
{"lineNum":"  454","line":"                        os.S.IFPORT => Entry.Kind.EventPort,"},
{"lineNum":"  455","line":"                        else => Entry.Kind.Unknown,"},
{"lineNum":"  456","line":"                    };"},
{"lineNum":"  457","line":"                    return Entry{"},
{"lineNum":"  458","line":"                        .name = name,"},
{"lineNum":"  459","line":"                        .kind = entry_kind,"},
{"lineNum":"  460","line":"                    };"},
{"lineNum":"  461","line":"                }"},
{"lineNum":"  462","line":"            }"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"            fn nextBsd(self: *Self) !?Entry {"},
{"lineNum":"  465","line":"                start_over: while (true) {"},
{"lineNum":"  466","line":"                    if (self.index >= self.end_index) {"},
{"lineNum":"  467","line":"                        if (self.first_iter) {"},
{"lineNum":"  468","line":"                            std.os.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions"},
{"lineNum":"  469","line":"                            self.first_iter = false;"},
{"lineNum":"  470","line":"                        }"},
{"lineNum":"  471","line":"                        const rc = if (builtin.os.tag == .netbsd)"},
{"lineNum":"  472","line":"                            os.system.__getdents30(self.dir.fd, &self.buf, self.buf.len)"},
{"lineNum":"  473","line":"                        else"},
{"lineNum":"  474","line":"                            os.system.getdents(self.dir.fd, &self.buf, self.buf.len);"},
{"lineNum":"  475","line":"                        switch (os.errno(rc)) {"},
{"lineNum":"  476","line":"                            .SUCCESS => {},"},
{"lineNum":"  477","line":"                            .BADF => unreachable, // Dir is invalid or was opened without iteration ability"},
{"lineNum":"  478","line":"                            .FAULT => unreachable,"},
{"lineNum":"  479","line":"                            .NOTDIR => unreachable,"},
{"lineNum":"  480","line":"                            .INVAL => unreachable,"},
{"lineNum":"  481","line":"                            else => |err| return os.unexpectedErrno(err),"},
{"lineNum":"  482","line":"                        }"},
{"lineNum":"  483","line":"                        if (rc == 0) return null;"},
{"lineNum":"  484","line":"                        self.index = 0;"},
{"lineNum":"  485","line":"                        self.end_index = @intCast(usize, rc);"},
{"lineNum":"  486","line":"                    }"},
{"lineNum":"  487","line":"                    const bsd_entry = @ptrCast(*align(1) os.system.dirent, &self.buf[self.index]);"},
{"lineNum":"  488","line":"                    const next_index = self.index + bsd_entry.reclen();"},
{"lineNum":"  489","line":"                    self.index = next_index;"},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"                    const name = @ptrCast([*]u8, &bsd_entry.d_name)[0..bsd_entry.d_namlen];"},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"                    const skip_zero_fileno = switch (builtin.os.tag) {"},
{"lineNum":"  494","line":"                        // d_fileno=0 is used to mark invalid entries or deleted files."},
{"lineNum":"  495","line":"                        .openbsd, .netbsd => true,"},
{"lineNum":"  496","line":"                        else => false,"},
{"lineNum":"  497","line":"                    };"},
{"lineNum":"  498","line":"                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\") or"},
{"lineNum":"  499","line":"                        (skip_zero_fileno and bsd_entry.d_fileno == 0))"},
{"lineNum":"  500","line":"                    {"},
{"lineNum":"  501","line":"                        continue :start_over;"},
{"lineNum":"  502","line":"                    }"},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"                    const entry_kind = switch (bsd_entry.d_type) {"},
{"lineNum":"  505","line":"                        os.DT.BLK => Entry.Kind.BlockDevice,"},
{"lineNum":"  506","line":"                        os.DT.CHR => Entry.Kind.CharacterDevice,"},
{"lineNum":"  507","line":"                        os.DT.DIR => Entry.Kind.Directory,"},
{"lineNum":"  508","line":"                        os.DT.FIFO => Entry.Kind.NamedPipe,"},
{"lineNum":"  509","line":"                        os.DT.LNK => Entry.Kind.SymLink,"},
{"lineNum":"  510","line":"                        os.DT.REG => Entry.Kind.File,"},
{"lineNum":"  511","line":"                        os.DT.SOCK => Entry.Kind.UnixDomainSocket,"},
{"lineNum":"  512","line":"                        os.DT.WHT => Entry.Kind.Whiteout,"},
{"lineNum":"  513","line":"                        else => Entry.Kind.Unknown,"},
{"lineNum":"  514","line":"                    };"},
{"lineNum":"  515","line":"                    return Entry{"},
{"lineNum":"  516","line":"                        .name = name,"},
{"lineNum":"  517","line":"                        .kind = entry_kind,"},
{"lineNum":"  518","line":"                    };"},
{"lineNum":"  519","line":"                }"},
{"lineNum":"  520","line":"            }"},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"            pub fn reset(self: *Self) void {"},
{"lineNum":"  523","line":"                self.index = 0;"},
{"lineNum":"  524","line":"                self.end_index = 0;"},
{"lineNum":"  525","line":"                self.first_iter = true;"},
{"lineNum":"  526","line":"            }"},
{"lineNum":"  527","line":"        },"},
{"lineNum":"  528","line":"        .haiku => struct {"},
{"lineNum":"  529","line":"            dir: Dir,"},
{"lineNum":"  530","line":"            buf: [1024]u8, // TODO align(@alignOf(os.dirent64)),"},
{"lineNum":"  531","line":"            index: usize,"},
{"lineNum":"  532","line":"            end_index: usize,"},
{"lineNum":"  533","line":"            first_iter: bool,"},
{"lineNum":"  534","line":""},
{"lineNum":"  535","line":"            const Self = @This();"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"            pub const Error = IteratorError;"},
{"lineNum":"  538","line":""},
{"lineNum":"  539","line":"            /// Memory such as file names referenced in this returned entry becomes invalid"},
{"lineNum":"  540","line":"            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized."},
{"lineNum":"  541","line":"            pub fn next(self: *Self) Error!?Entry {"},
{"lineNum":"  542","line":"                start_over: while (true) {"},
{"lineNum":"  543","line":"                    // TODO: find a better max"},
{"lineNum":"  544","line":"                    const HAIKU_MAX_COUNT = 10000;"},
{"lineNum":"  545","line":"                    if (self.index >= self.end_index) {"},
{"lineNum":"  546","line":"                        if (self.first_iter) {"},
{"lineNum":"  547","line":"                            std.os.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions"},
{"lineNum":"  548","line":"                            self.first_iter = false;"},
{"lineNum":"  549","line":"                        }"},
{"lineNum":"  550","line":"                        const rc = os.system._kern_read_dir("},
{"lineNum":"  551","line":"                            self.dir.fd,"},
{"lineNum":"  552","line":"                            &self.buf,"},
{"lineNum":"  553","line":"                            self.buf.len,"},
{"lineNum":"  554","line":"                            HAIKU_MAX_COUNT,"},
{"lineNum":"  555","line":"                        );"},
{"lineNum":"  556","line":"                        if (rc == 0) return null;"},
{"lineNum":"  557","line":"                        if (rc < 0) {"},
{"lineNum":"  558","line":"                            switch (os.errno(rc)) {"},
{"lineNum":"  559","line":"                                .BADF => unreachable, // Dir is invalid or was opened without iteration ability"},
{"lineNum":"  560","line":"                                .FAULT => unreachable,"},
{"lineNum":"  561","line":"                                .NOTDIR => unreachable,"},
{"lineNum":"  562","line":"                                .INVAL => unreachable,"},
{"lineNum":"  563","line":"                                else => |err| return os.unexpectedErrno(err),"},
{"lineNum":"  564","line":"                            }"},
{"lineNum":"  565","line":"                        }"},
{"lineNum":"  566","line":"                        self.index = 0;"},
{"lineNum":"  567","line":"                        self.end_index = @intCast(usize, rc);"},
{"lineNum":"  568","line":"                    }"},
{"lineNum":"  569","line":"                    const haiku_entry = @ptrCast(*align(1) os.system.dirent, &self.buf[self.index]);"},
{"lineNum":"  570","line":"                    const next_index = self.index + haiku_entry.reclen();"},
{"lineNum":"  571","line":"                    self.index = next_index;"},
{"lineNum":"  572","line":"                    const name = mem.sliceTo(@ptrCast([*:0]u8, &haiku_entry.d_name), 0);"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\") or (haiku_entry.d_ino == 0)) {"},
{"lineNum":"  575","line":"                        continue :start_over;"},
{"lineNum":"  576","line":"                    }"},
{"lineNum":"  577","line":""},
{"lineNum":"  578","line":"                    var stat_info: os.Stat = undefined;"},
{"lineNum":"  579","line":"                    const rc = os.system._kern_read_stat("},
{"lineNum":"  580","line":"                        self.dir.fd,"},
{"lineNum":"  581","line":"                        &haiku_entry.d_name,"},
{"lineNum":"  582","line":"                        false,"},
{"lineNum":"  583","line":"                        &stat_info,"},
{"lineNum":"  584","line":"                        0,"},
{"lineNum":"  585","line":"                    );"},
{"lineNum":"  586","line":"                    if (rc != 0) {"},
{"lineNum":"  587","line":"                        switch (os.errno(rc)) {"},
{"lineNum":"  588","line":"                            .SUCCESS => {},"},
{"lineNum":"  589","line":"                            .BADF => unreachable, // Dir is invalid or was opened without iteration ability"},
{"lineNum":"  590","line":"                            .FAULT => unreachable,"},
{"lineNum":"  591","line":"                            .NOTDIR => unreachable,"},
{"lineNum":"  592","line":"                            .INVAL => unreachable,"},
{"lineNum":"  593","line":"                            else => |err| return os.unexpectedErrno(err),"},
{"lineNum":"  594","line":"                        }"},
{"lineNum":"  595","line":"                    }"},
{"lineNum":"  596","line":"                    const statmode = stat_info.mode & os.S.IFMT;"},
{"lineNum":"  597","line":""},
{"lineNum":"  598","line":"                    const entry_kind = switch (statmode) {"},
{"lineNum":"  599","line":"                        os.S.IFDIR => Entry.Kind.Directory,"},
{"lineNum":"  600","line":"                        os.S.IFBLK => Entry.Kind.BlockDevice,"},
{"lineNum":"  601","line":"                        os.S.IFCHR => Entry.Kind.CharacterDevice,"},
{"lineNum":"  602","line":"                        os.S.IFLNK => Entry.Kind.SymLink,"},
{"lineNum":"  603","line":"                        os.S.IFREG => Entry.Kind.File,"},
{"lineNum":"  604","line":"                        os.S.IFIFO => Entry.Kind.NamedPipe,"},
{"lineNum":"  605","line":"                        else => Entry.Kind.Unknown,"},
{"lineNum":"  606","line":"                    };"},
{"lineNum":"  607","line":""},
{"lineNum":"  608","line":"                    return Entry{"},
{"lineNum":"  609","line":"                        .name = name,"},
{"lineNum":"  610","line":"                        .kind = entry_kind,"},
{"lineNum":"  611","line":"                    };"},
{"lineNum":"  612","line":"                }"},
{"lineNum":"  613","line":"            }"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"            pub fn reset(self: *Self) void {"},
{"lineNum":"  616","line":"                self.index = 0;"},
{"lineNum":"  617","line":"                self.end_index = 0;"},
{"lineNum":"  618","line":"                self.first_iter = true;"},
{"lineNum":"  619","line":"            }"},
{"lineNum":"  620","line":"        },"},
{"lineNum":"  621","line":"        .linux => struct {"},
{"lineNum":"  622","line":"            dir: Dir,"},
{"lineNum":"  623","line":"            // The if guard is solely there to prevent compile errors from missing `linux.dirent64`"},
{"lineNum":"  624","line":"            // definition when compiling for other OSes. It doesn\'t do anything when compiling for Linux."},
{"lineNum":"  625","line":"            buf: [1024]u8 align(if (builtin.os.tag != .linux) 1 else @alignOf(linux.dirent64)),"},
{"lineNum":"  626","line":"            index: usize,"},
{"lineNum":"  627","line":"            end_index: usize,"},
{"lineNum":"  628","line":"            first_iter: bool,"},
{"lineNum":"  629","line":""},
{"lineNum":"  630","line":"            const Self = @This();"},
{"lineNum":"  631","line":"            const linux = os.linux;"},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"            pub const Error = IteratorError;"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"            /// Memory such as file names referenced in this returned entry becomes invalid"},
{"lineNum":"  636","line":"            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized."},
{"lineNum":"  637","line":"            pub fn next(self: *Self) Error!?Entry {"},
{"lineNum":"  638","line":"                return self.nextLinux() catch |err| switch (err) {"},
{"lineNum":"  639","line":"                    // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration."},
{"lineNum":"  640","line":"                    // This matches the behavior of non-Linux UNIX platforms."},
{"lineNum":"  641","line":"                    error.DirNotFound => null,"},
{"lineNum":"  642","line":"                    else => |e| return e,"},
{"lineNum":"  643","line":"                };"},
{"lineNum":"  644","line":"            }"},
{"lineNum":"  645","line":""},
{"lineNum":"  646","line":"            pub const ErrorLinux = error{DirNotFound} || IteratorError;"},
{"lineNum":"  647","line":""},
{"lineNum":"  648","line":"            /// Implementation of `next` that can return `error.DirNotFound` if the directory being"},
{"lineNum":"  649","line":"            /// iterated was deleted during iteration (this error is Linux specific)."},
{"lineNum":"  650","line":"            pub fn nextLinux(self: *Self) ErrorLinux!?Entry {"},
{"lineNum":"  651","line":"                start_over: while (true) {"},
{"lineNum":"  652","line":"                    if (self.index >= self.end_index) {"},
{"lineNum":"  653","line":"                        if (self.first_iter) {"},
{"lineNum":"  654","line":"                            std.os.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions"},
{"lineNum":"  655","line":"                            self.first_iter = false;"},
{"lineNum":"  656","line":"                        }"},
{"lineNum":"  657","line":"                        const rc = linux.getdents64(self.dir.fd, &self.buf, self.buf.len);"},
{"lineNum":"  658","line":"                        switch (linux.getErrno(rc)) {"},
{"lineNum":"  659","line":"                            .SUCCESS => {},"},
{"lineNum":"  660","line":"                            .BADF => unreachable, // Dir is invalid or was opened without iteration ability"},
{"lineNum":"  661","line":"                            .FAULT => unreachable,"},
{"lineNum":"  662","line":"                            .NOTDIR => unreachable,"},
{"lineNum":"  663","line":"                            .NOENT => return error.DirNotFound, // The directory being iterated was deleted during iteration."},
{"lineNum":"  664","line":"                            .INVAL => return error.Unexpected, // Linux may in some cases return EINVAL when reading /proc/$PID/net."},
{"lineNum":"  665","line":"                            else => |err| return os.unexpectedErrno(err),"},
{"lineNum":"  666","line":"                        }"},
{"lineNum":"  667","line":"                        if (rc == 0) return null;"},
{"lineNum":"  668","line":"                        self.index = 0;"},
{"lineNum":"  669","line":"                        self.end_index = rc;"},
{"lineNum":"  670","line":"                    }"},
{"lineNum":"  671","line":"                    const linux_entry = @ptrCast(*align(1) linux.dirent64, &self.buf[self.index]);"},
{"lineNum":"  672","line":"                    const next_index = self.index + linux_entry.reclen();"},
{"lineNum":"  673","line":"                    self.index = next_index;"},
{"lineNum":"  674","line":""},
{"lineNum":"  675","line":"                    const name = mem.sliceTo(@ptrCast([*:0]u8, &linux_entry.d_name), 0);"},
{"lineNum":"  676","line":""},
{"lineNum":"  677","line":"                    // skip . and .. entries"},
{"lineNum":"  678","line":"                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\")) {"},
{"lineNum":"  679","line":"                        continue :start_over;"},
{"lineNum":"  680","line":"                    }"},
{"lineNum":"  681","line":""},
{"lineNum":"  682","line":"                    const entry_kind = switch (linux_entry.d_type) {"},
{"lineNum":"  683","line":"                        linux.DT.BLK => Entry.Kind.BlockDevice,"},
{"lineNum":"  684","line":"                        linux.DT.CHR => Entry.Kind.CharacterDevice,"},
{"lineNum":"  685","line":"                        linux.DT.DIR => Entry.Kind.Directory,"},
{"lineNum":"  686","line":"                        linux.DT.FIFO => Entry.Kind.NamedPipe,"},
{"lineNum":"  687","line":"                        linux.DT.LNK => Entry.Kind.SymLink,"},
{"lineNum":"  688","line":"                        linux.DT.REG => Entry.Kind.File,"},
{"lineNum":"  689","line":"                        linux.DT.SOCK => Entry.Kind.UnixDomainSocket,"},
{"lineNum":"  690","line":"                        else => Entry.Kind.Unknown,"},
{"lineNum":"  691","line":"                    };"},
{"lineNum":"  692","line":"                    return Entry{"},
{"lineNum":"  693","line":"                        .name = name,"},
{"lineNum":"  694","line":"                        .kind = entry_kind,"},
{"lineNum":"  695","line":"                    };"},
{"lineNum":"  696","line":"                }"},
{"lineNum":"  697","line":"            }"},
{"lineNum":"  698","line":""},
{"lineNum":"  699","line":"            pub fn reset(self: *Self) void {"},
{"lineNum":"  700","line":"                self.index = 0;"},
{"lineNum":"  701","line":"                self.end_index = 0;"},
{"lineNum":"  702","line":"                self.first_iter = true;"},
{"lineNum":"  703","line":"            }"},
{"lineNum":"  704","line":"        },"},
{"lineNum":"  705","line":"        .windows => struct {"},
{"lineNum":"  706","line":"            dir: Dir,"},
{"lineNum":"  707","line":"            buf: [1024]u8 align(@alignOf(os.windows.FILE_BOTH_DIR_INFORMATION)),"},
{"lineNum":"  708","line":"            index: usize,"},
{"lineNum":"  709","line":"            end_index: usize,"},
{"lineNum":"  710","line":"            first_iter: bool,"},
{"lineNum":"  711","line":"            name_data: [MAX_NAME_BYTES]u8,"},
{"lineNum":"  712","line":""},
{"lineNum":"  713","line":"            const Self = @This();"},
{"lineNum":"  714","line":""},
{"lineNum":"  715","line":"            pub const Error = IteratorError;"},
{"lineNum":"  716","line":""},
{"lineNum":"  717","line":"            /// Memory such as file names referenced in this returned entry becomes invalid"},
{"lineNum":"  718","line":"            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized."},
{"lineNum":"  719","line":"            pub fn next(self: *Self) Error!?Entry {"},
{"lineNum":"  720","line":"                while (true) {"},
{"lineNum":"  721","line":"                    const w = os.windows;"},
{"lineNum":"  722","line":"                    if (self.index >= self.end_index) {"},
{"lineNum":"  723","line":"                        var io: w.IO_STATUS_BLOCK = undefined;"},
{"lineNum":"  724","line":"                        const rc = w.ntdll.NtQueryDirectoryFile("},
{"lineNum":"  725","line":"                            self.dir.fd,"},
{"lineNum":"  726","line":"                            null,"},
{"lineNum":"  727","line":"                            null,"},
{"lineNum":"  728","line":"                            null,"},
{"lineNum":"  729","line":"                            &io,"},
{"lineNum":"  730","line":"                            &self.buf,"},
{"lineNum":"  731","line":"                            self.buf.len,"},
{"lineNum":"  732","line":"                            .FileBothDirectoryInformation,"},
{"lineNum":"  733","line":"                            w.FALSE,"},
{"lineNum":"  734","line":"                            null,"},
{"lineNum":"  735","line":"                            if (self.first_iter) @as(w.BOOLEAN, w.TRUE) else @as(w.BOOLEAN, w.FALSE),"},
{"lineNum":"  736","line":"                        );"},
{"lineNum":"  737","line":"                        self.first_iter = false;"},
{"lineNum":"  738","line":"                        if (io.Information == 0) return null;"},
{"lineNum":"  739","line":"                        self.index = 0;"},
{"lineNum":"  740","line":"                        self.end_index = io.Information;"},
{"lineNum":"  741","line":"                        switch (rc) {"},
{"lineNum":"  742","line":"                            .SUCCESS => {},"},
{"lineNum":"  743","line":"                            .ACCESS_DENIED => return error.AccessDenied, // Double-check that the Dir was opened with iteration ability"},
{"lineNum":"  744","line":""},
{"lineNum":"  745","line":"                            else => return w.unexpectedStatus(rc),"},
{"lineNum":"  746","line":"                        }"},
{"lineNum":"  747","line":"                    }"},
{"lineNum":"  748","line":""},
{"lineNum":"  749","line":"                    const aligned_ptr = @alignCast(@alignOf(w.FILE_BOTH_DIR_INFORMATION), &self.buf[self.index]);"},
{"lineNum":"  750","line":"                    const dir_info = @ptrCast(*w.FILE_BOTH_DIR_INFORMATION, aligned_ptr);"},
{"lineNum":"  751","line":"                    if (dir_info.NextEntryOffset != 0) {"},
{"lineNum":"  752","line":"                        self.index += dir_info.NextEntryOffset;"},
{"lineNum":"  753","line":"                    } else {"},
{"lineNum":"  754","line":"                        self.index = self.buf.len;"},
{"lineNum":"  755","line":"                    }"},
{"lineNum":"  756","line":""},
{"lineNum":"  757","line":"                    const name_utf16le = @ptrCast([*]u16, &dir_info.FileName)[0 .. dir_info.FileNameLength / 2];"},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":"                    if (mem.eql(u16, name_utf16le, &[_]u16{\'.\'}) or mem.eql(u16, name_utf16le, &[_]u16{ \'.\', \'.\' }))"},
{"lineNum":"  760","line":"                        continue;"},
{"lineNum":"  761","line":"                    // Trust that Windows gives us valid UTF-16LE"},
{"lineNum":"  762","line":"                    const name_utf8_len = std.unicode.utf16leToUtf8(self.name_data[0..], name_utf16le) catch unreachable;"},
{"lineNum":"  763","line":"                    const name_utf8 = self.name_data[0..name_utf8_len];"},
{"lineNum":"  764","line":"                    const kind = blk: {"},
{"lineNum":"  765","line":"                        const attrs = dir_info.FileAttributes;"},
{"lineNum":"  766","line":"                        if (attrs & w.FILE_ATTRIBUTE_DIRECTORY != 0) break :blk Entry.Kind.Directory;"},
{"lineNum":"  767","line":"                        if (attrs & w.FILE_ATTRIBUTE_REPARSE_POINT != 0) break :blk Entry.Kind.SymLink;"},
{"lineNum":"  768","line":"                        break :blk Entry.Kind.File;"},
{"lineNum":"  769","line":"                    };"},
{"lineNum":"  770","line":"                    return Entry{"},
{"lineNum":"  771","line":"                        .name = name_utf8,"},
{"lineNum":"  772","line":"                        .kind = kind,"},
{"lineNum":"  773","line":"                    };"},
{"lineNum":"  774","line":"                }"},
{"lineNum":"  775","line":"            }"},
{"lineNum":"  776","line":""},
{"lineNum":"  777","line":"            pub fn reset(self: *Self) void {"},
{"lineNum":"  778","line":"                self.index = 0;"},
{"lineNum":"  779","line":"                self.end_index = 0;"},
{"lineNum":"  780","line":"                self.first_iter = true;"},
{"lineNum":"  781","line":"            }"},
{"lineNum":"  782","line":"        },"},
{"lineNum":"  783","line":"        .wasi => struct {"},
{"lineNum":"  784","line":"            dir: Dir,"},
{"lineNum":"  785","line":"            buf: [1024]u8, // TODO align(@alignOf(os.wasi.dirent_t)),"},
{"lineNum":"  786","line":"            cookie: u64,"},
{"lineNum":"  787","line":"            index: usize,"},
{"lineNum":"  788","line":"            end_index: usize,"},
{"lineNum":"  789","line":""},
{"lineNum":"  790","line":"            const Self = @This();"},
{"lineNum":"  791","line":""},
{"lineNum":"  792","line":"            pub const Error = IteratorError;"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":"            /// Memory such as file names referenced in this returned entry becomes invalid"},
{"lineNum":"  795","line":"            /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized."},
{"lineNum":"  796","line":"            pub fn next(self: *Self) Error!?Entry {"},
{"lineNum":"  797","line":"                return self.nextWasi() catch |err| switch (err) {"},
{"lineNum":"  798","line":"                    // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration."},
{"lineNum":"  799","line":"                    // This matches the behavior of non-Linux UNIX platforms."},
{"lineNum":"  800","line":"                    error.DirNotFound => null,"},
{"lineNum":"  801","line":"                    else => |e| return e,"},
{"lineNum":"  802","line":"                };"},
{"lineNum":"  803","line":"            }"},
{"lineNum":"  804","line":""},
{"lineNum":"  805","line":"            pub const ErrorWasi = error{DirNotFound} || IteratorError;"},
{"lineNum":"  806","line":""},
{"lineNum":"  807","line":"            /// Implementation of `next` that can return platform-dependent errors depending on the host platform."},
{"lineNum":"  808","line":"            /// When the host platform is Linux, `error.DirNotFound` can be returned if the directory being"},
{"lineNum":"  809","line":"            /// iterated was deleted during iteration."},
{"lineNum":"  810","line":"            pub fn nextWasi(self: *Self) ErrorWasi!?Entry {"},
{"lineNum":"  811","line":"                // We intentinally use fd_readdir even when linked with libc,"},
{"lineNum":"  812","line":"                // since its implementation is exactly the same as below,"},
{"lineNum":"  813","line":"                // and we avoid the code complexity here."},
{"lineNum":"  814","line":"                const w = os.wasi;"},
{"lineNum":"  815","line":"                start_over: while (true) {"},
{"lineNum":"  816","line":"                    // According to the WASI spec, the last entry might be truncated,"},
{"lineNum":"  817","line":"                    // so we need to check if the left buffer contains the whole dirent."},
{"lineNum":"  818","line":"                    if (self.end_index - self.index < @sizeOf(w.dirent_t)) {"},
{"lineNum":"  819","line":"                        var bufused: usize = undefined;"},
{"lineNum":"  820","line":"                        switch (w.fd_readdir(self.dir.fd, &self.buf, self.buf.len, self.cookie, &bufused)) {"},
{"lineNum":"  821","line":"                            .SUCCESS => {},"},
{"lineNum":"  822","line":"                            .BADF => unreachable, // Dir is invalid or was opened without iteration ability"},
{"lineNum":"  823","line":"                            .FAULT => unreachable,"},
{"lineNum":"  824","line":"                            .NOTDIR => unreachable,"},
{"lineNum":"  825","line":"                            .INVAL => unreachable,"},
{"lineNum":"  826","line":"                            .NOENT => return error.DirNotFound, // The directory being iterated was deleted during iteration."},
{"lineNum":"  827","line":"                            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":"  828","line":"                            else => |err| return os.unexpectedErrno(err),"},
{"lineNum":"  829","line":"                        }"},
{"lineNum":"  830","line":"                        if (bufused == 0) return null;"},
{"lineNum":"  831","line":"                        self.index = 0;"},
{"lineNum":"  832","line":"                        self.end_index = bufused;"},
{"lineNum":"  833","line":"                    }"},
{"lineNum":"  834","line":"                    const entry = @ptrCast(*align(1) w.dirent_t, &self.buf[self.index]);"},
{"lineNum":"  835","line":"                    const entry_size = @sizeOf(w.dirent_t);"},
{"lineNum":"  836","line":"                    const name_index = self.index + entry_size;"},
{"lineNum":"  837","line":"                    if (name_index + entry.d_namlen > self.end_index) {"},
{"lineNum":"  838","line":"                        // This case, the name is truncated, so we need to call readdir to store the entire name."},
{"lineNum":"  839","line":"                        self.end_index = self.index; // Force fd_readdir in the next loop."},
{"lineNum":"  840","line":"                        continue :start_over;"},
{"lineNum":"  841","line":"                    }"},
{"lineNum":"  842","line":"                    const name = self.buf[name_index .. name_index + entry.d_namlen];"},
{"lineNum":"  843","line":""},
{"lineNum":"  844","line":"                    const next_index = name_index + entry.d_namlen;"},
{"lineNum":"  845","line":"                    self.index = next_index;"},
{"lineNum":"  846","line":"                    self.cookie = entry.d_next;"},
{"lineNum":"  847","line":""},
{"lineNum":"  848","line":"                    // skip . and .. entries"},
{"lineNum":"  849","line":"                    if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\")) {"},
{"lineNum":"  850","line":"                        continue :start_over;"},
{"lineNum":"  851","line":"                    }"},
{"lineNum":"  852","line":""},
{"lineNum":"  853","line":"                    const entry_kind = switch (entry.d_type) {"},
{"lineNum":"  854","line":"                        .BLOCK_DEVICE => Entry.Kind.BlockDevice,"},
{"lineNum":"  855","line":"                        .CHARACTER_DEVICE => Entry.Kind.CharacterDevice,"},
{"lineNum":"  856","line":"                        .DIRECTORY => Entry.Kind.Directory,"},
{"lineNum":"  857","line":"                        .SYMBOLIC_LINK => Entry.Kind.SymLink,"},
{"lineNum":"  858","line":"                        .REGULAR_FILE => Entry.Kind.File,"},
{"lineNum":"  859","line":"                        .SOCKET_STREAM, .SOCKET_DGRAM => Entry.Kind.UnixDomainSocket,"},
{"lineNum":"  860","line":"                        else => Entry.Kind.Unknown,"},
{"lineNum":"  861","line":"                    };"},
{"lineNum":"  862","line":"                    return Entry{"},
{"lineNum":"  863","line":"                        .name = name,"},
{"lineNum":"  864","line":"                        .kind = entry_kind,"},
{"lineNum":"  865","line":"                    };"},
{"lineNum":"  866","line":"                }"},
{"lineNum":"  867","line":"            }"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"            pub fn reset(self: *Self) void {"},
{"lineNum":"  870","line":"                self.index = 0;"},
{"lineNum":"  871","line":"                self.end_index = 0;"},
{"lineNum":"  872","line":"                self.cookie = os.wasi.DIRCOOKIE_START;"},
{"lineNum":"  873","line":"            }"},
{"lineNum":"  874","line":"        },"},
{"lineNum":"  875","line":"        else => @compileError(\"unimplemented\"),"},
{"lineNum":"  876","line":"    };"},
{"lineNum":"  877","line":""},
{"lineNum":"  878","line":"    pub fn iterate(self: IterableDir) Iterator {"},
{"lineNum":"  879","line":"        return self.iterateImpl(true);"},
{"lineNum":"  880","line":"    }"},
{"lineNum":"  881","line":""},
{"lineNum":"  882","line":"    /// Like `iterate`, but will not reset the directory cursor before the first"},
{"lineNum":"  883","line":"    /// iteration. This should only be used in cases where it is known that the"},
{"lineNum":"  884","line":"    /// `IterableDir` has not had its cursor modified yet (e.g. it was just opened)."},
{"lineNum":"  885","line":"    pub fn iterateAssumeFirstIteration(self: IterableDir) Iterator {"},
{"lineNum":"  886","line":"        return self.iterateImpl(false);"},
{"lineNum":"  887","line":"    }"},
{"lineNum":"  888","line":""},
{"lineNum":"  889","line":"    fn iterateImpl(self: IterableDir, first_iter_start_value: bool) Iterator {"},
{"lineNum":"  890","line":"        switch (builtin.os.tag) {"},
{"lineNum":"  891","line":"            .macos,"},
{"lineNum":"  892","line":"            .ios,"},
{"lineNum":"  893","line":"            .freebsd,"},
{"lineNum":"  894","line":"            .netbsd,"},
{"lineNum":"  895","line":"            .dragonfly,"},
{"lineNum":"  896","line":"            .openbsd,"},
{"lineNum":"  897","line":"            .solaris,"},
{"lineNum":"  898","line":"            => return Iterator{"},
{"lineNum":"  899","line":"                .dir = self.dir,"},
{"lineNum":"  900","line":"                .seek = 0,"},
{"lineNum":"  901","line":"                .index = 0,"},
{"lineNum":"  902","line":"                .end_index = 0,"},
{"lineNum":"  903","line":"                .buf = undefined,"},
{"lineNum":"  904","line":"                .first_iter = first_iter_start_value,"},
{"lineNum":"  905","line":"            },"},
{"lineNum":"  906","line":"            .linux, .haiku => return Iterator{"},
{"lineNum":"  907","line":"                .dir = self.dir,"},
{"lineNum":"  908","line":"                .index = 0,"},
{"lineNum":"  909","line":"                .end_index = 0,"},
{"lineNum":"  910","line":"                .buf = undefined,"},
{"lineNum":"  911","line":"                .first_iter = first_iter_start_value,"},
{"lineNum":"  912","line":"            },"},
{"lineNum":"  913","line":"            .windows => return Iterator{"},
{"lineNum":"  914","line":"                .dir = self.dir,"},
{"lineNum":"  915","line":"                .index = 0,"},
{"lineNum":"  916","line":"                .end_index = 0,"},
{"lineNum":"  917","line":"                .first_iter = first_iter_start_value,"},
{"lineNum":"  918","line":"                .buf = undefined,"},
{"lineNum":"  919","line":"                .name_data = undefined,"},
{"lineNum":"  920","line":"            },"},
{"lineNum":"  921","line":"            .wasi => return Iterator{"},
{"lineNum":"  922","line":"                .dir = self.dir,"},
{"lineNum":"  923","line":"                .cookie = os.wasi.DIRCOOKIE_START,"},
{"lineNum":"  924","line":"                .index = 0,"},
{"lineNum":"  925","line":"                .end_index = 0,"},
{"lineNum":"  926","line":"                .buf = undefined,"},
{"lineNum":"  927","line":"            },"},
{"lineNum":"  928","line":"            else => @compileError(\"unimplemented\"),"},
{"lineNum":"  929","line":"        }"},
{"lineNum":"  930","line":"    }"},
{"lineNum":"  931","line":""},
{"lineNum":"  932","line":"    pub const Walker = struct {"},
{"lineNum":"  933","line":"        stack: std.ArrayList(StackItem),"},
{"lineNum":"  934","line":"        name_buffer: std.ArrayList(u8),"},
{"lineNum":"  935","line":""},
{"lineNum":"  936","line":"        pub const WalkerEntry = struct {"},
{"lineNum":"  937","line":"            /// The containing directory. This can be used to operate directly on `basename`"},
{"lineNum":"  938","line":"            /// rather than `path`, avoiding `error.NameTooLong` for deeply nested paths."},
{"lineNum":"  939","line":"            /// The directory remains open until `next` or `deinit` is called."},
{"lineNum":"  940","line":"            dir: Dir,"},
{"lineNum":"  941","line":"            basename: []const u8,"},
{"lineNum":"  942","line":"            path: []const u8,"},
{"lineNum":"  943","line":"            kind: IterableDir.Entry.Kind,"},
{"lineNum":"  944","line":"        };"},
{"lineNum":"  945","line":""},
{"lineNum":"  946","line":"        const StackItem = struct {"},
{"lineNum":"  947","line":"            iter: IterableDir.Iterator,"},
{"lineNum":"  948","line":"            dirname_len: usize,"},
{"lineNum":"  949","line":"        };"},
{"lineNum":"  950","line":""},
{"lineNum":"  951","line":"        /// After each call to this function, and on deinit(), the memory returned"},
{"lineNum":"  952","line":"        /// from this function becomes invalid. A copy must be made in order to keep"},
{"lineNum":"  953","line":"        /// a reference to the path."},
{"lineNum":"  954","line":"        pub fn next(self: *Walker) !?WalkerEntry {"},
{"lineNum":"  955","line":"            while (self.stack.items.len != 0) {"},
{"lineNum":"  956","line":"                // `top` and `containing` become invalid after appending to `self.stack`"},
{"lineNum":"  957","line":"                var top = &self.stack.items[self.stack.items.len - 1];"},
{"lineNum":"  958","line":"                var containing = top;"},
{"lineNum":"  959","line":"                var dirname_len = top.dirname_len;"},
{"lineNum":"  960","line":"                if (try top.iter.next()) |base| {"},
{"lineNum":"  961","line":"                    self.name_buffer.shrinkRetainingCapacity(dirname_len);"},
{"lineNum":"  962","line":"                    if (self.name_buffer.items.len != 0) {"},
{"lineNum":"  963","line":"                        try self.name_buffer.append(path.sep);"},
{"lineNum":"  964","line":"                        dirname_len += 1;"},
{"lineNum":"  965","line":"                    }"},
{"lineNum":"  966","line":"                    try self.name_buffer.appendSlice(base.name);"},
{"lineNum":"  967","line":"                    if (base.kind == .Directory) {"},
{"lineNum":"  968","line":"                        var new_dir = top.iter.dir.openIterableDir(base.name, .{}) catch |err| switch (err) {"},
{"lineNum":"  969","line":"                            error.NameTooLong => unreachable, // no path sep in base.name"},
{"lineNum":"  970","line":"                            else => |e| return e,"},
{"lineNum":"  971","line":"                        };"},
{"lineNum":"  972","line":"                        {"},
{"lineNum":"  973","line":"                            errdefer new_dir.close();"},
{"lineNum":"  974","line":"                            try self.stack.append(StackItem{"},
{"lineNum":"  975","line":"                                .iter = new_dir.iterate(),"},
{"lineNum":"  976","line":"                                .dirname_len = self.name_buffer.items.len,"},
{"lineNum":"  977","line":"                            });"},
{"lineNum":"  978","line":"                            top = &self.stack.items[self.stack.items.len - 1];"},
{"lineNum":"  979","line":"                            containing = &self.stack.items[self.stack.items.len - 2];"},
{"lineNum":"  980","line":"                        }"},
{"lineNum":"  981","line":"                    }"},
{"lineNum":"  982","line":"                    return WalkerEntry{"},
{"lineNum":"  983","line":"                        .dir = containing.iter.dir,"},
{"lineNum":"  984","line":"                        .basename = self.name_buffer.items[dirname_len..],"},
{"lineNum":"  985","line":"                        .path = self.name_buffer.items,"},
{"lineNum":"  986","line":"                        .kind = base.kind,"},
{"lineNum":"  987","line":"                    };"},
{"lineNum":"  988","line":"                } else {"},
{"lineNum":"  989","line":"                    var item = self.stack.pop();"},
{"lineNum":"  990","line":"                    if (self.stack.items.len != 0) {"},
{"lineNum":"  991","line":"                        item.iter.dir.close();"},
{"lineNum":"  992","line":"                    }"},
{"lineNum":"  993","line":"                }"},
{"lineNum":"  994","line":"            }"},
{"lineNum":"  995","line":"            return null;"},
{"lineNum":"  996","line":"        }"},
{"lineNum":"  997","line":""},
{"lineNum":"  998","line":"        pub fn deinit(self: *Walker) void {"},
{"lineNum":"  999","line":"            // Close any remaining directories except the initial one (which is always at index 0)"},
{"lineNum":" 1000","line":"            if (self.stack.items.len > 1) {"},
{"lineNum":" 1001","line":"                for (self.stack.items[1..]) |*item| {"},
{"lineNum":" 1002","line":"                    item.iter.dir.close();"},
{"lineNum":" 1003","line":"                }"},
{"lineNum":" 1004","line":"            }"},
{"lineNum":" 1005","line":"            self.stack.deinit();"},
{"lineNum":" 1006","line":"            self.name_buffer.deinit();"},
{"lineNum":" 1007","line":"        }"},
{"lineNum":" 1008","line":"    };"},
{"lineNum":" 1009","line":""},
{"lineNum":" 1010","line":"    /// Recursively iterates over a directory."},
{"lineNum":" 1011","line":"    /// Must call `Walker.deinit` when done."},
{"lineNum":" 1012","line":"    /// The order of returned file system entries is undefined."},
{"lineNum":" 1013","line":"    /// `self` will not be closed after walking it."},
{"lineNum":" 1014","line":"    pub fn walk(self: IterableDir, allocator: Allocator) !Walker {"},
{"lineNum":" 1015","line":"        var name_buffer = std.ArrayList(u8).init(allocator);"},
{"lineNum":" 1016","line":"        errdefer name_buffer.deinit();"},
{"lineNum":" 1017","line":""},
{"lineNum":" 1018","line":"        var stack = std.ArrayList(Walker.StackItem).init(allocator);"},
{"lineNum":" 1019","line":"        errdefer stack.deinit();"},
{"lineNum":" 1020","line":""},
{"lineNum":" 1021","line":"        try stack.append(Walker.StackItem{"},
{"lineNum":" 1022","line":"            .iter = self.iterate(),"},
{"lineNum":" 1023","line":"            .dirname_len = 0,"},
{"lineNum":" 1024","line":"        });"},
{"lineNum":" 1025","line":""},
{"lineNum":" 1026","line":"        return Walker{"},
{"lineNum":" 1027","line":"            .stack = stack,"},
{"lineNum":" 1028","line":"            .name_buffer = name_buffer,"},
{"lineNum":" 1029","line":"        };"},
{"lineNum":" 1030","line":"    }"},
{"lineNum":" 1031","line":""},
{"lineNum":" 1032","line":"    pub fn close(self: *IterableDir) void {"},
{"lineNum":" 1033","line":"        self.dir.close();"},
{"lineNum":" 1034","line":"        self.* = undefined;"},
{"lineNum":" 1035","line":"    }"},
{"lineNum":" 1036","line":""},
{"lineNum":" 1037","line":"    pub const ChmodError = File.ChmodError;"},
{"lineNum":" 1038","line":""},
{"lineNum":" 1039","line":"    /// Changes the mode of the directory."},
{"lineNum":" 1040","line":"    /// The process must have the correct privileges in order to do this"},
{"lineNum":" 1041","line":"    /// successfully, or must have the effective user ID matching the owner"},
{"lineNum":" 1042","line":"    /// of the directory."},
{"lineNum":" 1043","line":"    pub fn chmod(self: IterableDir, new_mode: File.Mode) ChmodError!void {"},
{"lineNum":" 1044","line":"        const file: File = .{"},
{"lineNum":" 1045","line":"            .handle = self.dir.fd,"},
{"lineNum":" 1046","line":"            .capable_io_mode = .blocking,"},
{"lineNum":" 1047","line":"        };"},
{"lineNum":" 1048","line":"        try file.chmod(new_mode);"},
{"lineNum":" 1049","line":"    }"},
{"lineNum":" 1050","line":""},
{"lineNum":" 1051","line":"    /// Changes the owner and group of the directory."},
{"lineNum":" 1052","line":"    /// The process must have the correct privileges in order to do this"},
{"lineNum":" 1053","line":"    /// successfully. The group may be changed by the owner of the directory to"},
{"lineNum":" 1054","line":"    /// any group of which the owner is a member. If the"},
{"lineNum":" 1055","line":"    /// owner or group is specified as `null`, the ID is not changed."},
{"lineNum":" 1056","line":"    pub fn chown(self: IterableDir, owner: ?File.Uid, group: ?File.Gid) ChownError!void {"},
{"lineNum":" 1057","line":"        const file: File = .{"},
{"lineNum":" 1058","line":"            .handle = self.dir.fd,"},
{"lineNum":" 1059","line":"            .capable_io_mode = .blocking,"},
{"lineNum":" 1060","line":"        };"},
{"lineNum":" 1061","line":"        try file.chown(owner, group);"},
{"lineNum":" 1062","line":"    }"},
{"lineNum":" 1063","line":""},
{"lineNum":" 1064","line":"    pub const ChownError = File.ChownError;"},
{"lineNum":" 1065","line":"};"},
{"lineNum":" 1066","line":""},
{"lineNum":" 1067","line":"pub const Dir = struct {"},
{"lineNum":" 1068","line":"    fd: os.fd_t,"},
{"lineNum":" 1069","line":""},
{"lineNum":" 1070","line":"    pub const iterate = @compileError(\"only \'IterableDir\' can be iterated; \'IterableDir\' can be obtained with \'openIterableDir\'\");"},
{"lineNum":" 1071","line":"    pub const walk = @compileError(\"only \'IterableDir\' can be walked; \'IterableDir\' can be obtained with \'openIterableDir\'\");"},
{"lineNum":" 1072","line":"    pub const chmod = @compileError(\"only \'IterableDir\' can have its mode changed; \'IterableDir\' can be obtained with \'openIterableDir\'\");"},
{"lineNum":" 1073","line":"    pub const chown = @compileError(\"only \'IterableDir\' can have its owner changed; \'IterableDir\' can be obtained with \'openIterableDir\'\");"},
{"lineNum":" 1074","line":""},
{"lineNum":" 1075","line":"    pub const OpenError = error{"},
{"lineNum":" 1076","line":"        FileNotFound,"},
{"lineNum":" 1077","line":"        NotDir,"},
{"lineNum":" 1078","line":"        InvalidHandle,"},
{"lineNum":" 1079","line":"        AccessDenied,"},
{"lineNum":" 1080","line":"        SymLinkLoop,"},
{"lineNum":" 1081","line":"        ProcessFdQuotaExceeded,"},
{"lineNum":" 1082","line":"        NameTooLong,"},
{"lineNum":" 1083","line":"        SystemFdQuotaExceeded,"},
{"lineNum":" 1084","line":"        NoDevice,"},
{"lineNum":" 1085","line":"        SystemResources,"},
{"lineNum":" 1086","line":"        InvalidUtf8,"},
{"lineNum":" 1087","line":"        BadPathName,"},
{"lineNum":" 1088","line":"        DeviceBusy,"},
{"lineNum":" 1089","line":"    } || os.UnexpectedError;"},
{"lineNum":" 1090","line":""},
{"lineNum":" 1091","line":"    pub fn close(self: *Dir) void {"},
{"lineNum":" 1092","line":"        if (need_async_thread) {"},
{"lineNum":" 1093","line":"            std.event.Loop.instance.?.close(self.fd);"},
{"lineNum":" 1094","line":"        } else {"},
{"lineNum":" 1095","line":"            os.close(self.fd);"},
{"lineNum":" 1096","line":"        }"},
{"lineNum":" 1097","line":"        self.* = undefined;"},
{"lineNum":" 1098","line":"    }"},
{"lineNum":" 1099","line":""},
{"lineNum":" 1100","line":"    /// Opens a file for reading or writing, without attempting to create a new file."},
{"lineNum":" 1101","line":"    /// To create a new file, see `createFile`."},
{"lineNum":" 1102","line":"    /// Call `File.close` to release the resource."},
{"lineNum":" 1103","line":"    /// Asserts that the path parameter has no null bytes."},
{"lineNum":" 1104","line":"    pub fn openFile(self: Dir, sub_path: []const u8, flags: File.OpenFlags) File.OpenError!File {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1105","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1106","line":"            const path_w = try os.windows.sliceToPrefixedFileW(sub_path);"},
{"lineNum":" 1107","line":"            return self.openFileW(path_w.span(), flags);"},
{"lineNum":" 1108","line":"        }"},
{"lineNum":" 1109","line":"        if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1110","line":"            return self.openFileWasi(sub_path, flags);"},
{"lineNum":" 1111","line":"        }"},
{"lineNum":" 1112","line":"        const path_c = try os.toPosixPath(sub_path);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1113","line":"        return self.openFileZ(&path_c, flags);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1114","line":"    }"},
{"lineNum":" 1115","line":""},
{"lineNum":" 1116","line":"    /// Same as `openFile` but WASI only."},
{"lineNum":" 1117","line":"    pub fn openFileWasi(self: Dir, sub_path: []const u8, flags: File.OpenFlags) File.OpenError!File {"},
{"lineNum":" 1118","line":"        const w = os.wasi;"},
{"lineNum":" 1119","line":"        var fdflags: w.fdflags_t = 0x0;"},
{"lineNum":" 1120","line":"        var base: w.rights_t = 0x0;"},
{"lineNum":" 1121","line":"        if (flags.isRead()) {"},
{"lineNum":" 1122","line":"            base |= w.RIGHT.FD_READ | w.RIGHT.FD_TELL | w.RIGHT.FD_SEEK | w.RIGHT.FD_FILESTAT_GET;"},
{"lineNum":" 1123","line":"        }"},
{"lineNum":" 1124","line":"        if (flags.isWrite()) {"},
{"lineNum":" 1125","line":"            fdflags |= w.FDFLAG.APPEND;"},
{"lineNum":" 1126","line":"            base |= w.RIGHT.FD_WRITE |"},
{"lineNum":" 1127","line":"                w.RIGHT.FD_TELL |"},
{"lineNum":" 1128","line":"                w.RIGHT.FD_SEEK |"},
{"lineNum":" 1129","line":"                w.RIGHT.FD_DATASYNC |"},
{"lineNum":" 1130","line":"                w.RIGHT.FD_FDSTAT_SET_FLAGS |"},
{"lineNum":" 1131","line":"                w.RIGHT.FD_SYNC |"},
{"lineNum":" 1132","line":"                w.RIGHT.FD_ALLOCATE |"},
{"lineNum":" 1133","line":"                w.RIGHT.FD_ADVISE |"},
{"lineNum":" 1134","line":"                w.RIGHT.FD_FILESTAT_SET_TIMES |"},
{"lineNum":" 1135","line":"                w.RIGHT.FD_FILESTAT_SET_SIZE;"},
{"lineNum":" 1136","line":"        }"},
{"lineNum":" 1137","line":"        const fd = try os.openatWasi(self.fd, sub_path, 0x0, 0x0, fdflags, base, 0x0);"},
{"lineNum":" 1138","line":"        return File{ .handle = fd };"},
{"lineNum":" 1139","line":"    }"},
{"lineNum":" 1140","line":""},
{"lineNum":" 1141","line":"    /// Same as `openFile` but the path parameter is null-terminated."},
{"lineNum":" 1142","line":"    pub fn openFileZ(self: Dir, sub_path: [*:0]const u8, flags: File.OpenFlags) File.OpenError!File {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1143","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1144","line":"            const path_w = try os.windows.cStrToPrefixedFileW(sub_path);"},
{"lineNum":" 1145","line":"            return self.openFileW(path_w.span(), flags);"},
{"lineNum":" 1146","line":"        }"},
{"lineNum":" 1147","line":""},
{"lineNum":" 1148","line":"        var os_flags: u32 = os.O.CLOEXEC;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1149","line":"        // Use the O locking flags if the os supports them to acquire the lock"},
{"lineNum":" 1150","line":"        // atomically."},
{"lineNum":" 1151","line":"        const has_flock_open_flags = @hasDecl(os.O, \"EXLOCK\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1152","line":"        if (has_flock_open_flags) {"},
{"lineNum":" 1153","line":"            // Note that the O.NONBLOCK flag is removed after the openat() call"},
{"lineNum":" 1154","line":"            // is successful."},
{"lineNum":" 1155","line":"            const nonblocking_lock_flag: u32 = if (flags.lock_nonblocking)"},
{"lineNum":" 1156","line":"                os.O.NONBLOCK"},
{"lineNum":" 1157","line":"            else"},
{"lineNum":" 1158","line":"                0;"},
{"lineNum":" 1159","line":"            os_flags |= switch (flags.lock) {"},
{"lineNum":" 1160","line":"                .None => @as(u32, 0),"},
{"lineNum":" 1161","line":"                .Shared => os.O.SHLOCK | nonblocking_lock_flag,"},
{"lineNum":" 1162","line":"                .Exclusive => os.O.EXLOCK | nonblocking_lock_flag,"},
{"lineNum":" 1163","line":"            };"},
{"lineNum":" 1164","line":"        }"},
{"lineNum":" 1165","line":"        if (@hasDecl(os.O, \"LARGEFILE\")) {"},
{"lineNum":" 1166","line":"            os_flags |= os.O.LARGEFILE;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1167","line":"        }"},
{"lineNum":" 1168","line":"        if (!flags.allow_ctty) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1169","line":"            os_flags |= os.O.NOCTTY;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1170","line":"        }"},
{"lineNum":" 1171","line":"        os_flags |= switch (flags.mode) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1172","line":"            .read_only => @as(u32, os.O.RDONLY),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1173","line":"            .write_only => @as(u32, os.O.WRONLY),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1174","line":"            .read_write => @as(u32, os.O.RDWR),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1175","line":"        };"},
{"lineNum":" 1176","line":"        const fd = if (flags.intended_io_mode != .blocking)"},
{"lineNum":" 1177","line":"            try std.event.Loop.instance.?.openatZ(self.fd, sub_path, os_flags, 0)"},
{"lineNum":" 1178","line":"        else"},
{"lineNum":" 1179","line":"            try os.openatZ(self.fd, sub_path, os_flags, 0);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1180","line":"        errdefer os.close(fd);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1181","line":""},
{"lineNum":" 1182","line":"        // WASI doesn\'t have os.flock so we intetinally check OS prior to the inner if block"},
{"lineNum":" 1183","line":"        // since it is not compiltime-known and we need to avoid undefined symbol in Wasm."},
{"lineNum":" 1184","line":"        if (builtin.target.os.tag != .wasi) {"},
{"lineNum":" 1185","line":"            if (!has_flock_open_flags and flags.lock != .None) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1186","line":"                // TODO: integrate async I/O"},
{"lineNum":" 1187","line":"                const lock_nonblocking = if (flags.lock_nonblocking) os.LOCK.NB else @as(i32, 0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1188","line":"                try os.flock(fd, switch (flags.lock) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1189","line":"                    .None => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1190","line":"                    .Shared => os.LOCK.SH | lock_nonblocking,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1191","line":"                    .Exclusive => os.LOCK.EX | lock_nonblocking,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1192","line":"                });"},
{"lineNum":" 1193","line":"            }"},
{"lineNum":" 1194","line":"        }"},
{"lineNum":" 1195","line":""},
{"lineNum":" 1196","line":"        if (has_flock_open_flags and flags.lock_nonblocking) {"},
{"lineNum":" 1197","line":"            var fl_flags = os.fcntl(fd, os.F.GETFL, 0) catch |err| switch (err) {"},
{"lineNum":" 1198","line":"                error.FileBusy => unreachable,"},
{"lineNum":" 1199","line":"                error.Locked => unreachable,"},
{"lineNum":" 1200","line":"                error.PermissionDenied => unreachable,"},
{"lineNum":" 1201","line":"                error.DeadLock => unreachable,"},
{"lineNum":" 1202","line":"                error.LockedRegionLimitExceeded => unreachable,"},
{"lineNum":" 1203","line":"                else => |e| return e,"},
{"lineNum":" 1204","line":"            };"},
{"lineNum":" 1205","line":"            fl_flags &= ~@as(usize, os.O.NONBLOCK);"},
{"lineNum":" 1206","line":"            _ = os.fcntl(fd, os.F.SETFL, fl_flags) catch |err| switch (err) {"},
{"lineNum":" 1207","line":"                error.FileBusy => unreachable,"},
{"lineNum":" 1208","line":"                error.Locked => unreachable,"},
{"lineNum":" 1209","line":"                error.PermissionDenied => unreachable,"},
{"lineNum":" 1210","line":"                error.DeadLock => unreachable,"},
{"lineNum":" 1211","line":"                error.LockedRegionLimitExceeded => unreachable,"},
{"lineNum":" 1212","line":"                else => |e| return e,"},
{"lineNum":" 1213","line":"            };"},
{"lineNum":" 1214","line":"        }"},
{"lineNum":" 1215","line":""},
{"lineNum":" 1216","line":"        return File{","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1217","line":"            .handle = fd,"},
{"lineNum":" 1218","line":"            .capable_io_mode = .blocking,"},
{"lineNum":" 1219","line":"            .intended_io_mode = flags.intended_io_mode,"},
{"lineNum":" 1220","line":"        };"},
{"lineNum":" 1221","line":"    }"},
{"lineNum":" 1222","line":""},
{"lineNum":" 1223","line":"    /// Same as `openFile` but Windows-only and the path parameter is"},
{"lineNum":" 1224","line":"    /// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded."},
{"lineNum":" 1225","line":"    pub fn openFileW(self: Dir, sub_path_w: []const u16, flags: File.OpenFlags) File.OpenError!File {"},
{"lineNum":" 1226","line":"        const w = os.windows;"},
{"lineNum":" 1227","line":"        const file: File = .{"},
{"lineNum":" 1228","line":"            .handle = try w.OpenFile(sub_path_w, .{"},
{"lineNum":" 1229","line":"                .dir = self.fd,"},
{"lineNum":" 1230","line":"                .access_mask = w.SYNCHRONIZE |"},
{"lineNum":" 1231","line":"                    (if (flags.isRead()) @as(u32, w.GENERIC_READ) else 0) |"},
{"lineNum":" 1232","line":"                    (if (flags.isWrite()) @as(u32, w.GENERIC_WRITE) else 0),"},
{"lineNum":" 1233","line":"                .creation = w.FILE_OPEN,"},
{"lineNum":" 1234","line":"                .io_mode = flags.intended_io_mode,"},
{"lineNum":" 1235","line":"            }),"},
{"lineNum":" 1236","line":"            .capable_io_mode = std.io.default_mode,"},
{"lineNum":" 1237","line":"            .intended_io_mode = flags.intended_io_mode,"},
{"lineNum":" 1238","line":"        };"},
{"lineNum":" 1239","line":"        var io: w.IO_STATUS_BLOCK = undefined;"},
{"lineNum":" 1240","line":"        const range_off: w.LARGE_INTEGER = 0;"},
{"lineNum":" 1241","line":"        const range_len: w.LARGE_INTEGER = 1;"},
{"lineNum":" 1242","line":"        const exclusive = switch (flags.lock) {"},
{"lineNum":" 1243","line":"            .None => return file,"},
{"lineNum":" 1244","line":"            .Shared => false,"},
{"lineNum":" 1245","line":"            .Exclusive => true,"},
{"lineNum":" 1246","line":"        };"},
{"lineNum":" 1247","line":"        try w.LockFile("},
{"lineNum":" 1248","line":"            file.handle,"},
{"lineNum":" 1249","line":"            null,"},
{"lineNum":" 1250","line":"            null,"},
{"lineNum":" 1251","line":"            null,"},
{"lineNum":" 1252","line":"            &io,"},
{"lineNum":" 1253","line":"            &range_off,"},
{"lineNum":" 1254","line":"            &range_len,"},
{"lineNum":" 1255","line":"            null,"},
{"lineNum":" 1256","line":"            @boolToInt(flags.lock_nonblocking),"},
{"lineNum":" 1257","line":"            @boolToInt(exclusive),"},
{"lineNum":" 1258","line":"        );"},
{"lineNum":" 1259","line":"        return file;"},
{"lineNum":" 1260","line":"    }"},
{"lineNum":" 1261","line":""},
{"lineNum":" 1262","line":"    /// Creates, opens, or overwrites a file with write access."},
{"lineNum":" 1263","line":"    /// Call `File.close` on the result when done."},
{"lineNum":" 1264","line":"    /// Asserts that the path parameter has no null bytes."},
{"lineNum":" 1265","line":"    pub fn createFile(self: Dir, sub_path: []const u8, flags: File.CreateFlags) File.OpenError!File {"},
{"lineNum":" 1266","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1267","line":"            const path_w = try os.windows.sliceToPrefixedFileW(sub_path);"},
{"lineNum":" 1268","line":"            return self.createFileW(path_w.span(), flags);"},
{"lineNum":" 1269","line":"        }"},
{"lineNum":" 1270","line":"        if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1271","line":"            return self.createFileWasi(sub_path, flags);"},
{"lineNum":" 1272","line":"        }"},
{"lineNum":" 1273","line":"        const path_c = try os.toPosixPath(sub_path);"},
{"lineNum":" 1274","line":"        return self.createFileZ(&path_c, flags);"},
{"lineNum":" 1275","line":"    }"},
{"lineNum":" 1276","line":""},
{"lineNum":" 1277","line":"    /// Same as `createFile` but WASI only."},
{"lineNum":" 1278","line":"    pub fn createFileWasi(self: Dir, sub_path: []const u8, flags: File.CreateFlags) File.OpenError!File {"},
{"lineNum":" 1279","line":"        const w = os.wasi;"},
{"lineNum":" 1280","line":"        var oflags = w.O.CREAT;"},
{"lineNum":" 1281","line":"        var base: w.rights_t = w.RIGHT.FD_WRITE |"},
{"lineNum":" 1282","line":"            w.RIGHT.FD_DATASYNC |"},
{"lineNum":" 1283","line":"            w.RIGHT.FD_SEEK |"},
{"lineNum":" 1284","line":"            w.RIGHT.FD_TELL |"},
{"lineNum":" 1285","line":"            w.RIGHT.FD_FDSTAT_SET_FLAGS |"},
{"lineNum":" 1286","line":"            w.RIGHT.FD_SYNC |"},
{"lineNum":" 1287","line":"            w.RIGHT.FD_ALLOCATE |"},
{"lineNum":" 1288","line":"            w.RIGHT.FD_ADVISE |"},
{"lineNum":" 1289","line":"            w.RIGHT.FD_FILESTAT_SET_TIMES |"},
{"lineNum":" 1290","line":"            w.RIGHT.FD_FILESTAT_SET_SIZE |"},
{"lineNum":" 1291","line":"            w.RIGHT.FD_FILESTAT_GET;"},
{"lineNum":" 1292","line":"        if (flags.read) {"},
{"lineNum":" 1293","line":"            base |= w.RIGHT.FD_READ;"},
{"lineNum":" 1294","line":"        }"},
{"lineNum":" 1295","line":"        if (flags.truncate) {"},
{"lineNum":" 1296","line":"            oflags |= w.O.TRUNC;"},
{"lineNum":" 1297","line":"        }"},
{"lineNum":" 1298","line":"        if (flags.exclusive) {"},
{"lineNum":" 1299","line":"            oflags |= w.O.EXCL;"},
{"lineNum":" 1300","line":"        }"},
{"lineNum":" 1301","line":"        const fd = try os.openatWasi(self.fd, sub_path, 0x0, oflags, 0x0, base, 0x0);"},
{"lineNum":" 1302","line":"        return File{ .handle = fd };"},
{"lineNum":" 1303","line":"    }"},
{"lineNum":" 1304","line":""},
{"lineNum":" 1305","line":"    /// Same as `createFile` but the path parameter is null-terminated."},
{"lineNum":" 1306","line":"    pub fn createFileZ(self: Dir, sub_path_c: [*:0]const u8, flags: File.CreateFlags) File.OpenError!File {"},
{"lineNum":" 1307","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1308","line":"            const path_w = try os.windows.cStrToPrefixedFileW(sub_path_c);"},
{"lineNum":" 1309","line":"            return self.createFileW(path_w.span(), flags);"},
{"lineNum":" 1310","line":"        }"},
{"lineNum":" 1311","line":""},
{"lineNum":" 1312","line":"        // Use the O locking flags if the os supports them to acquire the lock"},
{"lineNum":" 1313","line":"        // atomically."},
{"lineNum":" 1314","line":"        const has_flock_open_flags = @hasDecl(os.O, \"EXLOCK\");"},
{"lineNum":" 1315","line":"        // Note that the O.NONBLOCK flag is removed after the openat() call"},
{"lineNum":" 1316","line":"        // is successful."},
{"lineNum":" 1317","line":"        const nonblocking_lock_flag: u32 = if (has_flock_open_flags and flags.lock_nonblocking)"},
{"lineNum":" 1318","line":"            os.O.NONBLOCK"},
{"lineNum":" 1319","line":"        else"},
{"lineNum":" 1320","line":"            0;"},
{"lineNum":" 1321","line":"        const lock_flag: u32 = if (has_flock_open_flags) switch (flags.lock) {"},
{"lineNum":" 1322","line":"            .None => @as(u32, 0),"},
{"lineNum":" 1323","line":"            .Shared => os.O.SHLOCK | nonblocking_lock_flag,"},
{"lineNum":" 1324","line":"            .Exclusive => os.O.EXLOCK | nonblocking_lock_flag,"},
{"lineNum":" 1325","line":"        } else 0;"},
{"lineNum":" 1326","line":""},
{"lineNum":" 1327","line":"        const O_LARGEFILE = if (@hasDecl(os.O, \"LARGEFILE\")) os.O.LARGEFILE else 0;"},
{"lineNum":" 1328","line":"        const os_flags = lock_flag | O_LARGEFILE | os.O.CREAT | os.O.CLOEXEC |"},
{"lineNum":" 1329","line":"            (if (flags.truncate) @as(u32, os.O.TRUNC) else 0) |"},
{"lineNum":" 1330","line":"            (if (flags.read) @as(u32, os.O.RDWR) else os.O.WRONLY) |"},
{"lineNum":" 1331","line":"            (if (flags.exclusive) @as(u32, os.O.EXCL) else 0);"},
{"lineNum":" 1332","line":"        const fd = if (flags.intended_io_mode != .blocking)"},
{"lineNum":" 1333","line":"            try std.event.Loop.instance.?.openatZ(self.fd, sub_path_c, os_flags, flags.mode)"},
{"lineNum":" 1334","line":"        else"},
{"lineNum":" 1335","line":"            try os.openatZ(self.fd, sub_path_c, os_flags, flags.mode);"},
{"lineNum":" 1336","line":"        errdefer os.close(fd);"},
{"lineNum":" 1337","line":""},
{"lineNum":" 1338","line":"        // WASI doesn\'t have os.flock so we intetinally check OS prior to the inner if block"},
{"lineNum":" 1339","line":"        // since it is not compiltime-known and we need to avoid undefined symbol in Wasm."},
{"lineNum":" 1340","line":"        if (builtin.target.os.tag != .wasi) {"},
{"lineNum":" 1341","line":"            if (!has_flock_open_flags and flags.lock != .None) {"},
{"lineNum":" 1342","line":"                // TODO: integrate async I/O"},
{"lineNum":" 1343","line":"                const lock_nonblocking = if (flags.lock_nonblocking) os.LOCK.NB else @as(i32, 0);"},
{"lineNum":" 1344","line":"                try os.flock(fd, switch (flags.lock) {"},
{"lineNum":" 1345","line":"                    .None => unreachable,"},
{"lineNum":" 1346","line":"                    .Shared => os.LOCK.SH | lock_nonblocking,"},
{"lineNum":" 1347","line":"                    .Exclusive => os.LOCK.EX | lock_nonblocking,"},
{"lineNum":" 1348","line":"                });"},
{"lineNum":" 1349","line":"            }"},
{"lineNum":" 1350","line":"        }"},
{"lineNum":" 1351","line":""},
{"lineNum":" 1352","line":"        if (has_flock_open_flags and flags.lock_nonblocking) {"},
{"lineNum":" 1353","line":"            var fl_flags = os.fcntl(fd, os.F.GETFL, 0) catch |err| switch (err) {"},
{"lineNum":" 1354","line":"                error.FileBusy => unreachable,"},
{"lineNum":" 1355","line":"                error.Locked => unreachable,"},
{"lineNum":" 1356","line":"                error.PermissionDenied => unreachable,"},
{"lineNum":" 1357","line":"                error.DeadLock => unreachable,"},
{"lineNum":" 1358","line":"                error.LockedRegionLimitExceeded => unreachable,"},
{"lineNum":" 1359","line":"                else => |e| return e,"},
{"lineNum":" 1360","line":"            };"},
{"lineNum":" 1361","line":"            fl_flags &= ~@as(usize, os.O.NONBLOCK);"},
{"lineNum":" 1362","line":"            _ = os.fcntl(fd, os.F.SETFL, fl_flags) catch |err| switch (err) {"},
{"lineNum":" 1363","line":"                error.FileBusy => unreachable,"},
{"lineNum":" 1364","line":"                error.Locked => unreachable,"},
{"lineNum":" 1365","line":"                error.PermissionDenied => unreachable,"},
{"lineNum":" 1366","line":"                error.DeadLock => unreachable,"},
{"lineNum":" 1367","line":"                error.LockedRegionLimitExceeded => unreachable,"},
{"lineNum":" 1368","line":"                else => |e| return e,"},
{"lineNum":" 1369","line":"            };"},
{"lineNum":" 1370","line":"        }"},
{"lineNum":" 1371","line":""},
{"lineNum":" 1372","line":"        return File{"},
{"lineNum":" 1373","line":"            .handle = fd,"},
{"lineNum":" 1374","line":"            .capable_io_mode = .blocking,"},
{"lineNum":" 1375","line":"            .intended_io_mode = flags.intended_io_mode,"},
{"lineNum":" 1376","line":"        };"},
{"lineNum":" 1377","line":"    }"},
{"lineNum":" 1378","line":""},
{"lineNum":" 1379","line":"    /// Same as `createFile` but Windows-only and the path parameter is"},
{"lineNum":" 1380","line":"    /// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded."},
{"lineNum":" 1381","line":"    pub fn createFileW(self: Dir, sub_path_w: []const u16, flags: File.CreateFlags) File.OpenError!File {"},
{"lineNum":" 1382","line":"        const w = os.windows;"},
{"lineNum":" 1383","line":"        const read_flag = if (flags.read) @as(u32, w.GENERIC_READ) else 0;"},
{"lineNum":" 1384","line":"        const file: File = .{"},
{"lineNum":" 1385","line":"            .handle = try os.windows.OpenFile(sub_path_w, .{"},
{"lineNum":" 1386","line":"                .dir = self.fd,"},
{"lineNum":" 1387","line":"                .access_mask = w.SYNCHRONIZE | w.GENERIC_WRITE | read_flag,"},
{"lineNum":" 1388","line":"                .creation = if (flags.exclusive)"},
{"lineNum":" 1389","line":"                    @as(u32, w.FILE_CREATE)"},
{"lineNum":" 1390","line":"                else if (flags.truncate)"},
{"lineNum":" 1391","line":"                    @as(u32, w.FILE_OVERWRITE_IF)"},
{"lineNum":" 1392","line":"                else"},
{"lineNum":" 1393","line":"                    @as(u32, w.FILE_OPEN_IF),"},
{"lineNum":" 1394","line":"                .io_mode = flags.intended_io_mode,"},
{"lineNum":" 1395","line":"            }),"},
{"lineNum":" 1396","line":"            .capable_io_mode = std.io.default_mode,"},
{"lineNum":" 1397","line":"            .intended_io_mode = flags.intended_io_mode,"},
{"lineNum":" 1398","line":"        };"},
{"lineNum":" 1399","line":"        var io: w.IO_STATUS_BLOCK = undefined;"},
{"lineNum":" 1400","line":"        const range_off: w.LARGE_INTEGER = 0;"},
{"lineNum":" 1401","line":"        const range_len: w.LARGE_INTEGER = 1;"},
{"lineNum":" 1402","line":"        const exclusive = switch (flags.lock) {"},
{"lineNum":" 1403","line":"            .None => return file,"},
{"lineNum":" 1404","line":"            .Shared => false,"},
{"lineNum":" 1405","line":"            .Exclusive => true,"},
{"lineNum":" 1406","line":"        };"},
{"lineNum":" 1407","line":"        try w.LockFile("},
{"lineNum":" 1408","line":"            file.handle,"},
{"lineNum":" 1409","line":"            null,"},
{"lineNum":" 1410","line":"            null,"},
{"lineNum":" 1411","line":"            null,"},
{"lineNum":" 1412","line":"            &io,"},
{"lineNum":" 1413","line":"            &range_off,"},
{"lineNum":" 1414","line":"            &range_len,"},
{"lineNum":" 1415","line":"            null,"},
{"lineNum":" 1416","line":"            @boolToInt(flags.lock_nonblocking),"},
{"lineNum":" 1417","line":"            @boolToInt(exclusive),"},
{"lineNum":" 1418","line":"        );"},
{"lineNum":" 1419","line":"        return file;"},
{"lineNum":" 1420","line":"    }"},
{"lineNum":" 1421","line":""},
{"lineNum":" 1422","line":"    pub fn makeDir(self: Dir, sub_path: []const u8) !void {"},
{"lineNum":" 1423","line":"        try os.mkdirat(self.fd, sub_path, default_new_dir_mode);"},
{"lineNum":" 1424","line":"    }"},
{"lineNum":" 1425","line":""},
{"lineNum":" 1426","line":"    pub fn makeDirZ(self: Dir, sub_path: [*:0]const u8) !void {"},
{"lineNum":" 1427","line":"        try os.mkdiratZ(self.fd, sub_path, default_new_dir_mode);"},
{"lineNum":" 1428","line":"    }"},
{"lineNum":" 1429","line":""},
{"lineNum":" 1430","line":"    pub fn makeDirW(self: Dir, sub_path: [*:0]const u16) !void {"},
{"lineNum":" 1431","line":"        try os.mkdiratW(self.fd, sub_path, default_new_dir_mode);"},
{"lineNum":" 1432","line":"    }"},
{"lineNum":" 1433","line":""},
{"lineNum":" 1434","line":"    /// Calls makeDir recursively to make an entire path. Returns success if the path"},
{"lineNum":" 1435","line":"    /// already exists and is a directory."},
{"lineNum":" 1436","line":"    /// This function is not atomic, and if it returns an error, the file system may"},
{"lineNum":" 1437","line":"    /// have been modified regardless."},
{"lineNum":" 1438","line":"    pub fn makePath(self: Dir, sub_path: []const u8) !void {"},
{"lineNum":" 1439","line":"        var end_index: usize = sub_path.len;"},
{"lineNum":" 1440","line":"        while (true) {"},
{"lineNum":" 1441","line":"            self.makeDir(sub_path[0..end_index]) catch |err| switch (err) {"},
{"lineNum":" 1442","line":"                error.PathAlreadyExists => {"},
{"lineNum":" 1443","line":"                    // TODO stat the file and return an error if it\'s not a directory"},
{"lineNum":" 1444","line":"                    // this is important because otherwise a dangling symlink"},
{"lineNum":" 1445","line":"                    // could cause an infinite loop"},
{"lineNum":" 1446","line":"                    if (end_index == sub_path.len) return;"},
{"lineNum":" 1447","line":"                },"},
{"lineNum":" 1448","line":"                error.FileNotFound => {"},
{"lineNum":" 1449","line":"                    // march end_index backward until next path component"},
{"lineNum":" 1450","line":"                    while (true) {"},
{"lineNum":" 1451","line":"                        if (end_index == 0) return err;"},
{"lineNum":" 1452","line":"                        end_index -= 1;"},
{"lineNum":" 1453","line":"                        if (path.isSep(sub_path[end_index])) break;"},
{"lineNum":" 1454","line":"                    }"},
{"lineNum":" 1455","line":"                    continue;"},
{"lineNum":" 1456","line":"                },"},
{"lineNum":" 1457","line":"                else => return err,"},
{"lineNum":" 1458","line":"            };"},
{"lineNum":" 1459","line":"            if (end_index == sub_path.len) return;"},
{"lineNum":" 1460","line":"            // march end_index forward until next path component"},
{"lineNum":" 1461","line":"            while (true) {"},
{"lineNum":" 1462","line":"                end_index += 1;"},
{"lineNum":" 1463","line":"                if (end_index == sub_path.len or path.isSep(sub_path[end_index])) break;"},
{"lineNum":" 1464","line":"            }"},
{"lineNum":" 1465","line":"        }"},
{"lineNum":" 1466","line":"    }"},
{"lineNum":" 1467","line":""},
{"lineNum":" 1468","line":"    /// This function performs `makePath`, followed by `openDir`."},
{"lineNum":" 1469","line":"    /// If supported by the OS, this operation is atomic. It is not atomic on"},
{"lineNum":" 1470","line":"    /// all operating systems."},
{"lineNum":" 1471","line":"    pub fn makeOpenPath(self: Dir, sub_path: []const u8, open_dir_options: OpenDirOptions) !Dir {"},
{"lineNum":" 1472","line":"        // TODO improve this implementation on Windows; we can avoid 1 call to NtClose"},
{"lineNum":" 1473","line":"        try self.makePath(sub_path);"},
{"lineNum":" 1474","line":"        return self.openDir(sub_path, open_dir_options);"},
{"lineNum":" 1475","line":"    }"},
{"lineNum":" 1476","line":""},
{"lineNum":" 1477","line":"    /// This function performs `makePath`, followed by `openIterableDir`."},
{"lineNum":" 1478","line":"    /// If supported by the OS, this operation is atomic. It is not atomic on"},
{"lineNum":" 1479","line":"    /// all operating systems."},
{"lineNum":" 1480","line":"    pub fn makeOpenPathIterable(self: Dir, sub_path: []const u8, open_dir_options: OpenDirOptions) !IterableDir {"},
{"lineNum":" 1481","line":"        // TODO improve this implementation on Windows; we can avoid 1 call to NtClose"},
{"lineNum":" 1482","line":"        try self.makePath(sub_path);"},
{"lineNum":" 1483","line":"        return self.openIterableDir(sub_path, open_dir_options);"},
{"lineNum":" 1484","line":"    }"},
{"lineNum":" 1485","line":""},
{"lineNum":" 1486","line":"    ///  This function returns the canonicalized absolute pathname of"},
{"lineNum":" 1487","line":"    /// `pathname` relative to this `Dir`. If `pathname` is absolute, ignores this"},
{"lineNum":" 1488","line":"    /// `Dir` handle and returns the canonicalized absolute pathname of `pathname`"},
{"lineNum":" 1489","line":"    /// argument."},
{"lineNum":" 1490","line":"    /// This function is not universally supported by all platforms."},
{"lineNum":" 1491","line":"    /// Currently supported hosts are: Linux, macOS, and Windows."},
{"lineNum":" 1492","line":"    /// See also `Dir.realpathZ`, `Dir.realpathW`, and `Dir.realpathAlloc`."},
{"lineNum":" 1493","line":"    pub fn realpath(self: Dir, pathname: []const u8, out_buffer: []u8) ![]u8 {"},
{"lineNum":" 1494","line":"        if (builtin.os.tag == .wasi) {"},
{"lineNum":" 1495","line":"            @compileError(\"realpath is not available on WASI\");"},
{"lineNum":" 1496","line":"        }"},
{"lineNum":" 1497","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1498","line":"            const pathname_w = try os.windows.sliceToPrefixedFileW(pathname);"},
{"lineNum":" 1499","line":"            return self.realpathW(pathname_w.span(), out_buffer);"},
{"lineNum":" 1500","line":"        }"},
{"lineNum":" 1501","line":"        const pathname_c = try os.toPosixPath(pathname);"},
{"lineNum":" 1502","line":"        return self.realpathZ(&pathname_c, out_buffer);"},
{"lineNum":" 1503","line":"    }"},
{"lineNum":" 1504","line":""},
{"lineNum":" 1505","line":"    /// Same as `Dir.realpath` except `pathname` is null-terminated."},
{"lineNum":" 1506","line":"    /// See also `Dir.realpath`, `realpathZ`."},
{"lineNum":" 1507","line":"    pub fn realpathZ(self: Dir, pathname: [*:0]const u8, out_buffer: []u8) ![]u8 {"},
{"lineNum":" 1508","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1509","line":"            const pathname_w = try os.windows.cStrToPrefixedFileW(pathname);"},
{"lineNum":" 1510","line":"            return self.realpathW(pathname_w.span(), out_buffer);"},
{"lineNum":" 1511","line":"        }"},
{"lineNum":" 1512","line":""},
{"lineNum":" 1513","line":"        const flags = if (builtin.os.tag == .linux) os.O.PATH | os.O.NONBLOCK | os.O.CLOEXEC else os.O.NONBLOCK | os.O.CLOEXEC;"},
{"lineNum":" 1514","line":"        const fd = os.openatZ(self.fd, pathname, flags, 0) catch |err| switch (err) {"},
{"lineNum":" 1515","line":"            error.FileLocksNotSupported => unreachable,"},
{"lineNum":" 1516","line":"            else => |e| return e,"},
{"lineNum":" 1517","line":"        };"},
{"lineNum":" 1518","line":"        defer os.close(fd);"},
{"lineNum":" 1519","line":""},
{"lineNum":" 1520","line":"        // Use of MAX_PATH_BYTES here is valid as the realpath function does not"},
{"lineNum":" 1521","line":"        // have a variant that takes an arbitrary-size buffer."},
{"lineNum":" 1522","line":"        // TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008"},
{"lineNum":" 1523","line":"        // NULL out parameter (GNU\'s canonicalize_file_name) to handle overelong"},
{"lineNum":" 1524","line":"        // paths. musl supports passing NULL but restricts the output to PATH_MAX"},
{"lineNum":" 1525","line":"        // anyway."},
{"lineNum":" 1526","line":"        var buffer: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 1527","line":"        const out_path = try os.getFdPath(fd, &buffer);"},
{"lineNum":" 1528","line":""},
{"lineNum":" 1529","line":"        if (out_path.len > out_buffer.len) {"},
{"lineNum":" 1530","line":"            return error.NameTooLong;"},
{"lineNum":" 1531","line":"        }"},
{"lineNum":" 1532","line":""},
{"lineNum":" 1533","line":"        mem.copy(u8, out_buffer, out_path);"},
{"lineNum":" 1534","line":""},
{"lineNum":" 1535","line":"        return out_buffer[0..out_path.len];"},
{"lineNum":" 1536","line":"    }"},
{"lineNum":" 1537","line":""},
{"lineNum":" 1538","line":"    /// Windows-only. Same as `Dir.realpath` except `pathname` is WTF16 encoded."},
{"lineNum":" 1539","line":"    /// See also `Dir.realpath`, `realpathW`."},
{"lineNum":" 1540","line":"    pub fn realpathW(self: Dir, pathname: []const u16, out_buffer: []u8) ![]u8 {"},
{"lineNum":" 1541","line":"        const w = os.windows;"},
{"lineNum":" 1542","line":""},
{"lineNum":" 1543","line":"        const access_mask = w.GENERIC_READ | w.SYNCHRONIZE;"},
{"lineNum":" 1544","line":"        const share_access = w.FILE_SHARE_READ;"},
{"lineNum":" 1545","line":"        const creation = w.FILE_OPEN;"},
{"lineNum":" 1546","line":"        const h_file = blk: {"},
{"lineNum":" 1547","line":"            const res = w.OpenFile(pathname, .{"},
{"lineNum":" 1548","line":"                .dir = self.fd,"},
{"lineNum":" 1549","line":"                .access_mask = access_mask,"},
{"lineNum":" 1550","line":"                .share_access = share_access,"},
{"lineNum":" 1551","line":"                .creation = creation,"},
{"lineNum":" 1552","line":"                .io_mode = .blocking,"},
{"lineNum":" 1553","line":"            }) catch |err| switch (err) {"},
{"lineNum":" 1554","line":"                error.IsDir => break :blk w.OpenFile(pathname, .{"},
{"lineNum":" 1555","line":"                    .dir = self.fd,"},
{"lineNum":" 1556","line":"                    .access_mask = access_mask,"},
{"lineNum":" 1557","line":"                    .share_access = share_access,"},
{"lineNum":" 1558","line":"                    .creation = creation,"},
{"lineNum":" 1559","line":"                    .io_mode = .blocking,"},
{"lineNum":" 1560","line":"                    .filter = .dir_only,"},
{"lineNum":" 1561","line":"                }) catch |er| switch (er) {"},
{"lineNum":" 1562","line":"                    error.WouldBlock => unreachable,"},
{"lineNum":" 1563","line":"                    else => |e2| return e2,"},
{"lineNum":" 1564","line":"                },"},
{"lineNum":" 1565","line":"                error.WouldBlock => unreachable,"},
{"lineNum":" 1566","line":"                else => |e| return e,"},
{"lineNum":" 1567","line":"            };"},
{"lineNum":" 1568","line":"            break :blk res;"},
{"lineNum":" 1569","line":"        };"},
{"lineNum":" 1570","line":"        defer w.CloseHandle(h_file);"},
{"lineNum":" 1571","line":""},
{"lineNum":" 1572","line":"        // Use of MAX_PATH_BYTES here is valid as the realpath function does not"},
{"lineNum":" 1573","line":"        // have a variant that takes an arbitrary-size buffer."},
{"lineNum":" 1574","line":"        // TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008"},
{"lineNum":" 1575","line":"        // NULL out parameter (GNU\'s canonicalize_file_name) to handle overelong"},
{"lineNum":" 1576","line":"        // paths. musl supports passing NULL but restricts the output to PATH_MAX"},
{"lineNum":" 1577","line":"        // anyway."},
{"lineNum":" 1578","line":"        var buffer: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 1579","line":"        const out_path = try os.getFdPath(h_file, &buffer);"},
{"lineNum":" 1580","line":""},
{"lineNum":" 1581","line":"        if (out_path.len > out_buffer.len) {"},
{"lineNum":" 1582","line":"            return error.NameTooLong;"},
{"lineNum":" 1583","line":"        }"},
{"lineNum":" 1584","line":""},
{"lineNum":" 1585","line":"        mem.copy(u8, out_buffer, out_path);"},
{"lineNum":" 1586","line":""},
{"lineNum":" 1587","line":"        return out_buffer[0..out_path.len];"},
{"lineNum":" 1588","line":"    }"},
{"lineNum":" 1589","line":""},
{"lineNum":" 1590","line":"    /// Same as `Dir.realpath` except caller must free the returned memory."},
{"lineNum":" 1591","line":"    /// See also `Dir.realpath`."},
{"lineNum":" 1592","line":"    pub fn realpathAlloc(self: Dir, allocator: Allocator, pathname: []const u8) ![]u8 {"},
{"lineNum":" 1593","line":"        // Use of MAX_PATH_BYTES here is valid as the realpath function does not"},
{"lineNum":" 1594","line":"        // have a variant that takes an arbitrary-size buffer."},
{"lineNum":" 1595","line":"        // TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008"},
{"lineNum":" 1596","line":"        // NULL out parameter (GNU\'s canonicalize_file_name) to handle overelong"},
{"lineNum":" 1597","line":"        // paths. musl supports passing NULL but restricts the output to PATH_MAX"},
{"lineNum":" 1598","line":"        // anyway."},
{"lineNum":" 1599","line":"        var buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 1600","line":"        return allocator.dupe(u8, try self.realpath(pathname, buf[0..]));"},
{"lineNum":" 1601","line":"    }"},
{"lineNum":" 1602","line":""},
{"lineNum":" 1603","line":"    /// Changes the current working directory to the open directory handle."},
{"lineNum":" 1604","line":"    /// This modifies global state and can have surprising effects in multi-"},
{"lineNum":" 1605","line":"    /// threaded applications. Most applications and especially libraries should"},
{"lineNum":" 1606","line":"    /// not call this function as a general rule, however it can have use cases"},
{"lineNum":" 1607","line":"    /// in, for example, implementing a shell, or child process execution."},
{"lineNum":" 1608","line":"    /// Not all targets support this. For example, WASI does not have the concept"},
{"lineNum":" 1609","line":"    /// of a current working directory."},
{"lineNum":" 1610","line":"    pub fn setAsCwd(self: Dir) !void {"},
{"lineNum":" 1611","line":"        if (builtin.os.tag == .wasi) {"},
{"lineNum":" 1612","line":"            @compileError(\"changing cwd is not currently possible in WASI\");"},
{"lineNum":" 1613","line":"        }"},
{"lineNum":" 1614","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1615","line":"            var dir_path_buffer: [os.windows.PATH_MAX_WIDE]u16 = undefined;"},
{"lineNum":" 1616","line":"            var dir_path = try os.windows.GetFinalPathNameByHandle(self.fd, .{}, &dir_path_buffer);"},
{"lineNum":" 1617","line":"            if (builtin.link_libc) {"},
{"lineNum":" 1618","line":"                return os.chdirW(dir_path);"},
{"lineNum":" 1619","line":"            }"},
{"lineNum":" 1620","line":"            return os.windows.SetCurrentDirectory(dir_path);"},
{"lineNum":" 1621","line":"        }"},
{"lineNum":" 1622","line":"        try os.fchdir(self.fd);"},
{"lineNum":" 1623","line":"    }"},
{"lineNum":" 1624","line":""},
{"lineNum":" 1625","line":"    pub const OpenDirOptions = struct {"},
{"lineNum":" 1626","line":"        /// `true` means the opened directory can be used as the `Dir` parameter"},
{"lineNum":" 1627","line":"        /// for functions which operate based on an open directory handle. When `false`,"},
{"lineNum":" 1628","line":"        /// such operations are Illegal Behavior."},
{"lineNum":" 1629","line":"        access_sub_paths: bool = true,"},
{"lineNum":" 1630","line":""},
{"lineNum":" 1631","line":"        /// `true` means it won\'t dereference the symlinks."},
{"lineNum":" 1632","line":"        no_follow: bool = false,"},
{"lineNum":" 1633","line":"    };"},
{"lineNum":" 1634","line":""},
{"lineNum":" 1635","line":"    /// Opens a directory at the given path. The directory is a system resource that remains"},
{"lineNum":" 1636","line":"    /// open until `close` is called on the result."},
{"lineNum":" 1637","line":"    ///"},
{"lineNum":" 1638","line":"    /// Asserts that the path parameter has no null bytes."},
{"lineNum":" 1639","line":"    pub fn openDir(self: Dir, sub_path: []const u8, args: OpenDirOptions) OpenError!Dir {"},
{"lineNum":" 1640","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1641","line":"            const sub_path_w = try os.windows.sliceToPrefixedFileW(sub_path);"},
{"lineNum":" 1642","line":"            return self.openDirW(sub_path_w.span().ptr, args, false);"},
{"lineNum":" 1643","line":"        } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1644","line":"            return self.openDirWasi(sub_path, args);"},
{"lineNum":" 1645","line":"        } else {"},
{"lineNum":" 1646","line":"            const sub_path_c = try os.toPosixPath(sub_path);"},
{"lineNum":" 1647","line":"            return self.openDirZ(&sub_path_c, args, false);"},
{"lineNum":" 1648","line":"        }"},
{"lineNum":" 1649","line":"    }"},
{"lineNum":" 1650","line":""},
{"lineNum":" 1651","line":"    /// Opens an iterable directory at the given path. The directory is a system resource that remains"},
{"lineNum":" 1652","line":"    /// open until `close` is called on the result."},
{"lineNum":" 1653","line":"    ///"},
{"lineNum":" 1654","line":"    /// Asserts that the path parameter has no null bytes."},
{"lineNum":" 1655","line":"    pub fn openIterableDir(self: Dir, sub_path: []const u8, args: OpenDirOptions) OpenError!IterableDir {"},
{"lineNum":" 1656","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1657","line":"            const sub_path_w = try os.windows.sliceToPrefixedFileW(sub_path);"},
{"lineNum":" 1658","line":"            return IterableDir{ .dir = try self.openDirW(sub_path_w.span().ptr, args, true) };"},
{"lineNum":" 1659","line":"        } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1660","line":"            return IterableDir{ .dir = try self.openDirWasi(sub_path, args) };"},
{"lineNum":" 1661","line":"        } else {"},
{"lineNum":" 1662","line":"            const sub_path_c = try os.toPosixPath(sub_path);"},
{"lineNum":" 1663","line":"            return IterableDir{ .dir = try self.openDirZ(&sub_path_c, args, true) };"},
{"lineNum":" 1664","line":"        }"},
{"lineNum":" 1665","line":"    }"},
{"lineNum":" 1666","line":""},
{"lineNum":" 1667","line":"    /// Same as `openDir` except only WASI."},
{"lineNum":" 1668","line":"    pub fn openDirWasi(self: Dir, sub_path: []const u8, args: OpenDirOptions) OpenError!Dir {"},
{"lineNum":" 1669","line":"        const w = os.wasi;"},
{"lineNum":" 1670","line":"        var base: w.rights_t = w.RIGHT.FD_FILESTAT_GET | w.RIGHT.FD_FDSTAT_SET_FLAGS | w.RIGHT.FD_FILESTAT_SET_TIMES;"},
{"lineNum":" 1671","line":"        if (args.access_sub_paths) {"},
{"lineNum":" 1672","line":"            base |= w.RIGHT.FD_READDIR |"},
{"lineNum":" 1673","line":"                w.RIGHT.PATH_CREATE_DIRECTORY |"},
{"lineNum":" 1674","line":"                w.RIGHT.PATH_CREATE_FILE |"},
{"lineNum":" 1675","line":"                w.RIGHT.PATH_LINK_SOURCE |"},
{"lineNum":" 1676","line":"                w.RIGHT.PATH_LINK_TARGET |"},
{"lineNum":" 1677","line":"                w.RIGHT.PATH_OPEN |"},
{"lineNum":" 1678","line":"                w.RIGHT.PATH_READLINK |"},
{"lineNum":" 1679","line":"                w.RIGHT.PATH_RENAME_SOURCE |"},
{"lineNum":" 1680","line":"                w.RIGHT.PATH_RENAME_TARGET |"},
{"lineNum":" 1681","line":"                w.RIGHT.PATH_FILESTAT_GET |"},
{"lineNum":" 1682","line":"                w.RIGHT.PATH_FILESTAT_SET_SIZE |"},
{"lineNum":" 1683","line":"                w.RIGHT.PATH_FILESTAT_SET_TIMES |"},
{"lineNum":" 1684","line":"                w.RIGHT.PATH_SYMLINK |"},
{"lineNum":" 1685","line":"                w.RIGHT.PATH_REMOVE_DIRECTORY |"},
{"lineNum":" 1686","line":"                w.RIGHT.PATH_UNLINK_FILE;"},
{"lineNum":" 1687","line":"        }"},
{"lineNum":" 1688","line":"        const symlink_flags: w.lookupflags_t = if (args.no_follow) 0x0 else w.LOOKUP_SYMLINK_FOLLOW;"},
{"lineNum":" 1689","line":"        // TODO do we really need all the rights here?"},
{"lineNum":" 1690","line":"        const inheriting: w.rights_t = w.RIGHT.ALL ^ w.RIGHT.SOCK_SHUTDOWN;"},
{"lineNum":" 1691","line":""},
{"lineNum":" 1692","line":"        const result = os.openatWasi("},
{"lineNum":" 1693","line":"            self.fd,"},
{"lineNum":" 1694","line":"            sub_path,"},
{"lineNum":" 1695","line":"            symlink_flags,"},
{"lineNum":" 1696","line":"            w.O.DIRECTORY,"},
{"lineNum":" 1697","line":"            0x0,"},
{"lineNum":" 1698","line":"            base,"},
{"lineNum":" 1699","line":"            inheriting,"},
{"lineNum":" 1700","line":"        );"},
{"lineNum":" 1701","line":"        const fd = result catch |err| switch (err) {"},
{"lineNum":" 1702","line":"            error.FileTooBig => unreachable, // can\'t happen for directories"},
{"lineNum":" 1703","line":"            error.IsDir => unreachable, // we\'re providing O.DIRECTORY"},
{"lineNum":" 1704","line":"            error.NoSpaceLeft => unreachable, // not providing O.CREAT"},
{"lineNum":" 1705","line":"            error.PathAlreadyExists => unreachable, // not providing O.CREAT"},
{"lineNum":" 1706","line":"            error.FileLocksNotSupported => unreachable, // locking folders is not supported"},
{"lineNum":" 1707","line":"            error.WouldBlock => unreachable, // can\'t happen for directories"},
{"lineNum":" 1708","line":"            error.FileBusy => unreachable, // can\'t happen for directories"},
{"lineNum":" 1709","line":"            else => |e| return e,"},
{"lineNum":" 1710","line":"        };"},
{"lineNum":" 1711","line":"        return Dir{ .fd = fd };"},
{"lineNum":" 1712","line":"    }"},
{"lineNum":" 1713","line":""},
{"lineNum":" 1714","line":"    /// Same as `openDir` except the parameter is null-terminated."},
{"lineNum":" 1715","line":"    pub fn openDirZ(self: Dir, sub_path_c: [*:0]const u8, args: OpenDirOptions, iterable: bool) OpenError!Dir {"},
{"lineNum":" 1716","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1717","line":"            const sub_path_w = try os.windows.cStrToPrefixedFileW(sub_path_c);"},
{"lineNum":" 1718","line":"            return self.openDirW(sub_path_w.span().ptr, args, iterable);"},
{"lineNum":" 1719","line":"        }"},
{"lineNum":" 1720","line":"        const symlink_flags: u32 = if (args.no_follow) os.O.NOFOLLOW else 0x0;"},
{"lineNum":" 1721","line":"        if (!iterable) {"},
{"lineNum":" 1722","line":"            const O_PATH = if (@hasDecl(os.O, \"PATH\")) os.O.PATH else 0;"},
{"lineNum":" 1723","line":"            return self.openDirFlagsZ(sub_path_c, os.O.DIRECTORY | os.O.RDONLY | os.O.CLOEXEC | O_PATH | symlink_flags);"},
{"lineNum":" 1724","line":"        } else {"},
{"lineNum":" 1725","line":"            return self.openDirFlagsZ(sub_path_c, os.O.DIRECTORY | os.O.RDONLY | os.O.CLOEXEC | symlink_flags);"},
{"lineNum":" 1726","line":"        }"},
{"lineNum":" 1727","line":"    }"},
{"lineNum":" 1728","line":""},
{"lineNum":" 1729","line":"    /// Same as `openDir` except the path parameter is WTF-16 encoded, NT-prefixed."},
{"lineNum":" 1730","line":"    /// This function asserts the target OS is Windows."},
{"lineNum":" 1731","line":"    pub fn openDirW(self: Dir, sub_path_w: [*:0]const u16, args: OpenDirOptions, iterable: bool) OpenError!Dir {"},
{"lineNum":" 1732","line":"        const w = os.windows;"},
{"lineNum":" 1733","line":"        // TODO remove some of these flags if args.access_sub_paths is false"},
{"lineNum":" 1734","line":"        const base_flags = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |"},
{"lineNum":" 1735","line":"            w.SYNCHRONIZE | w.FILE_TRAVERSE;"},
{"lineNum":" 1736","line":"        const flags: u32 = if (iterable) base_flags | w.FILE_LIST_DIRECTORY else base_flags;"},
{"lineNum":" 1737","line":"        var dir = try self.openDirAccessMaskW(sub_path_w, flags, args.no_follow);"},
{"lineNum":" 1738","line":"        return dir;"},
{"lineNum":" 1739","line":"    }"},
{"lineNum":" 1740","line":""},
{"lineNum":" 1741","line":"    /// `flags` must contain `os.O.DIRECTORY`."},
{"lineNum":" 1742","line":"    fn openDirFlagsZ(self: Dir, sub_path_c: [*:0]const u8, flags: u32) OpenError!Dir {"},
{"lineNum":" 1743","line":"        const result = if (need_async_thread)"},
{"lineNum":" 1744","line":"            std.event.Loop.instance.?.openatZ(self.fd, sub_path_c, flags, 0)"},
{"lineNum":" 1745","line":"        else"},
{"lineNum":" 1746","line":"            os.openatZ(self.fd, sub_path_c, flags, 0);"},
{"lineNum":" 1747","line":"        const fd = result catch |err| switch (err) {"},
{"lineNum":" 1748","line":"            error.FileTooBig => unreachable, // can\'t happen for directories"},
{"lineNum":" 1749","line":"            error.IsDir => unreachable, // we\'re providing O.DIRECTORY"},
{"lineNum":" 1750","line":"            error.NoSpaceLeft => unreachable, // not providing O.CREAT"},
{"lineNum":" 1751","line":"            error.PathAlreadyExists => unreachable, // not providing O.CREAT"},
{"lineNum":" 1752","line":"            error.FileLocksNotSupported => unreachable, // locking folders is not supported"},
{"lineNum":" 1753","line":"            error.WouldBlock => unreachable, // can\'t happen for directories"},
{"lineNum":" 1754","line":"            error.FileBusy => unreachable, // can\'t happen for directories"},
{"lineNum":" 1755","line":"            else => |e| return e,"},
{"lineNum":" 1756","line":"        };"},
{"lineNum":" 1757","line":"        return Dir{ .fd = fd };"},
{"lineNum":" 1758","line":"    }"},
{"lineNum":" 1759","line":""},
{"lineNum":" 1760","line":"    fn openDirAccessMaskW(self: Dir, sub_path_w: [*:0]const u16, access_mask: u32, no_follow: bool) OpenError!Dir {"},
{"lineNum":" 1761","line":"        const w = os.windows;"},
{"lineNum":" 1762","line":""},
{"lineNum":" 1763","line":"        var result = Dir{"},
{"lineNum":" 1764","line":"            .fd = undefined,"},
{"lineNum":" 1765","line":"        };"},
{"lineNum":" 1766","line":""},
{"lineNum":" 1767","line":"        const path_len_bytes = @intCast(u16, mem.sliceTo(sub_path_w, 0).len * 2);"},
{"lineNum":" 1768","line":"        var nt_name = w.UNICODE_STRING{"},
{"lineNum":" 1769","line":"            .Length = path_len_bytes,"},
{"lineNum":" 1770","line":"            .MaximumLength = path_len_bytes,"},
{"lineNum":" 1771","line":"            .Buffer = @constCast(sub_path_w),"},
{"lineNum":" 1772","line":"        };"},
{"lineNum":" 1773","line":"        var attr = w.OBJECT_ATTRIBUTES{"},
{"lineNum":" 1774","line":"            .Length = @sizeOf(w.OBJECT_ATTRIBUTES),"},
{"lineNum":" 1775","line":"            .RootDirectory = if (path.isAbsoluteWindowsW(sub_path_w)) null else self.fd,"},
{"lineNum":" 1776","line":"            .Attributes = 0, // Note we do not use OBJ_CASE_INSENSITIVE here."},
{"lineNum":" 1777","line":"            .ObjectName = &nt_name,"},
{"lineNum":" 1778","line":"            .SecurityDescriptor = null,"},
{"lineNum":" 1779","line":"            .SecurityQualityOfService = null,"},
{"lineNum":" 1780","line":"        };"},
{"lineNum":" 1781","line":"        const open_reparse_point: w.DWORD = if (no_follow) w.FILE_OPEN_REPARSE_POINT else 0x0;"},
{"lineNum":" 1782","line":"        var io: w.IO_STATUS_BLOCK = undefined;"},
{"lineNum":" 1783","line":"        const rc = w.ntdll.NtCreateFile("},
{"lineNum":" 1784","line":"            &result.fd,"},
{"lineNum":" 1785","line":"            access_mask,"},
{"lineNum":" 1786","line":"            &attr,"},
{"lineNum":" 1787","line":"            &io,"},
{"lineNum":" 1788","line":"            null,"},
{"lineNum":" 1789","line":"            0,"},
{"lineNum":" 1790","line":"            w.FILE_SHARE_READ | w.FILE_SHARE_WRITE,"},
{"lineNum":" 1791","line":"            w.FILE_OPEN,"},
{"lineNum":" 1792","line":"            w.FILE_DIRECTORY_FILE | w.FILE_SYNCHRONOUS_IO_NONALERT | w.FILE_OPEN_FOR_BACKUP_INTENT | open_reparse_point,"},
{"lineNum":" 1793","line":"            null,"},
{"lineNum":" 1794","line":"            0,"},
{"lineNum":" 1795","line":"        );"},
{"lineNum":" 1796","line":"        switch (rc) {"},
{"lineNum":" 1797","line":"            .SUCCESS => return result,"},
{"lineNum":" 1798","line":"            .OBJECT_NAME_INVALID => unreachable,"},
{"lineNum":" 1799","line":"            .OBJECT_NAME_NOT_FOUND => return error.FileNotFound,"},
{"lineNum":" 1800","line":"            .OBJECT_PATH_NOT_FOUND => return error.FileNotFound,"},
{"lineNum":" 1801","line":"            .NOT_A_DIRECTORY => return error.NotDir,"},
{"lineNum":" 1802","line":"            // This can happen if the directory has \'List folder contents\' permission set to \'Deny\'"},
{"lineNum":" 1803","line":"            // and the directory is trying to be opened for iteration."},
{"lineNum":" 1804","line":"            .ACCESS_DENIED => return error.AccessDenied,"},
{"lineNum":" 1805","line":"            .INVALID_PARAMETER => unreachable,"},
{"lineNum":" 1806","line":"            else => return w.unexpectedStatus(rc),"},
{"lineNum":" 1807","line":"        }"},
{"lineNum":" 1808","line":"    }"},
{"lineNum":" 1809","line":""},
{"lineNum":" 1810","line":"    pub const DeleteFileError = os.UnlinkError;"},
{"lineNum":" 1811","line":""},
{"lineNum":" 1812","line":"    /// Delete a file name and possibly the file it refers to, based on an open directory handle."},
{"lineNum":" 1813","line":"    /// Asserts that the path parameter has no null bytes."},
{"lineNum":" 1814","line":"    pub fn deleteFile(self: Dir, sub_path: []const u8) DeleteFileError!void {"},
{"lineNum":" 1815","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1816","line":"            const sub_path_w = try os.windows.sliceToPrefixedFileW(sub_path);"},
{"lineNum":" 1817","line":"            return self.deleteFileW(sub_path_w.span());"},
{"lineNum":" 1818","line":"        } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1819","line":"            os.unlinkat(self.fd, sub_path, 0) catch |err| switch (err) {"},
{"lineNum":" 1820","line":"                error.DirNotEmpty => unreachable, // not passing AT.REMOVEDIR"},
{"lineNum":" 1821","line":"                else => |e| return e,"},
{"lineNum":" 1822","line":"            };"},
{"lineNum":" 1823","line":"        } else {"},
{"lineNum":" 1824","line":"            const sub_path_c = try os.toPosixPath(sub_path);"},
{"lineNum":" 1825","line":"            return self.deleteFileZ(&sub_path_c);"},
{"lineNum":" 1826","line":"        }"},
{"lineNum":" 1827","line":"    }"},
{"lineNum":" 1828","line":""},
{"lineNum":" 1829","line":"    /// Same as `deleteFile` except the parameter is null-terminated."},
{"lineNum":" 1830","line":"    pub fn deleteFileZ(self: Dir, sub_path_c: [*:0]const u8) DeleteFileError!void {"},
{"lineNum":" 1831","line":"        os.unlinkatZ(self.fd, sub_path_c, 0) catch |err| switch (err) {"},
{"lineNum":" 1832","line":"            error.DirNotEmpty => unreachable, // not passing AT.REMOVEDIR"},
{"lineNum":" 1833","line":"            error.AccessDenied => |e| switch (builtin.os.tag) {"},
{"lineNum":" 1834","line":"                // non-Linux POSIX systems return EPERM when trying to delete a directory, so"},
{"lineNum":" 1835","line":"                // we need to handle that case specifically and translate the error"},
{"lineNum":" 1836","line":"                .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris => {"},
{"lineNum":" 1837","line":"                    // Don\'t follow symlinks to match unlinkat (which acts on symlinks rather than follows them)"},
{"lineNum":" 1838","line":"                    const fstat = os.fstatatZ(self.fd, sub_path_c, os.AT.SYMLINK_NOFOLLOW) catch return e;"},
{"lineNum":" 1839","line":"                    const is_dir = fstat.mode & os.S.IFMT == os.S.IFDIR;"},
{"lineNum":" 1840","line":"                    return if (is_dir) error.IsDir else e;"},
{"lineNum":" 1841","line":"                },"},
{"lineNum":" 1842","line":"                else => return e,"},
{"lineNum":" 1843","line":"            },"},
{"lineNum":" 1844","line":"            else => |e| return e,"},
{"lineNum":" 1845","line":"        };"},
{"lineNum":" 1846","line":"    }"},
{"lineNum":" 1847","line":""},
{"lineNum":" 1848","line":"    /// Same as `deleteFile` except the parameter is WTF-16 encoded."},
{"lineNum":" 1849","line":"    pub fn deleteFileW(self: Dir, sub_path_w: []const u16) DeleteFileError!void {"},
{"lineNum":" 1850","line":"        os.unlinkatW(self.fd, sub_path_w, 0) catch |err| switch (err) {"},
{"lineNum":" 1851","line":"            error.DirNotEmpty => unreachable, // not passing AT.REMOVEDIR"},
{"lineNum":" 1852","line":"            else => |e| return e,"},
{"lineNum":" 1853","line":"        };"},
{"lineNum":" 1854","line":"    }"},
{"lineNum":" 1855","line":""},
{"lineNum":" 1856","line":"    pub const DeleteDirError = error{"},
{"lineNum":" 1857","line":"        DirNotEmpty,"},
{"lineNum":" 1858","line":"        FileNotFound,"},
{"lineNum":" 1859","line":"        AccessDenied,"},
{"lineNum":" 1860","line":"        FileBusy,"},
{"lineNum":" 1861","line":"        FileSystem,"},
{"lineNum":" 1862","line":"        SymLinkLoop,"},
{"lineNum":" 1863","line":"        NameTooLong,"},
{"lineNum":" 1864","line":"        NotDir,"},
{"lineNum":" 1865","line":"        SystemResources,"},
{"lineNum":" 1866","line":"        ReadOnlyFileSystem,"},
{"lineNum":" 1867","line":"        InvalidUtf8,"},
{"lineNum":" 1868","line":"        BadPathName,"},
{"lineNum":" 1869","line":"        Unexpected,"},
{"lineNum":" 1870","line":"    };"},
{"lineNum":" 1871","line":""},
{"lineNum":" 1872","line":"    /// Returns `error.DirNotEmpty` if the directory is not empty."},
{"lineNum":" 1873","line":"    /// To delete a directory recursively, see `deleteTree`."},
{"lineNum":" 1874","line":"    /// Asserts that the path parameter has no null bytes."},
{"lineNum":" 1875","line":"    pub fn deleteDir(self: Dir, sub_path: []const u8) DeleteDirError!void {"},
{"lineNum":" 1876","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1877","line":"            const sub_path_w = try os.windows.sliceToPrefixedFileW(sub_path);"},
{"lineNum":" 1878","line":"            return self.deleteDirW(sub_path_w.span());"},
{"lineNum":" 1879","line":"        } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1880","line":"            os.unlinkat(self.fd, sub_path, os.AT.REMOVEDIR) catch |err| switch (err) {"},
{"lineNum":" 1881","line":"                error.IsDir => unreachable, // not possible since we pass AT.REMOVEDIR"},
{"lineNum":" 1882","line":"                else => |e| return e,"},
{"lineNum":" 1883","line":"            };"},
{"lineNum":" 1884","line":"        } else {"},
{"lineNum":" 1885","line":"            const sub_path_c = try os.toPosixPath(sub_path);"},
{"lineNum":" 1886","line":"            return self.deleteDirZ(&sub_path_c);"},
{"lineNum":" 1887","line":"        }"},
{"lineNum":" 1888","line":"    }"},
{"lineNum":" 1889","line":""},
{"lineNum":" 1890","line":"    /// Same as `deleteDir` except the parameter is null-terminated."},
{"lineNum":" 1891","line":"    pub fn deleteDirZ(self: Dir, sub_path_c: [*:0]const u8) DeleteDirError!void {"},
{"lineNum":" 1892","line":"        os.unlinkatZ(self.fd, sub_path_c, os.AT.REMOVEDIR) catch |err| switch (err) {"},
{"lineNum":" 1893","line":"            error.IsDir => unreachable, // not possible since we pass AT.REMOVEDIR"},
{"lineNum":" 1894","line":"            else => |e| return e,"},
{"lineNum":" 1895","line":"        };"},
{"lineNum":" 1896","line":"    }"},
{"lineNum":" 1897","line":""},
{"lineNum":" 1898","line":"    /// Same as `deleteDir` except the parameter is UTF16LE, NT prefixed."},
{"lineNum":" 1899","line":"    /// This function is Windows-only."},
{"lineNum":" 1900","line":"    pub fn deleteDirW(self: Dir, sub_path_w: []const u16) DeleteDirError!void {"},
{"lineNum":" 1901","line":"        os.unlinkatW(self.fd, sub_path_w, os.AT.REMOVEDIR) catch |err| switch (err) {"},
{"lineNum":" 1902","line":"            error.IsDir => unreachable, // not possible since we pass AT.REMOVEDIR"},
{"lineNum":" 1903","line":"            else => |e| return e,"},
{"lineNum":" 1904","line":"        };"},
{"lineNum":" 1905","line":"    }"},
{"lineNum":" 1906","line":""},
{"lineNum":" 1907","line":"    pub const RenameError = os.RenameError;"},
{"lineNum":" 1908","line":""},
{"lineNum":" 1909","line":"    /// Change the name or location of a file or directory."},
{"lineNum":" 1910","line":"    /// If new_sub_path already exists, it will be replaced."},
{"lineNum":" 1911","line":"    /// Renaming a file over an existing directory or a directory"},
{"lineNum":" 1912","line":"    /// over an existing file will fail with `error.IsDir` or `error.NotDir`"},
{"lineNum":" 1913","line":"    pub fn rename(self: Dir, old_sub_path: []const u8, new_sub_path: []const u8) RenameError!void {"},
{"lineNum":" 1914","line":"        return os.renameat(self.fd, old_sub_path, self.fd, new_sub_path);"},
{"lineNum":" 1915","line":"    }"},
{"lineNum":" 1916","line":""},
{"lineNum":" 1917","line":"    /// Same as `rename` except the parameters are null-terminated."},
{"lineNum":" 1918","line":"    pub fn renameZ(self: Dir, old_sub_path_z: [*:0]const u8, new_sub_path_z: [*:0]const u8) RenameError!void {"},
{"lineNum":" 1919","line":"        return os.renameatZ(self.fd, old_sub_path_z, self.fd, new_sub_path_z);"},
{"lineNum":" 1920","line":"    }"},
{"lineNum":" 1921","line":""},
{"lineNum":" 1922","line":"    /// Same as `rename` except the parameters are UTF16LE, NT prefixed."},
{"lineNum":" 1923","line":"    /// This function is Windows-only."},
{"lineNum":" 1924","line":"    pub fn renameW(self: Dir, old_sub_path_w: []const u16, new_sub_path_w: []const u16) RenameError!void {"},
{"lineNum":" 1925","line":"        return os.renameatW(self.fd, old_sub_path_w, self.fd, new_sub_path_w);"},
{"lineNum":" 1926","line":"    }"},
{"lineNum":" 1927","line":""},
{"lineNum":" 1928","line":"    /// Creates a symbolic link named `sym_link_path` which contains the string `target_path`."},
{"lineNum":" 1929","line":"    /// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent"},
{"lineNum":" 1930","line":"    /// one; the latter case is known as a dangling link."},
{"lineNum":" 1931","line":"    /// If `sym_link_path` exists, it will not be overwritten."},
{"lineNum":" 1932","line":"    pub fn symLink("},
{"lineNum":" 1933","line":"        self: Dir,"},
{"lineNum":" 1934","line":"        target_path: []const u8,"},
{"lineNum":" 1935","line":"        sym_link_path: []const u8,"},
{"lineNum":" 1936","line":"        flags: SymLinkFlags,"},
{"lineNum":" 1937","line":"    ) !void {"},
{"lineNum":" 1938","line":"        if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1939","line":"            return self.symLinkWasi(target_path, sym_link_path, flags);"},
{"lineNum":" 1940","line":"        }"},
{"lineNum":" 1941","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1942","line":"            const target_path_w = try os.windows.sliceToPrefixedFileW(target_path);"},
{"lineNum":" 1943","line":"            const sym_link_path_w = try os.windows.sliceToPrefixedFileW(sym_link_path);"},
{"lineNum":" 1944","line":"            return self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);"},
{"lineNum":" 1945","line":"        }"},
{"lineNum":" 1946","line":"        const target_path_c = try os.toPosixPath(target_path);"},
{"lineNum":" 1947","line":"        const sym_link_path_c = try os.toPosixPath(sym_link_path);"},
{"lineNum":" 1948","line":"        return self.symLinkZ(&target_path_c, &sym_link_path_c, flags);"},
{"lineNum":" 1949","line":"    }"},
{"lineNum":" 1950","line":""},
{"lineNum":" 1951","line":"    /// WASI-only. Same as `symLink` except targeting WASI."},
{"lineNum":" 1952","line":"    pub fn symLinkWasi("},
{"lineNum":" 1953","line":"        self: Dir,"},
{"lineNum":" 1954","line":"        target_path: []const u8,"},
{"lineNum":" 1955","line":"        sym_link_path: []const u8,"},
{"lineNum":" 1956","line":"        _: SymLinkFlags,"},
{"lineNum":" 1957","line":"    ) !void {"},
{"lineNum":" 1958","line":"        return os.symlinkat(target_path, self.fd, sym_link_path);"},
{"lineNum":" 1959","line":"    }"},
{"lineNum":" 1960","line":""},
{"lineNum":" 1961","line":"    /// Same as `symLink`, except the pathname parameters are null-terminated."},
{"lineNum":" 1962","line":"    pub fn symLinkZ("},
{"lineNum":" 1963","line":"        self: Dir,"},
{"lineNum":" 1964","line":"        target_path_c: [*:0]const u8,"},
{"lineNum":" 1965","line":"        sym_link_path_c: [*:0]const u8,"},
{"lineNum":" 1966","line":"        flags: SymLinkFlags,"},
{"lineNum":" 1967","line":"    ) !void {"},
{"lineNum":" 1968","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1969","line":"            const target_path_w = try os.windows.cStrToPrefixedFileW(target_path_c);"},
{"lineNum":" 1970","line":"            const sym_link_path_w = try os.windows.cStrToPrefixedFileW(sym_link_path_c);"},
{"lineNum":" 1971","line":"            return self.symLinkW(target_path_w.span(), sym_link_path_w.span(), flags);"},
{"lineNum":" 1972","line":"        }"},
{"lineNum":" 1973","line":"        return os.symlinkatZ(target_path_c, self.fd, sym_link_path_c);"},
{"lineNum":" 1974","line":"    }"},
{"lineNum":" 1975","line":""},
{"lineNum":" 1976","line":"    /// Windows-only. Same as `symLink` except the pathname parameters"},
{"lineNum":" 1977","line":"    /// are null-terminated, WTF16 encoded."},
{"lineNum":" 1978","line":"    pub fn symLinkW("},
{"lineNum":" 1979","line":"        self: Dir,"},
{"lineNum":" 1980","line":"        target_path_w: []const u16,"},
{"lineNum":" 1981","line":"        sym_link_path_w: []const u16,"},
{"lineNum":" 1982","line":"        flags: SymLinkFlags,"},
{"lineNum":" 1983","line":"    ) !void {"},
{"lineNum":" 1984","line":"        return os.windows.CreateSymbolicLink(self.fd, sym_link_path_w, target_path_w, flags.is_directory);"},
{"lineNum":" 1985","line":"    }"},
{"lineNum":" 1986","line":""},
{"lineNum":" 1987","line":"    /// Read value of a symbolic link."},
{"lineNum":" 1988","line":"    /// The return value is a slice of `buffer`, from index `0`."},
{"lineNum":" 1989","line":"    /// Asserts that the path parameter has no null bytes."},
{"lineNum":" 1990","line":"    pub fn readLink(self: Dir, sub_path: []const u8, buffer: []u8) ![]u8 {"},
{"lineNum":" 1991","line":"        if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1992","line":"            return self.readLinkWasi(sub_path, buffer);"},
{"lineNum":" 1993","line":"        }"},
{"lineNum":" 1994","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 1995","line":"            const sub_path_w = try os.windows.sliceToPrefixedFileW(sub_path);"},
{"lineNum":" 1996","line":"            return self.readLinkW(sub_path_w.span(), buffer);"},
{"lineNum":" 1997","line":"        }"},
{"lineNum":" 1998","line":"        const sub_path_c = try os.toPosixPath(sub_path);"},
{"lineNum":" 1999","line":"        return self.readLinkZ(&sub_path_c, buffer);"},
{"lineNum":" 2000","line":"    }"},
{"lineNum":" 2001","line":""},
{"lineNum":" 2002","line":"    /// WASI-only. Same as `readLink` except targeting WASI."},
{"lineNum":" 2003","line":"    pub fn readLinkWasi(self: Dir, sub_path: []const u8, buffer: []u8) ![]u8 {"},
{"lineNum":" 2004","line":"        return os.readlinkat(self.fd, sub_path, buffer);"},
{"lineNum":" 2005","line":"    }"},
{"lineNum":" 2006","line":""},
{"lineNum":" 2007","line":"    /// Same as `readLink`, except the `pathname` parameter is null-terminated."},
{"lineNum":" 2008","line":"    pub fn readLinkZ(self: Dir, sub_path_c: [*:0]const u8, buffer: []u8) ![]u8 {"},
{"lineNum":" 2009","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 2010","line":"            const sub_path_w = try os.windows.cStrToPrefixedFileW(sub_path_c);"},
{"lineNum":" 2011","line":"            return self.readLinkW(sub_path_w.span(), buffer);"},
{"lineNum":" 2012","line":"        }"},
{"lineNum":" 2013","line":"        return os.readlinkatZ(self.fd, sub_path_c, buffer);"},
{"lineNum":" 2014","line":"    }"},
{"lineNum":" 2015","line":""},
{"lineNum":" 2016","line":"    /// Windows-only. Same as `readLink` except the pathname parameter"},
{"lineNum":" 2017","line":"    /// is null-terminated, WTF16 encoded."},
{"lineNum":" 2018","line":"    pub fn readLinkW(self: Dir, sub_path_w: []const u16, buffer: []u8) ![]u8 {"},
{"lineNum":" 2019","line":"        return os.windows.ReadLink(self.fd, sub_path_w, buffer);"},
{"lineNum":" 2020","line":"    }"},
{"lineNum":" 2021","line":""},
{"lineNum":" 2022","line":"    /// Read all of file contents using a preallocated buffer."},
{"lineNum":" 2023","line":"    /// The returned slice has the same pointer as `buffer`. If the length matches `buffer.len`"},
{"lineNum":" 2024","line":"    /// the situation is ambiguous. It could either mean that the entire file was read, and"},
{"lineNum":" 2025","line":"    /// it exactly fits the buffer, or it could mean the buffer was not big enough for the"},
{"lineNum":" 2026","line":"    /// entire file."},
{"lineNum":" 2027","line":"    pub fn readFile(self: Dir, file_path: []const u8, buffer: []u8) ![]u8 {"},
{"lineNum":" 2028","line":"        var file = try self.openFile(file_path, .{});"},
{"lineNum":" 2029","line":"        defer file.close();"},
{"lineNum":" 2030","line":""},
{"lineNum":" 2031","line":"        const end_index = try file.readAll(buffer);"},
{"lineNum":" 2032","line":"        return buffer[0..end_index];"},
{"lineNum":" 2033","line":"    }"},
{"lineNum":" 2034","line":""},
{"lineNum":" 2035","line":"    /// On success, caller owns returned buffer."},
{"lineNum":" 2036","line":"    /// If the file is larger than `max_bytes`, returns `error.FileTooBig`."},
{"lineNum":" 2037","line":"    pub fn readFileAlloc(self: Dir, allocator: mem.Allocator, file_path: []const u8, max_bytes: usize) ![]u8 {"},
{"lineNum":" 2038","line":"        return self.readFileAllocOptions(allocator, file_path, max_bytes, null, @alignOf(u8), null);"},
{"lineNum":" 2039","line":"    }"},
{"lineNum":" 2040","line":""},
{"lineNum":" 2041","line":"    /// On success, caller owns returned buffer."},
{"lineNum":" 2042","line":"    /// If the file is larger than `max_bytes`, returns `error.FileTooBig`."},
{"lineNum":" 2043","line":"    /// If `size_hint` is specified the initial buffer size is calculated using"},
{"lineNum":" 2044","line":"    /// that value, otherwise the effective file size is used instead."},
{"lineNum":" 2045","line":"    /// Allows specifying alignment and a sentinel value."},
{"lineNum":" 2046","line":"    pub fn readFileAllocOptions("},
{"lineNum":" 2047","line":"        self: Dir,"},
{"lineNum":" 2048","line":"        allocator: mem.Allocator,"},
{"lineNum":" 2049","line":"        file_path: []const u8,"},
{"lineNum":" 2050","line":"        max_bytes: usize,"},
{"lineNum":" 2051","line":"        size_hint: ?usize,"},
{"lineNum":" 2052","line":"        comptime alignment: u29,"},
{"lineNum":" 2053","line":"        comptime optional_sentinel: ?u8,"},
{"lineNum":" 2054","line":"    ) !(if (optional_sentinel) |s| [:s]align(alignment) u8 else []align(alignment) u8) {"},
{"lineNum":" 2055","line":"        var file = try self.openFile(file_path, .{});"},
{"lineNum":" 2056","line":"        defer file.close();"},
{"lineNum":" 2057","line":""},
{"lineNum":" 2058","line":"        // If the file size doesn\'t fit a usize it\'ll be certainly greater than"},
{"lineNum":" 2059","line":"        // `max_bytes`"},
{"lineNum":" 2060","line":"        const stat_size = size_hint orelse math.cast(usize, try file.getEndPos()) orelse"},
{"lineNum":" 2061","line":"            return error.FileTooBig;"},
{"lineNum":" 2062","line":""},
{"lineNum":" 2063","line":"        return file.readToEndAllocOptions(allocator, max_bytes, stat_size, alignment, optional_sentinel);"},
{"lineNum":" 2064","line":"    }"},
{"lineNum":" 2065","line":""},
{"lineNum":" 2066","line":"    pub const DeleteTreeError = error{"},
{"lineNum":" 2067","line":"        InvalidHandle,"},
{"lineNum":" 2068","line":"        AccessDenied,"},
{"lineNum":" 2069","line":"        FileTooBig,"},
{"lineNum":" 2070","line":"        SymLinkLoop,"},
{"lineNum":" 2071","line":"        ProcessFdQuotaExceeded,"},
{"lineNum":" 2072","line":"        NameTooLong,"},
{"lineNum":" 2073","line":"        SystemFdQuotaExceeded,"},
{"lineNum":" 2074","line":"        NoDevice,"},
{"lineNum":" 2075","line":"        SystemResources,"},
{"lineNum":" 2076","line":"        ReadOnlyFileSystem,"},
{"lineNum":" 2077","line":"        FileSystem,"},
{"lineNum":" 2078","line":"        FileBusy,"},
{"lineNum":" 2079","line":"        DeviceBusy,"},
{"lineNum":" 2080","line":""},
{"lineNum":" 2081","line":"        /// One of the path components was not a directory."},
{"lineNum":" 2082","line":"        /// This error is unreachable if `sub_path` does not contain a path separator."},
{"lineNum":" 2083","line":"        NotDir,"},
{"lineNum":" 2084","line":""},
{"lineNum":" 2085","line":"        /// On Windows, file paths must be valid Unicode."},
{"lineNum":" 2086","line":"        InvalidUtf8,"},
{"lineNum":" 2087","line":""},
{"lineNum":" 2088","line":"        /// On Windows, file paths cannot contain these characters:"},
{"lineNum":" 2089","line":"        /// \'/\', \'*\', \'?\', \'\"\', \'<\', \'>\', \'|\'"},
{"lineNum":" 2090","line":"        BadPathName,"},
{"lineNum":" 2091","line":"    } || os.UnexpectedError;"},
{"lineNum":" 2092","line":""},
{"lineNum":" 2093","line":"    /// Whether `full_path` describes a symlink, file, or directory, this function"},
{"lineNum":" 2094","line":"    /// removes it. If it cannot be removed because it is a non-empty directory,"},
{"lineNum":" 2095","line":"    /// this function recursively removes its entries and then tries again."},
{"lineNum":" 2096","line":"    /// This operation is not atomic on most file systems."},
{"lineNum":" 2097","line":"    pub fn deleteTree(self: Dir, sub_path: []const u8) DeleteTreeError!void {"},
{"lineNum":" 2098","line":"        var initial_iterable_dir = (try self.deleteTreeOpenInitialSubpath(sub_path, .File)) orelse return;"},
{"lineNum":" 2099","line":""},
{"lineNum":" 2100","line":"        const StackItem = struct {"},
{"lineNum":" 2101","line":"            name: []const u8,"},
{"lineNum":" 2102","line":"            parent_dir: Dir,"},
{"lineNum":" 2103","line":"            iter: IterableDir.Iterator,"},
{"lineNum":" 2104","line":"        };"},
{"lineNum":" 2105","line":""},
{"lineNum":" 2106","line":"        var stack = std.BoundedArray(StackItem, 16){};"},
{"lineNum":" 2107","line":"        defer {"},
{"lineNum":" 2108","line":"            for (stack.slice()) |*item| {"},
{"lineNum":" 2109","line":"                item.iter.dir.close();"},
{"lineNum":" 2110","line":"            }"},
{"lineNum":" 2111","line":"        }"},
{"lineNum":" 2112","line":""},
{"lineNum":" 2113","line":"        stack.appendAssumeCapacity(StackItem{"},
{"lineNum":" 2114","line":"            .name = sub_path,"},
{"lineNum":" 2115","line":"            .parent_dir = self,"},
{"lineNum":" 2116","line":"            .iter = initial_iterable_dir.iterateAssumeFirstIteration(),"},
{"lineNum":" 2117","line":"        });"},
{"lineNum":" 2118","line":""},
{"lineNum":" 2119","line":"        process_stack: while (stack.len != 0) {"},
{"lineNum":" 2120","line":"            var top = &(stack.slice()[stack.len - 1]);"},
{"lineNum":" 2121","line":"            while (try top.iter.next()) |entry| {"},
{"lineNum":" 2122","line":"                var treat_as_dir = entry.kind == .Directory;"},
{"lineNum":" 2123","line":"                handle_entry: while (true) {"},
{"lineNum":" 2124","line":"                    if (treat_as_dir) {"},
{"lineNum":" 2125","line":"                        if (stack.ensureUnusedCapacity(1)) {"},
{"lineNum":" 2126","line":"                            var iterable_dir = top.iter.dir.openIterableDir(entry.name, .{ .no_follow = true }) catch |err| switch (err) {"},
{"lineNum":" 2127","line":"                                error.NotDir => {"},
{"lineNum":" 2128","line":"                                    treat_as_dir = false;"},
{"lineNum":" 2129","line":"                                    continue :handle_entry;"},
{"lineNum":" 2130","line":"                                },"},
{"lineNum":" 2131","line":"                                error.FileNotFound => {"},
{"lineNum":" 2132","line":"                                    // That\'s fine, we were trying to remove this directory anyway."},
{"lineNum":" 2133","line":"                                    break :handle_entry;"},
{"lineNum":" 2134","line":"                                },"},
{"lineNum":" 2135","line":""},
{"lineNum":" 2136","line":"                                error.InvalidHandle,"},
{"lineNum":" 2137","line":"                                error.AccessDenied,"},
{"lineNum":" 2138","line":"                                error.SymLinkLoop,"},
{"lineNum":" 2139","line":"                                error.ProcessFdQuotaExceeded,"},
{"lineNum":" 2140","line":"                                error.NameTooLong,"},
{"lineNum":" 2141","line":"                                error.SystemFdQuotaExceeded,"},
{"lineNum":" 2142","line":"                                error.NoDevice,"},
{"lineNum":" 2143","line":"                                error.SystemResources,"},
{"lineNum":" 2144","line":"                                error.Unexpected,"},
{"lineNum":" 2145","line":"                                error.InvalidUtf8,"},
{"lineNum":" 2146","line":"                                error.BadPathName,"},
{"lineNum":" 2147","line":"                                error.DeviceBusy,"},
{"lineNum":" 2148","line":"                                => |e| return e,"},
{"lineNum":" 2149","line":"                            };"},
{"lineNum":" 2150","line":"                            stack.appendAssumeCapacity(StackItem{"},
{"lineNum":" 2151","line":"                                .name = entry.name,"},
{"lineNum":" 2152","line":"                                .parent_dir = top.iter.dir,"},
{"lineNum":" 2153","line":"                                .iter = iterable_dir.iterateAssumeFirstIteration(),"},
{"lineNum":" 2154","line":"                            });"},
{"lineNum":" 2155","line":"                            continue :process_stack;"},
{"lineNum":" 2156","line":"                        } else |_| {"},
{"lineNum":" 2157","line":"                            try top.iter.dir.deleteTreeMinStackSizeWithKindHint(entry.name, entry.kind);"},
{"lineNum":" 2158","line":"                            break :handle_entry;"},
{"lineNum":" 2159","line":"                        }"},
{"lineNum":" 2160","line":"                    } else {"},
{"lineNum":" 2161","line":"                        if (top.iter.dir.deleteFile(entry.name)) {"},
{"lineNum":" 2162","line":"                            break :handle_entry;"},
{"lineNum":" 2163","line":"                        } else |err| switch (err) {"},
{"lineNum":" 2164","line":"                            error.FileNotFound => break :handle_entry,"},
{"lineNum":" 2165","line":""},
{"lineNum":" 2166","line":"                            // Impossible because we do not pass any path separators."},
{"lineNum":" 2167","line":"                            error.NotDir => unreachable,"},
{"lineNum":" 2168","line":""},
{"lineNum":" 2169","line":"                            error.IsDir => {"},
{"lineNum":" 2170","line":"                                treat_as_dir = true;"},
{"lineNum":" 2171","line":"                                continue :handle_entry;"},
{"lineNum":" 2172","line":"                            },"},
{"lineNum":" 2173","line":""},
{"lineNum":" 2174","line":"                            error.AccessDenied,"},
{"lineNum":" 2175","line":"                            error.InvalidUtf8,"},
{"lineNum":" 2176","line":"                            error.SymLinkLoop,"},
{"lineNum":" 2177","line":"                            error.NameTooLong,"},
{"lineNum":" 2178","line":"                            error.SystemResources,"},
{"lineNum":" 2179","line":"                            error.ReadOnlyFileSystem,"},
{"lineNum":" 2180","line":"                            error.FileSystem,"},
{"lineNum":" 2181","line":"                            error.FileBusy,"},
{"lineNum":" 2182","line":"                            error.BadPathName,"},
{"lineNum":" 2183","line":"                            error.Unexpected,"},
{"lineNum":" 2184","line":"                            => |e| return e,"},
{"lineNum":" 2185","line":"                        }"},
{"lineNum":" 2186","line":"                    }"},
{"lineNum":" 2187","line":"                }"},
{"lineNum":" 2188","line":"            }"},
{"lineNum":" 2189","line":""},
{"lineNum":" 2190","line":"            // On Windows, we can\'t delete until the dir\'s handle has been closed, so"},
{"lineNum":" 2191","line":"            // close it before we try to delete."},
{"lineNum":" 2192","line":"            top.iter.dir.close();"},
{"lineNum":" 2193","line":""},
{"lineNum":" 2194","line":"            // In order to avoid double-closing the directory when cleaning up"},
{"lineNum":" 2195","line":"            // the stack in the case of an error, we save the relevant portions and"},
{"lineNum":" 2196","line":"            // pop the value from the stack."},
{"lineNum":" 2197","line":"            const parent_dir = top.parent_dir;"},
{"lineNum":" 2198","line":"            const name = top.name;"},
{"lineNum":" 2199","line":"            _ = stack.pop();"},
{"lineNum":" 2200","line":""},
{"lineNum":" 2201","line":"            var need_to_retry: bool = false;"},
{"lineNum":" 2202","line":"            parent_dir.deleteDir(name) catch |err| switch (err) {"},
{"lineNum":" 2203","line":"                error.FileNotFound => {},"},
{"lineNum":" 2204","line":"                error.DirNotEmpty => need_to_retry = false,"},
{"lineNum":" 2205","line":"                else => |e| return e,"},
{"lineNum":" 2206","line":"            };"},
{"lineNum":" 2207","line":""},
{"lineNum":" 2208","line":"            if (need_to_retry) {"},
{"lineNum":" 2209","line":"                // Since we closed the handle that the previous iterator used, we"},
{"lineNum":" 2210","line":"                // need to re-open the dir and re-create the iterator."},
{"lineNum":" 2211","line":"                var iterable_dir = iterable_dir: {"},
{"lineNum":" 2212","line":"                    var treat_as_dir = true;"},
{"lineNum":" 2213","line":"                    handle_entry: while (true) {"},
{"lineNum":" 2214","line":"                        if (treat_as_dir) {"},
{"lineNum":" 2215","line":"                            break :iterable_dir parent_dir.openIterableDir(name, .{ .no_follow = true }) catch |err| switch (err) {"},
{"lineNum":" 2216","line":"                                error.NotDir => {"},
{"lineNum":" 2217","line":"                                    treat_as_dir = false;"},
{"lineNum":" 2218","line":"                                    continue :handle_entry;"},
{"lineNum":" 2219","line":"                                },"},
{"lineNum":" 2220","line":"                                error.FileNotFound => {"},
{"lineNum":" 2221","line":"                                    // That\'s fine, we were trying to remove this directory anyway."},
{"lineNum":" 2222","line":"                                    continue :process_stack;"},
{"lineNum":" 2223","line":"                                },"},
{"lineNum":" 2224","line":""},
{"lineNum":" 2225","line":"                                error.InvalidHandle,"},
{"lineNum":" 2226","line":"                                error.AccessDenied,"},
{"lineNum":" 2227","line":"                                error.SymLinkLoop,"},
{"lineNum":" 2228","line":"                                error.ProcessFdQuotaExceeded,"},
{"lineNum":" 2229","line":"                                error.NameTooLong,"},
{"lineNum":" 2230","line":"                                error.SystemFdQuotaExceeded,"},
{"lineNum":" 2231","line":"                                error.NoDevice,"},
{"lineNum":" 2232","line":"                                error.SystemResources,"},
{"lineNum":" 2233","line":"                                error.Unexpected,"},
{"lineNum":" 2234","line":"                                error.InvalidUtf8,"},
{"lineNum":" 2235","line":"                                error.BadPathName,"},
{"lineNum":" 2236","line":"                                error.DeviceBusy,"},
{"lineNum":" 2237","line":"                                => |e| return e,"},
{"lineNum":" 2238","line":"                            };"},
{"lineNum":" 2239","line":"                        } else {"},
{"lineNum":" 2240","line":"                            if (parent_dir.deleteFile(name)) {"},
{"lineNum":" 2241","line":"                                continue :process_stack;"},
{"lineNum":" 2242","line":"                            } else |err| switch (err) {"},
{"lineNum":" 2243","line":"                                error.FileNotFound => continue :process_stack,"},
{"lineNum":" 2244","line":""},
{"lineNum":" 2245","line":"                                // Impossible because we do not pass any path separators."},
{"lineNum":" 2246","line":"                                error.NotDir => unreachable,"},
{"lineNum":" 2247","line":""},
{"lineNum":" 2248","line":"                                error.IsDir => {"},
{"lineNum":" 2249","line":"                                    treat_as_dir = true;"},
{"lineNum":" 2250","line":"                                    continue :handle_entry;"},
{"lineNum":" 2251","line":"                                },"},
{"lineNum":" 2252","line":""},
{"lineNum":" 2253","line":"                                error.AccessDenied,"},
{"lineNum":" 2254","line":"                                error.InvalidUtf8,"},
{"lineNum":" 2255","line":"                                error.SymLinkLoop,"},
{"lineNum":" 2256","line":"                                error.NameTooLong,"},
{"lineNum":" 2257","line":"                                error.SystemResources,"},
{"lineNum":" 2258","line":"                                error.ReadOnlyFileSystem,"},
{"lineNum":" 2259","line":"                                error.FileSystem,"},
{"lineNum":" 2260","line":"                                error.FileBusy,"},
{"lineNum":" 2261","line":"                                error.BadPathName,"},
{"lineNum":" 2262","line":"                                error.Unexpected,"},
{"lineNum":" 2263","line":"                                => |e| return e,"},
{"lineNum":" 2264","line":"                            }"},
{"lineNum":" 2265","line":"                        }"},
{"lineNum":" 2266","line":"                    }"},
{"lineNum":" 2267","line":"                };"},
{"lineNum":" 2268","line":"                // We know there is room on the stack since we are just re-adding"},
{"lineNum":" 2269","line":"                // the StackItem that we previously popped."},
{"lineNum":" 2270","line":"                stack.appendAssumeCapacity(StackItem{"},
{"lineNum":" 2271","line":"                    .name = name,"},
{"lineNum":" 2272","line":"                    .parent_dir = parent_dir,"},
{"lineNum":" 2273","line":"                    .iter = iterable_dir.iterateAssumeFirstIteration(),"},
{"lineNum":" 2274","line":"                });"},
{"lineNum":" 2275","line":"                continue :process_stack;"},
{"lineNum":" 2276","line":"            }"},
{"lineNum":" 2277","line":"        }"},
{"lineNum":" 2278","line":"    }"},
{"lineNum":" 2279","line":""},
{"lineNum":" 2280","line":"    /// Like `deleteTree`, but only keeps one `Iterator` active at a time to minimize the function\'s stack size."},
{"lineNum":" 2281","line":"    /// This is slower than `deleteTree` but uses less stack space."},
{"lineNum":" 2282","line":"    pub fn deleteTreeMinStackSize(self: Dir, sub_path: []const u8) DeleteTreeError!void {"},
{"lineNum":" 2283","line":"        return self.deleteTreeMinStackSizeWithKindHint(sub_path, .File);"},
{"lineNum":" 2284","line":"    }"},
{"lineNum":" 2285","line":""},
{"lineNum":" 2286","line":"    fn deleteTreeMinStackSizeWithKindHint(self: Dir, sub_path: []const u8, kind_hint: File.Kind) DeleteTreeError!void {"},
{"lineNum":" 2287","line":"        start_over: while (true) {"},
{"lineNum":" 2288","line":"            var iterable_dir = (try self.deleteTreeOpenInitialSubpath(sub_path, kind_hint)) orelse return;"},
{"lineNum":" 2289","line":"            var cleanup_dir_parent: ?IterableDir = null;"},
{"lineNum":" 2290","line":"            defer if (cleanup_dir_parent) |*d| d.close();"},
{"lineNum":" 2291","line":""},
{"lineNum":" 2292","line":"            var cleanup_dir = true;"},
{"lineNum":" 2293","line":"            defer if (cleanup_dir) iterable_dir.close();"},
{"lineNum":" 2294","line":""},
{"lineNum":" 2295","line":"            // Valid use of MAX_PATH_BYTES because dir_name_buf will only"},
{"lineNum":" 2296","line":"            // ever store a single path component that was returned from the"},
{"lineNum":" 2297","line":"            // filesystem."},
{"lineNum":" 2298","line":"            var dir_name_buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 2299","line":"            var dir_name: []const u8 = sub_path;"},
{"lineNum":" 2300","line":""},
{"lineNum":" 2301","line":"            // Here we must avoid recursion, in order to provide O(1) memory guarantee of this function."},
{"lineNum":" 2302","line":"            // Go through each entry and if it is not a directory, delete it. If it is a directory,"},
{"lineNum":" 2303","line":"            // open it, and close the original directory. Repeat. Then start the entire operation over."},
{"lineNum":" 2304","line":""},
{"lineNum":" 2305","line":"            scan_dir: while (true) {"},
{"lineNum":" 2306","line":"                var dir_it = iterable_dir.iterateAssumeFirstIteration();"},
{"lineNum":" 2307","line":"                dir_it: while (try dir_it.next()) |entry| {"},
{"lineNum":" 2308","line":"                    var treat_as_dir = entry.kind == .Directory;"},
{"lineNum":" 2309","line":"                    handle_entry: while (true) {"},
{"lineNum":" 2310","line":"                        if (treat_as_dir) {"},
{"lineNum":" 2311","line":"                            const new_dir = iterable_dir.dir.openIterableDir(entry.name, .{ .no_follow = true }) catch |err| switch (err) {"},
{"lineNum":" 2312","line":"                                error.NotDir => {"},
{"lineNum":" 2313","line":"                                    treat_as_dir = false;"},
{"lineNum":" 2314","line":"                                    continue :handle_entry;"},
{"lineNum":" 2315","line":"                                },"},
{"lineNum":" 2316","line":"                                error.FileNotFound => {"},
{"lineNum":" 2317","line":"                                    // That\'s fine, we were trying to remove this directory anyway."},
{"lineNum":" 2318","line":"                                    continue :dir_it;"},
{"lineNum":" 2319","line":"                                },"},
{"lineNum":" 2320","line":""},
{"lineNum":" 2321","line":"                                error.InvalidHandle,"},
{"lineNum":" 2322","line":"                                error.AccessDenied,"},
{"lineNum":" 2323","line":"                                error.SymLinkLoop,"},
{"lineNum":" 2324","line":"                                error.ProcessFdQuotaExceeded,"},
{"lineNum":" 2325","line":"                                error.NameTooLong,"},
{"lineNum":" 2326","line":"                                error.SystemFdQuotaExceeded,"},
{"lineNum":" 2327","line":"                                error.NoDevice,"},
{"lineNum":" 2328","line":"                                error.SystemResources,"},
{"lineNum":" 2329","line":"                                error.Unexpected,"},
{"lineNum":" 2330","line":"                                error.InvalidUtf8,"},
{"lineNum":" 2331","line":"                                error.BadPathName,"},
{"lineNum":" 2332","line":"                                error.DeviceBusy,"},
{"lineNum":" 2333","line":"                                => |e| return e,"},
{"lineNum":" 2334","line":"                            };"},
{"lineNum":" 2335","line":"                            if (cleanup_dir_parent) |*d| d.close();"},
{"lineNum":" 2336","line":"                            cleanup_dir_parent = iterable_dir;"},
{"lineNum":" 2337","line":"                            iterable_dir = new_dir;"},
{"lineNum":" 2338","line":"                            mem.copy(u8, &dir_name_buf, entry.name);"},
{"lineNum":" 2339","line":"                            dir_name = dir_name_buf[0..entry.name.len];"},
{"lineNum":" 2340","line":"                            continue :scan_dir;"},
{"lineNum":" 2341","line":"                        } else {"},
{"lineNum":" 2342","line":"                            if (iterable_dir.dir.deleteFile(entry.name)) {"},
{"lineNum":" 2343","line":"                                continue :dir_it;"},
{"lineNum":" 2344","line":"                            } else |err| switch (err) {"},
{"lineNum":" 2345","line":"                                error.FileNotFound => continue :dir_it,"},
{"lineNum":" 2346","line":""},
{"lineNum":" 2347","line":"                                // Impossible because we do not pass any path separators."},
{"lineNum":" 2348","line":"                                error.NotDir => unreachable,"},
{"lineNum":" 2349","line":""},
{"lineNum":" 2350","line":"                                error.IsDir => {"},
{"lineNum":" 2351","line":"                                    treat_as_dir = true;"},
{"lineNum":" 2352","line":"                                    continue :handle_entry;"},
{"lineNum":" 2353","line":"                                },"},
{"lineNum":" 2354","line":""},
{"lineNum":" 2355","line":"                                error.AccessDenied,"},
{"lineNum":" 2356","line":"                                error.InvalidUtf8,"},
{"lineNum":" 2357","line":"                                error.SymLinkLoop,"},
{"lineNum":" 2358","line":"                                error.NameTooLong,"},
{"lineNum":" 2359","line":"                                error.SystemResources,"},
{"lineNum":" 2360","line":"                                error.ReadOnlyFileSystem,"},
{"lineNum":" 2361","line":"                                error.FileSystem,"},
{"lineNum":" 2362","line":"                                error.FileBusy,"},
{"lineNum":" 2363","line":"                                error.BadPathName,"},
{"lineNum":" 2364","line":"                                error.Unexpected,"},
{"lineNum":" 2365","line":"                                => |e| return e,"},
{"lineNum":" 2366","line":"                            }"},
{"lineNum":" 2367","line":"                        }"},
{"lineNum":" 2368","line":"                    }"},
{"lineNum":" 2369","line":"                }"},
{"lineNum":" 2370","line":"                // Reached the end of the directory entries, which means we successfully deleted all of them."},
{"lineNum":" 2371","line":"                // Now to remove the directory itself."},
{"lineNum":" 2372","line":"                iterable_dir.close();"},
{"lineNum":" 2373","line":"                cleanup_dir = false;"},
{"lineNum":" 2374","line":""},
{"lineNum":" 2375","line":"                if (cleanup_dir_parent) |d| {"},
{"lineNum":" 2376","line":"                    d.dir.deleteDir(dir_name) catch |err| switch (err) {"},
{"lineNum":" 2377","line":"                        // These two things can happen due to file system race conditions."},
{"lineNum":" 2378","line":"                        error.FileNotFound, error.DirNotEmpty => continue :start_over,"},
{"lineNum":" 2379","line":"                        else => |e| return e,"},
{"lineNum":" 2380","line":"                    };"},
{"lineNum":" 2381","line":"                    continue :start_over;"},
{"lineNum":" 2382","line":"                } else {"},
{"lineNum":" 2383","line":"                    self.deleteDir(sub_path) catch |err| switch (err) {"},
{"lineNum":" 2384","line":"                        error.FileNotFound => return,"},
{"lineNum":" 2385","line":"                        error.DirNotEmpty => continue :start_over,"},
{"lineNum":" 2386","line":"                        else => |e| return e,"},
{"lineNum":" 2387","line":"                    };"},
{"lineNum":" 2388","line":"                    return;"},
{"lineNum":" 2389","line":"                }"},
{"lineNum":" 2390","line":"            }"},
{"lineNum":" 2391","line":"        }"},
{"lineNum":" 2392","line":"    }"},
{"lineNum":" 2393","line":""},
{"lineNum":" 2394","line":"    /// On successful delete, returns null."},
{"lineNum":" 2395","line":"    fn deleteTreeOpenInitialSubpath(self: Dir, sub_path: []const u8, kind_hint: File.Kind) !?IterableDir {"},
{"lineNum":" 2396","line":"        return iterable_dir: {"},
{"lineNum":" 2397","line":"            // Treat as a file by default"},
{"lineNum":" 2398","line":"            var treat_as_dir = kind_hint == .Directory;"},
{"lineNum":" 2399","line":""},
{"lineNum":" 2400","line":"            handle_entry: while (true) {"},
{"lineNum":" 2401","line":"                if (treat_as_dir) {"},
{"lineNum":" 2402","line":"                    break :iterable_dir self.openIterableDir(sub_path, .{ .no_follow = true }) catch |err| switch (err) {"},
{"lineNum":" 2403","line":"                        error.NotDir => {"},
{"lineNum":" 2404","line":"                            treat_as_dir = false;"},
{"lineNum":" 2405","line":"                            continue :handle_entry;"},
{"lineNum":" 2406","line":"                        },"},
{"lineNum":" 2407","line":"                        error.FileNotFound => {"},
{"lineNum":" 2408","line":"                            // That\'s fine, we were trying to remove this directory anyway."},
{"lineNum":" 2409","line":"                            return null;"},
{"lineNum":" 2410","line":"                        },"},
{"lineNum":" 2411","line":""},
{"lineNum":" 2412","line":"                        error.InvalidHandle,"},
{"lineNum":" 2413","line":"                        error.AccessDenied,"},
{"lineNum":" 2414","line":"                        error.SymLinkLoop,"},
{"lineNum":" 2415","line":"                        error.ProcessFdQuotaExceeded,"},
{"lineNum":" 2416","line":"                        error.NameTooLong,"},
{"lineNum":" 2417","line":"                        error.SystemFdQuotaExceeded,"},
{"lineNum":" 2418","line":"                        error.NoDevice,"},
{"lineNum":" 2419","line":"                        error.SystemResources,"},
{"lineNum":" 2420","line":"                        error.Unexpected,"},
{"lineNum":" 2421","line":"                        error.InvalidUtf8,"},
{"lineNum":" 2422","line":"                        error.BadPathName,"},
{"lineNum":" 2423","line":"                        error.DeviceBusy,"},
{"lineNum":" 2424","line":"                        => |e| return e,"},
{"lineNum":" 2425","line":"                    };"},
{"lineNum":" 2426","line":"                } else {"},
{"lineNum":" 2427","line":"                    if (self.deleteFile(sub_path)) {"},
{"lineNum":" 2428","line":"                        return null;"},
{"lineNum":" 2429","line":"                    } else |err| switch (err) {"},
{"lineNum":" 2430","line":"                        error.FileNotFound => return null,"},
{"lineNum":" 2431","line":""},
{"lineNum":" 2432","line":"                        error.IsDir => {"},
{"lineNum":" 2433","line":"                            treat_as_dir = true;"},
{"lineNum":" 2434","line":"                            continue :handle_entry;"},
{"lineNum":" 2435","line":"                        },"},
{"lineNum":" 2436","line":""},
{"lineNum":" 2437","line":"                        error.AccessDenied,"},
{"lineNum":" 2438","line":"                        error.InvalidUtf8,"},
{"lineNum":" 2439","line":"                        error.SymLinkLoop,"},
{"lineNum":" 2440","line":"                        error.NameTooLong,"},
{"lineNum":" 2441","line":"                        error.SystemResources,"},
{"lineNum":" 2442","line":"                        error.ReadOnlyFileSystem,"},
{"lineNum":" 2443","line":"                        error.NotDir,"},
{"lineNum":" 2444","line":"                        error.FileSystem,"},
{"lineNum":" 2445","line":"                        error.FileBusy,"},
{"lineNum":" 2446","line":"                        error.BadPathName,"},
{"lineNum":" 2447","line":"                        error.Unexpected,"},
{"lineNum":" 2448","line":"                        => |e| return e,"},
{"lineNum":" 2449","line":"                    }"},
{"lineNum":" 2450","line":"                }"},
{"lineNum":" 2451","line":"            }"},
{"lineNum":" 2452","line":"        };"},
{"lineNum":" 2453","line":"    }"},
{"lineNum":" 2454","line":""},
{"lineNum":" 2455","line":"    /// Writes content to the file system, creating a new file if it does not exist, truncating"},
{"lineNum":" 2456","line":"    /// if it already exists."},
{"lineNum":" 2457","line":"    pub fn writeFile(self: Dir, sub_path: []const u8, data: []const u8) !void {"},
{"lineNum":" 2458","line":"        var file = try self.createFile(sub_path, .{});"},
{"lineNum":" 2459","line":"        defer file.close();"},
{"lineNum":" 2460","line":"        try file.writeAll(data);"},
{"lineNum":" 2461","line":"    }"},
{"lineNum":" 2462","line":""},
{"lineNum":" 2463","line":"    pub const AccessError = os.AccessError;"},
{"lineNum":" 2464","line":""},
{"lineNum":" 2465","line":"    /// Test accessing `path`."},
{"lineNum":" 2466","line":"    /// `path` is UTF8-encoded."},
{"lineNum":" 2467","line":"    /// Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function."},
{"lineNum":" 2468","line":"    /// For example, instead of testing if a file exists and then opening it, just"},
{"lineNum":" 2469","line":"    /// open it and handle the error for file not found."},
{"lineNum":" 2470","line":"    pub fn access(self: Dir, sub_path: []const u8, flags: File.OpenFlags) AccessError!void {"},
{"lineNum":" 2471","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 2472","line":"            const sub_path_w = try os.windows.sliceToPrefixedFileW(sub_path);"},
{"lineNum":" 2473","line":"            return self.accessW(sub_path_w.span().ptr, flags);"},
{"lineNum":" 2474","line":"        }"},
{"lineNum":" 2475","line":"        const path_c = try os.toPosixPath(sub_path);"},
{"lineNum":" 2476","line":"        return self.accessZ(&path_c, flags);"},
{"lineNum":" 2477","line":"    }"},
{"lineNum":" 2478","line":""},
{"lineNum":" 2479","line":"    /// Same as `access` except the path parameter is null-terminated."},
{"lineNum":" 2480","line":"    pub fn accessZ(self: Dir, sub_path: [*:0]const u8, flags: File.OpenFlags) AccessError!void {"},
{"lineNum":" 2481","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 2482","line":"            const sub_path_w = try os.windows.cStrToPrefixedFileW(sub_path);"},
{"lineNum":" 2483","line":"            return self.accessW(sub_path_w.span().ptr, flags);"},
{"lineNum":" 2484","line":"        }"},
{"lineNum":" 2485","line":"        const os_mode = switch (flags.mode) {"},
{"lineNum":" 2486","line":"            .read_only => @as(u32, os.F_OK),"},
{"lineNum":" 2487","line":"            .write_only => @as(u32, os.W_OK),"},
{"lineNum":" 2488","line":"            .read_write => @as(u32, os.R_OK | os.W_OK),"},
{"lineNum":" 2489","line":"        };"},
{"lineNum":" 2490","line":"        const result = if (need_async_thread and flags.intended_io_mode != .blocking)"},
{"lineNum":" 2491","line":"            std.event.Loop.instance.?.faccessatZ(self.fd, sub_path, os_mode, 0)"},
{"lineNum":" 2492","line":"        else"},
{"lineNum":" 2493","line":"            os.faccessatZ(self.fd, sub_path, os_mode, 0);"},
{"lineNum":" 2494","line":"        return result;"},
{"lineNum":" 2495","line":"    }"},
{"lineNum":" 2496","line":""},
{"lineNum":" 2497","line":"    /// Same as `access` except asserts the target OS is Windows and the path parameter is"},
{"lineNum":" 2498","line":"    /// * WTF-16 encoded"},
{"lineNum":" 2499","line":"    /// * null-terminated"},
{"lineNum":" 2500","line":"    /// * NtDll prefixed"},
{"lineNum":" 2501","line":"    /// TODO currently this ignores `flags`."},
{"lineNum":" 2502","line":"    pub fn accessW(self: Dir, sub_path_w: [*:0]const u16, flags: File.OpenFlags) AccessError!void {"},
{"lineNum":" 2503","line":"        _ = flags;"},
{"lineNum":" 2504","line":"        return os.faccessatW(self.fd, sub_path_w, 0, 0);"},
{"lineNum":" 2505","line":"    }"},
{"lineNum":" 2506","line":""},
{"lineNum":" 2507","line":"    /// Check the file size, mtime, and mode of `source_path` and `dest_path`. If they are equal, does nothing."},
{"lineNum":" 2508","line":"    /// Otherwise, atomically copies `source_path` to `dest_path`. The destination file gains the mtime,"},
{"lineNum":" 2509","line":"    /// atime, and mode of the source file so that the next call to `updateFile` will not need a copy."},
{"lineNum":" 2510","line":"    /// Returns the previous status of the file before updating."},
{"lineNum":" 2511","line":"    /// If any of the directories do not exist for dest_path, they are created."},
{"lineNum":" 2512","line":"    pub fn updateFile("},
{"lineNum":" 2513","line":"        source_dir: Dir,"},
{"lineNum":" 2514","line":"        source_path: []const u8,"},
{"lineNum":" 2515","line":"        dest_dir: Dir,"},
{"lineNum":" 2516","line":"        dest_path: []const u8,"},
{"lineNum":" 2517","line":"        options: CopyFileOptions,"},
{"lineNum":" 2518","line":"    ) !PrevStatus {"},
{"lineNum":" 2519","line":"        var src_file = try source_dir.openFile(source_path, .{});"},
{"lineNum":" 2520","line":"        defer src_file.close();"},
{"lineNum":" 2521","line":""},
{"lineNum":" 2522","line":"        const src_stat = try src_file.stat();"},
{"lineNum":" 2523","line":"        const actual_mode = options.override_mode orelse src_stat.mode;"},
{"lineNum":" 2524","line":"        check_dest_stat: {"},
{"lineNum":" 2525","line":"            const dest_stat = blk: {"},
{"lineNum":" 2526","line":"                var dest_file = dest_dir.openFile(dest_path, .{}) catch |err| switch (err) {"},
{"lineNum":" 2527","line":"                    error.FileNotFound => break :check_dest_stat,"},
{"lineNum":" 2528","line":"                    else => |e| return e,"},
{"lineNum":" 2529","line":"                };"},
{"lineNum":" 2530","line":"                defer dest_file.close();"},
{"lineNum":" 2531","line":""},
{"lineNum":" 2532","line":"                break :blk try dest_file.stat();"},
{"lineNum":" 2533","line":"            };"},
{"lineNum":" 2534","line":""},
{"lineNum":" 2535","line":"            if (src_stat.size == dest_stat.size and"},
{"lineNum":" 2536","line":"                src_stat.mtime == dest_stat.mtime and"},
{"lineNum":" 2537","line":"                actual_mode == dest_stat.mode)"},
{"lineNum":" 2538","line":"            {"},
{"lineNum":" 2539","line":"                return PrevStatus.fresh;"},
{"lineNum":" 2540","line":"            }"},
{"lineNum":" 2541","line":"        }"},
{"lineNum":" 2542","line":""},
{"lineNum":" 2543","line":"        if (path.dirname(dest_path)) |dirname| {"},
{"lineNum":" 2544","line":"            try dest_dir.makePath(dirname);"},
{"lineNum":" 2545","line":"        }"},
{"lineNum":" 2546","line":""},
{"lineNum":" 2547","line":"        var atomic_file = try dest_dir.atomicFile(dest_path, .{ .mode = actual_mode });"},
{"lineNum":" 2548","line":"        defer atomic_file.deinit();"},
{"lineNum":" 2549","line":""},
{"lineNum":" 2550","line":"        try atomic_file.file.writeFileAll(src_file, .{ .in_len = src_stat.size });"},
{"lineNum":" 2551","line":"        try atomic_file.file.updateTimes(src_stat.atime, src_stat.mtime);"},
{"lineNum":" 2552","line":"        try atomic_file.finish();"},
{"lineNum":" 2553","line":"        return PrevStatus.stale;"},
{"lineNum":" 2554","line":"    }"},
{"lineNum":" 2555","line":""},
{"lineNum":" 2556","line":"    pub const CopyFileError = File.OpenError || File.StatError || AtomicFile.InitError || CopyFileRawError || AtomicFile.FinishError;"},
{"lineNum":" 2557","line":""},
{"lineNum":" 2558","line":"    /// Guaranteed to be atomic."},
{"lineNum":" 2559","line":"    /// On Linux, until https://patchwork.kernel.org/patch/9636735/ is merged and readily available,"},
{"lineNum":" 2560","line":"    /// there is a possibility of power loss or application termination leaving temporary files present"},
{"lineNum":" 2561","line":"    /// in the same directory as dest_path."},
{"lineNum":" 2562","line":"    pub fn copyFile(source_dir: Dir, source_path: []const u8, dest_dir: Dir, dest_path: []const u8, options: CopyFileOptions) CopyFileError!void {"},
{"lineNum":" 2563","line":"        var in_file = try source_dir.openFile(source_path, .{});"},
{"lineNum":" 2564","line":"        defer in_file.close();"},
{"lineNum":" 2565","line":""},
{"lineNum":" 2566","line":"        var size: ?u64 = null;"},
{"lineNum":" 2567","line":"        const mode = options.override_mode orelse blk: {"},
{"lineNum":" 2568","line":"            const st = try in_file.stat();"},
{"lineNum":" 2569","line":"            size = st.size;"},
{"lineNum":" 2570","line":"            break :blk st.mode;"},
{"lineNum":" 2571","line":"        };"},
{"lineNum":" 2572","line":""},
{"lineNum":" 2573","line":"        var atomic_file = try dest_dir.atomicFile(dest_path, .{ .mode = mode });"},
{"lineNum":" 2574","line":"        defer atomic_file.deinit();"},
{"lineNum":" 2575","line":""},
{"lineNum":" 2576","line":"        try copy_file(in_file.handle, atomic_file.file.handle, size);"},
{"lineNum":" 2577","line":"        try atomic_file.finish();"},
{"lineNum":" 2578","line":"    }"},
{"lineNum":" 2579","line":""},
{"lineNum":" 2580","line":"    pub const AtomicFileOptions = struct {"},
{"lineNum":" 2581","line":"        mode: File.Mode = File.default_mode,"},
{"lineNum":" 2582","line":"    };"},
{"lineNum":" 2583","line":""},
{"lineNum":" 2584","line":"    /// Directly access the `.file` field, and then call `AtomicFile.finish`"},
{"lineNum":" 2585","line":"    /// to atomically replace `dest_path` with contents."},
{"lineNum":" 2586","line":"    /// Always call `AtomicFile.deinit` to clean up, regardless of whether `AtomicFile.finish` succeeded."},
{"lineNum":" 2587","line":"    /// `dest_path` must remain valid until `AtomicFile.deinit` is called."},
{"lineNum":" 2588","line":"    pub fn atomicFile(self: Dir, dest_path: []const u8, options: AtomicFileOptions) !AtomicFile {"},
{"lineNum":" 2589","line":"        if (path.dirname(dest_path)) |dirname| {"},
{"lineNum":" 2590","line":"            const dir = try self.openDir(dirname, .{});"},
{"lineNum":" 2591","line":"            return AtomicFile.init(path.basename(dest_path), options.mode, dir, true);"},
{"lineNum":" 2592","line":"        } else {"},
{"lineNum":" 2593","line":"            return AtomicFile.init(dest_path, options.mode, self, false);"},
{"lineNum":" 2594","line":"        }"},
{"lineNum":" 2595","line":"    }"},
{"lineNum":" 2596","line":""},
{"lineNum":" 2597","line":"    pub const Stat = File.Stat;"},
{"lineNum":" 2598","line":"    pub const StatError = File.StatError;"},
{"lineNum":" 2599","line":""},
{"lineNum":" 2600","line":"    pub fn stat(self: Dir) StatError!Stat {"},
{"lineNum":" 2601","line":"        const file: File = .{"},
{"lineNum":" 2602","line":"            .handle = self.fd,"},
{"lineNum":" 2603","line":"            .capable_io_mode = .blocking,"},
{"lineNum":" 2604","line":"        };"},
{"lineNum":" 2605","line":"        return file.stat();"},
{"lineNum":" 2606","line":"    }"},
{"lineNum":" 2607","line":""},
{"lineNum":" 2608","line":"    pub const StatFileError = File.OpenError || File.StatError || os.FStatAtError;"},
{"lineNum":" 2609","line":""},
{"lineNum":" 2610","line":"    /// Returns metadata for a file inside the directory."},
{"lineNum":" 2611","line":"    ///"},
{"lineNum":" 2612","line":"    /// On Windows, this requires three syscalls. On other operating systems, it"},
{"lineNum":" 2613","line":"    /// only takes one."},
{"lineNum":" 2614","line":"    ///"},
{"lineNum":" 2615","line":"    /// Symlinks are followed."},
{"lineNum":" 2616","line":"    ///"},
{"lineNum":" 2617","line":"    /// `sub_path` may be absolute, in which case `self` is ignored."},
{"lineNum":" 2618","line":"    pub fn statFile(self: Dir, sub_path: []const u8) StatFileError!Stat {"},
{"lineNum":" 2619","line":"        switch (builtin.os.tag) {"},
{"lineNum":" 2620","line":"            .windows => {"},
{"lineNum":" 2621","line":"                var file = try self.openFile(sub_path, .{});"},
{"lineNum":" 2622","line":"                defer file.close();"},
{"lineNum":" 2623","line":"                return file.stat();"},
{"lineNum":" 2624","line":"            },"},
{"lineNum":" 2625","line":"            .wasi => {"},
{"lineNum":" 2626","line":"                const st = try os.fstatatWasi(self.fd, sub_path, os.wasi.LOOKUP_SYMLINK_FOLLOW);"},
{"lineNum":" 2627","line":"                return Stat.fromSystem(st);"},
{"lineNum":" 2628","line":"            },"},
{"lineNum":" 2629","line":"            else => {"},
{"lineNum":" 2630","line":"                const st = try os.fstatat(self.fd, sub_path, 0);"},
{"lineNum":" 2631","line":"                return Stat.fromSystem(st);"},
{"lineNum":" 2632","line":"            },"},
{"lineNum":" 2633","line":"        }"},
{"lineNum":" 2634","line":"    }"},
{"lineNum":" 2635","line":""},
{"lineNum":" 2636","line":"    const Permissions = File.Permissions;"},
{"lineNum":" 2637","line":"    pub const SetPermissionsError = File.SetPermissionsError;"},
{"lineNum":" 2638","line":""},
{"lineNum":" 2639","line":"    /// Sets permissions according to the provided `Permissions` struct."},
{"lineNum":" 2640","line":"    /// This method is *NOT* available on WASI"},
{"lineNum":" 2641","line":"    pub fn setPermissions(self: Dir, permissions: Permissions) SetPermissionsError!void {"},
{"lineNum":" 2642","line":"        const file: File = .{"},
{"lineNum":" 2643","line":"            .handle = self.fd,"},
{"lineNum":" 2644","line":"            .capable_io_mode = .blocking,"},
{"lineNum":" 2645","line":"        };"},
{"lineNum":" 2646","line":"        try file.setPermissions(permissions);"},
{"lineNum":" 2647","line":"    }"},
{"lineNum":" 2648","line":""},
{"lineNum":" 2649","line":"    const Metadata = File.Metadata;"},
{"lineNum":" 2650","line":"    pub const MetadataError = File.MetadataError;"},
{"lineNum":" 2651","line":""},
{"lineNum":" 2652","line":"    /// Returns a `Metadata` struct, representing the permissions on the directory"},
{"lineNum":" 2653","line":"    pub fn metadata(self: Dir) MetadataError!Metadata {"},
{"lineNum":" 2654","line":"        const file: File = .{"},
{"lineNum":" 2655","line":"            .handle = self.fd,"},
{"lineNum":" 2656","line":"            .capable_io_mode = .blocking,"},
{"lineNum":" 2657","line":"        };"},
{"lineNum":" 2658","line":"        return try file.metadata();"},
{"lineNum":" 2659","line":"    }"},
{"lineNum":" 2660","line":"};"},
{"lineNum":" 2661","line":""},
{"lineNum":" 2662","line":"/// Returns a handle to the current working directory. It is not opened with iteration capability."},
{"lineNum":" 2663","line":"/// Closing the returned `Dir` is checked illegal behavior. Iterating over the result is illegal behavior."},
{"lineNum":" 2664","line":"/// On POSIX targets, this function is comptime-callable."},
{"lineNum":" 2665","line":"pub fn cwd() Dir {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2666","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2667","line":"        return Dir{ .fd = os.windows.peb().ProcessParameters.CurrentDirectory.Handle };"},
{"lineNum":" 2668","line":"    } else if (builtin.os.tag == .wasi) {"},
{"lineNum":" 2669","line":"        return std.options.wasiCwd();"},
{"lineNum":" 2670","line":"    } else {"},
{"lineNum":" 2671","line":"        return Dir{ .fd = os.AT.FDCWD };","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2672","line":"    }"},
{"lineNum":" 2673","line":"}"},
{"lineNum":" 2674","line":""},
{"lineNum":" 2675","line":"pub fn defaultWasiCwd() Dir {"},
{"lineNum":" 2676","line":"    // Expect the first preopen to be current working directory."},
{"lineNum":" 2677","line":"    return .{ .fd = 3 };"},
{"lineNum":" 2678","line":"}"},
{"lineNum":" 2679","line":""},
{"lineNum":" 2680","line":"/// Opens a directory at the given path. The directory is a system resource that remains"},
{"lineNum":" 2681","line":"/// open until `close` is called on the result."},
{"lineNum":" 2682","line":"/// See `openDirAbsoluteZ` for a function that accepts a null-terminated path."},
{"lineNum":" 2683","line":"///"},
{"lineNum":" 2684","line":"/// Asserts that the path parameter has no null bytes."},
{"lineNum":" 2685","line":"pub fn openDirAbsolute(absolute_path: []const u8, flags: Dir.OpenDirOptions) File.OpenError!Dir {"},
{"lineNum":" 2686","line":"    assert(path.isAbsolute(absolute_path));"},
{"lineNum":" 2687","line":"    return cwd().openDir(absolute_path, flags);"},
{"lineNum":" 2688","line":"}"},
{"lineNum":" 2689","line":""},
{"lineNum":" 2690","line":"/// Same as `openDirAbsolute` but the path parameter is null-terminated."},
{"lineNum":" 2691","line":"pub fn openDirAbsoluteZ(absolute_path_c: [*:0]const u8, flags: Dir.OpenDirOptions) File.OpenError!Dir {"},
{"lineNum":" 2692","line":"    assert(path.isAbsoluteZ(absolute_path_c));"},
{"lineNum":" 2693","line":"    return cwd().openDirZ(absolute_path_c, flags, false);"},
{"lineNum":" 2694","line":"}"},
{"lineNum":" 2695","line":"/// Same as `openDirAbsolute` but the path parameter is null-terminated."},
{"lineNum":" 2696","line":"pub fn openDirAbsoluteW(absolute_path_c: [*:0]const u16, flags: Dir.OpenDirOptions) File.OpenError!Dir {"},
{"lineNum":" 2697","line":"    assert(path.isAbsoluteWindowsW(absolute_path_c));"},
{"lineNum":" 2698","line":"    return cwd().openDirW(absolute_path_c, flags, false);"},
{"lineNum":" 2699","line":"}"},
{"lineNum":" 2700","line":""},
{"lineNum":" 2701","line":"/// Opens a directory at the given path. The directory is a system resource that remains"},
{"lineNum":" 2702","line":"/// open until `close` is called on the result."},
{"lineNum":" 2703","line":"/// See `openIterableDirAbsoluteZ` for a function that accepts a null-terminated path."},
{"lineNum":" 2704","line":"///"},
{"lineNum":" 2705","line":"/// Asserts that the path parameter has no null bytes."},
{"lineNum":" 2706","line":"pub fn openIterableDirAbsolute(absolute_path: []const u8, flags: Dir.OpenDirOptions) File.OpenError!IterableDir {"},
{"lineNum":" 2707","line":"    assert(path.isAbsolute(absolute_path));"},
{"lineNum":" 2708","line":"    return cwd().openIterableDir(absolute_path, flags);"},
{"lineNum":" 2709","line":"}"},
{"lineNum":" 2710","line":""},
{"lineNum":" 2711","line":"/// Same as `openIterableDirAbsolute` but the path parameter is null-terminated."},
{"lineNum":" 2712","line":"pub fn openIterableDirAbsoluteZ(absolute_path_c: [*:0]const u8, flags: Dir.OpenDirOptions) File.OpenError!IterableDir {"},
{"lineNum":" 2713","line":"    assert(path.isAbsoluteZ(absolute_path_c));"},
{"lineNum":" 2714","line":"    return IterableDir{ .dir = try cwd().openDirZ(absolute_path_c, flags, true) };"},
{"lineNum":" 2715","line":"}"},
{"lineNum":" 2716","line":"/// Same as `openIterableDirAbsolute` but the path parameter is null-terminated."},
{"lineNum":" 2717","line":"pub fn openIterableDirAbsoluteW(absolute_path_c: [*:0]const u16, flags: Dir.OpenDirOptions) File.OpenError!IterableDir {"},
{"lineNum":" 2718","line":"    assert(path.isAbsoluteWindowsW(absolute_path_c));"},
{"lineNum":" 2719","line":"    return IterableDir{ .dir = try cwd().openDirW(absolute_path_c, flags, true) };"},
{"lineNum":" 2720","line":"}"},
{"lineNum":" 2721","line":""},
{"lineNum":" 2722","line":"/// Opens a file for reading or writing, without attempting to create a new file, based on an absolute path."},
{"lineNum":" 2723","line":"/// Call `File.close` to release the resource."},
{"lineNum":" 2724","line":"/// Asserts that the path is absolute. See `Dir.openFile` for a function that"},
{"lineNum":" 2725","line":"/// operates on both absolute and relative paths."},
{"lineNum":" 2726","line":"/// Asserts that the path parameter has no null bytes. See `openFileAbsoluteZ` for a function"},
{"lineNum":" 2727","line":"/// that accepts a null-terminated path."},
{"lineNum":" 2728","line":"pub fn openFileAbsolute(absolute_path: []const u8, flags: File.OpenFlags) File.OpenError!File {"},
{"lineNum":" 2729","line":"    assert(path.isAbsolute(absolute_path));"},
{"lineNum":" 2730","line":"    return cwd().openFile(absolute_path, flags);"},
{"lineNum":" 2731","line":"}"},
{"lineNum":" 2732","line":""},
{"lineNum":" 2733","line":"/// Same as `openFileAbsolute` but the path parameter is null-terminated."},
{"lineNum":" 2734","line":"pub fn openFileAbsoluteZ(absolute_path_c: [*:0]const u8, flags: File.OpenFlags) File.OpenError!File {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2735","line":"    assert(path.isAbsoluteZ(absolute_path_c));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2736","line":"    return cwd().openFileZ(absolute_path_c, flags);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2737","line":"}"},
{"lineNum":" 2738","line":""},
{"lineNum":" 2739","line":"/// Same as `openFileAbsolute` but the path parameter is WTF-16 encoded."},
{"lineNum":" 2740","line":"pub fn openFileAbsoluteW(absolute_path_w: []const u16, flags: File.OpenFlags) File.OpenError!File {"},
{"lineNum":" 2741","line":"    assert(path.isAbsoluteWindowsWTF16(absolute_path_w));"},
{"lineNum":" 2742","line":"    return cwd().openFileW(absolute_path_w, flags);"},
{"lineNum":" 2743","line":"}"},
{"lineNum":" 2744","line":""},
{"lineNum":" 2745","line":"/// Test accessing `path`."},
{"lineNum":" 2746","line":"/// `path` is UTF8-encoded."},
{"lineNum":" 2747","line":"/// Be careful of Time-Of-Check-Time-Of-Use race conditions when using this function."},
{"lineNum":" 2748","line":"/// For example, instead of testing if a file exists and then opening it, just"},
{"lineNum":" 2749","line":"/// open it and handle the error for file not found."},
{"lineNum":" 2750","line":"/// See `accessAbsoluteZ` for a function that accepts a null-terminated path."},
{"lineNum":" 2751","line":"pub fn accessAbsolute(absolute_path: []const u8, flags: File.OpenFlags) Dir.AccessError!void {"},
{"lineNum":" 2752","line":"    assert(path.isAbsolute(absolute_path));"},
{"lineNum":" 2753","line":"    try cwd().access(absolute_path, flags);"},
{"lineNum":" 2754","line":"}"},
{"lineNum":" 2755","line":"/// Same as `accessAbsolute` but the path parameter is null-terminated."},
{"lineNum":" 2756","line":"pub fn accessAbsoluteZ(absolute_path: [*:0]const u8, flags: File.OpenFlags) Dir.AccessError!void {"},
{"lineNum":" 2757","line":"    assert(path.isAbsoluteZ(absolute_path));"},
{"lineNum":" 2758","line":"    try cwd().accessZ(absolute_path, flags);"},
{"lineNum":" 2759","line":"}"},
{"lineNum":" 2760","line":"/// Same as `accessAbsolute` but the path parameter is WTF-16 encoded."},
{"lineNum":" 2761","line":"pub fn accessAbsoluteW(absolute_path: [*:0]const 16, flags: File.OpenFlags) Dir.AccessError!void {"},
{"lineNum":" 2762","line":"    assert(path.isAbsoluteWindowsW(absolute_path));"},
{"lineNum":" 2763","line":"    try cwd().accessW(absolute_path, flags);"},
{"lineNum":" 2764","line":"}"},
{"lineNum":" 2765","line":""},
{"lineNum":" 2766","line":"/// Creates, opens, or overwrites a file with write access, based on an absolute path."},
{"lineNum":" 2767","line":"/// Call `File.close` to release the resource."},
{"lineNum":" 2768","line":"/// Asserts that the path is absolute. See `Dir.createFile` for a function that"},
{"lineNum":" 2769","line":"/// operates on both absolute and relative paths."},
{"lineNum":" 2770","line":"/// Asserts that the path parameter has no null bytes. See `createFileAbsoluteC` for a function"},
{"lineNum":" 2771","line":"/// that accepts a null-terminated path."},
{"lineNum":" 2772","line":"pub fn createFileAbsolute(absolute_path: []const u8, flags: File.CreateFlags) File.OpenError!File {"},
{"lineNum":" 2773","line":"    assert(path.isAbsolute(absolute_path));"},
{"lineNum":" 2774","line":"    return cwd().createFile(absolute_path, flags);"},
{"lineNum":" 2775","line":"}"},
{"lineNum":" 2776","line":""},
{"lineNum":" 2777","line":"/// Same as `createFileAbsolute` but the path parameter is null-terminated."},
{"lineNum":" 2778","line":"pub fn createFileAbsoluteZ(absolute_path_c: [*:0]const u8, flags: File.CreateFlags) File.OpenError!File {"},
{"lineNum":" 2779","line":"    assert(path.isAbsoluteZ(absolute_path_c));"},
{"lineNum":" 2780","line":"    return cwd().createFileZ(absolute_path_c, flags);"},
{"lineNum":" 2781","line":"}"},
{"lineNum":" 2782","line":""},
{"lineNum":" 2783","line":"/// Same as `createFileAbsolute` but the path parameter is WTF-16 encoded."},
{"lineNum":" 2784","line":"pub fn createFileAbsoluteW(absolute_path_w: [*:0]const u16, flags: File.CreateFlags) File.OpenError!File {"},
{"lineNum":" 2785","line":"    assert(path.isAbsoluteWindowsW(absolute_path_w));"},
{"lineNum":" 2786","line":"    return cwd().createFileW(absolute_path_w, flags);"},
{"lineNum":" 2787","line":"}"},
{"lineNum":" 2788","line":""},
{"lineNum":" 2789","line":"/// Delete a file name and possibly the file it refers to, based on an absolute path."},
{"lineNum":" 2790","line":"/// Asserts that the path is absolute. See `Dir.deleteFile` for a function that"},
{"lineNum":" 2791","line":"/// operates on both absolute and relative paths."},
{"lineNum":" 2792","line":"/// Asserts that the path parameter has no null bytes."},
{"lineNum":" 2793","line":"pub fn deleteFileAbsolute(absolute_path: []const u8) Dir.DeleteFileError!void {"},
{"lineNum":" 2794","line":"    assert(path.isAbsolute(absolute_path));"},
{"lineNum":" 2795","line":"    return cwd().deleteFile(absolute_path);"},
{"lineNum":" 2796","line":"}"},
{"lineNum":" 2797","line":""},
{"lineNum":" 2798","line":"/// Same as `deleteFileAbsolute` except the parameter is null-terminated."},
{"lineNum":" 2799","line":"pub fn deleteFileAbsoluteZ(absolute_path_c: [*:0]const u8) Dir.DeleteFileError!void {"},
{"lineNum":" 2800","line":"    assert(path.isAbsoluteZ(absolute_path_c));"},
{"lineNum":" 2801","line":"    return cwd().deleteFileZ(absolute_path_c);"},
{"lineNum":" 2802","line":"}"},
{"lineNum":" 2803","line":""},
{"lineNum":" 2804","line":"/// Same as `deleteFileAbsolute` except the parameter is WTF-16 encoded."},
{"lineNum":" 2805","line":"pub fn deleteFileAbsoluteW(absolute_path_w: [*:0]const u16) Dir.DeleteFileError!void {"},
{"lineNum":" 2806","line":"    assert(path.isAbsoluteWindowsW(absolute_path_w));"},
{"lineNum":" 2807","line":"    return cwd().deleteFileW(absolute_path_w);"},
{"lineNum":" 2808","line":"}"},
{"lineNum":" 2809","line":""},
{"lineNum":" 2810","line":"/// Removes a symlink, file, or directory."},
{"lineNum":" 2811","line":"/// This is equivalent to `Dir.deleteTree` with the base directory."},
{"lineNum":" 2812","line":"/// Asserts that the path is absolute. See `Dir.deleteTree` for a function that"},
{"lineNum":" 2813","line":"/// operates on both absolute and relative paths."},
{"lineNum":" 2814","line":"/// Asserts that the path parameter has no null bytes."},
{"lineNum":" 2815","line":"pub fn deleteTreeAbsolute(absolute_path: []const u8) !void {"},
{"lineNum":" 2816","line":"    assert(path.isAbsolute(absolute_path));"},
{"lineNum":" 2817","line":"    const dirname = path.dirname(absolute_path) orelse return error{"},
{"lineNum":" 2818","line":"        /// Attempt to remove the root file system path."},
{"lineNum":" 2819","line":"        /// This error is unreachable if `absolute_path` is relative."},
{"lineNum":" 2820","line":"        CannotDeleteRootDirectory,"},
{"lineNum":" 2821","line":"    }.CannotDeleteRootDirectory;"},
{"lineNum":" 2822","line":""},
{"lineNum":" 2823","line":"    var dir = try cwd().openDir(dirname, .{});"},
{"lineNum":" 2824","line":"    defer dir.close();"},
{"lineNum":" 2825","line":""},
{"lineNum":" 2826","line":"    return dir.deleteTree(path.basename(absolute_path));"},
{"lineNum":" 2827","line":"}"},
{"lineNum":" 2828","line":""},
{"lineNum":" 2829","line":"/// Same as `Dir.readLink`, except it asserts the path is absolute."},
{"lineNum":" 2830","line":"pub fn readLinkAbsolute(pathname: []const u8, buffer: *[MAX_PATH_BYTES]u8) ![]u8 {"},
{"lineNum":" 2831","line":"    assert(path.isAbsolute(pathname));"},
{"lineNum":" 2832","line":"    return os.readlink(pathname, buffer);"},
{"lineNum":" 2833","line":"}"},
{"lineNum":" 2834","line":""},
{"lineNum":" 2835","line":"/// Windows-only. Same as `readlinkW`, except the path parameter is null-terminated, WTF16"},
{"lineNum":" 2836","line":"/// encoded."},
{"lineNum":" 2837","line":"pub fn readlinkAbsoluteW(pathname_w: [*:0]const u16, buffer: *[MAX_PATH_BYTES]u8) ![]u8 {"},
{"lineNum":" 2838","line":"    assert(path.isAbsoluteWindowsW(pathname_w));"},
{"lineNum":" 2839","line":"    return os.readlinkW(pathname_w, buffer);"},
{"lineNum":" 2840","line":"}"},
{"lineNum":" 2841","line":""},
{"lineNum":" 2842","line":"/// Same as `readLink`, except the path parameter is null-terminated."},
{"lineNum":" 2843","line":"pub fn readLinkAbsoluteZ(pathname_c: [*:0]const u8, buffer: *[MAX_PATH_BYTES]u8) ![]u8 {"},
{"lineNum":" 2844","line":"    assert(path.isAbsoluteZ(pathname_c));"},
{"lineNum":" 2845","line":"    return os.readlinkZ(pathname_c, buffer);"},
{"lineNum":" 2846","line":"}"},
{"lineNum":" 2847","line":""},
{"lineNum":" 2848","line":"/// Use with `Dir.symLink` and `symLinkAbsolute` to specify whether the symlink"},
{"lineNum":" 2849","line":"/// will point to a file or a directory. This value is ignored on all hosts"},
{"lineNum":" 2850","line":"/// except Windows where creating symlinks to different resource types, requires"},
{"lineNum":" 2851","line":"/// different flags. By default, `symLinkAbsolute` is assumed to point to a file."},
{"lineNum":" 2852","line":"pub const SymLinkFlags = struct {"},
{"lineNum":" 2853","line":"    is_directory: bool = false,"},
{"lineNum":" 2854","line":"};"},
{"lineNum":" 2855","line":""},
{"lineNum":" 2856","line":"/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`."},
{"lineNum":" 2857","line":"/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent"},
{"lineNum":" 2858","line":"/// one; the latter case is known as a dangling link."},
{"lineNum":" 2859","line":"/// If `sym_link_path` exists, it will not be overwritten."},
{"lineNum":" 2860","line":"/// See also `symLinkAbsoluteZ` and `symLinkAbsoluteW`."},
{"lineNum":" 2861","line":"pub fn symLinkAbsolute(target_path: []const u8, sym_link_path: []const u8, flags: SymLinkFlags) !void {"},
{"lineNum":" 2862","line":"    assert(path.isAbsolute(target_path));"},
{"lineNum":" 2863","line":"    assert(path.isAbsolute(sym_link_path));"},
{"lineNum":" 2864","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2865","line":"        const target_path_w = try os.windows.sliceToPrefixedFileW(target_path);"},
{"lineNum":" 2866","line":"        const sym_link_path_w = try os.windows.sliceToPrefixedFileW(sym_link_path);"},
{"lineNum":" 2867","line":"        return os.windows.CreateSymbolicLink(null, sym_link_path_w.span(), target_path_w.span(), flags.is_directory);"},
{"lineNum":" 2868","line":"    }"},
{"lineNum":" 2869","line":"    return os.symlink(target_path, sym_link_path);"},
{"lineNum":" 2870","line":"}"},
{"lineNum":" 2871","line":""},
{"lineNum":" 2872","line":"/// Windows-only. Same as `symLinkAbsolute` except the parameters are null-terminated, WTF16 encoded."},
{"lineNum":" 2873","line":"/// Note that this function will by default try creating a symbolic link to a file. If you would"},
{"lineNum":" 2874","line":"/// like to create a symbolic link to a directory, specify this with `SymLinkFlags{ .is_directory = true }`."},
{"lineNum":" 2875","line":"/// See also `symLinkAbsolute`, `symLinkAbsoluteZ`."},
{"lineNum":" 2876","line":"pub fn symLinkAbsoluteW(target_path_w: []const u16, sym_link_path_w: []const u16, flags: SymLinkFlags) !void {"},
{"lineNum":" 2877","line":"    assert(path.isAbsoluteWindowsWTF16(target_path_w));"},
{"lineNum":" 2878","line":"    assert(path.isAbsoluteWindowsWTF16(sym_link_path_w));"},
{"lineNum":" 2879","line":"    return os.windows.CreateSymbolicLink(null, sym_link_path_w, target_path_w, flags.is_directory);"},
{"lineNum":" 2880","line":"}"},
{"lineNum":" 2881","line":""},
{"lineNum":" 2882","line":"/// Same as `symLinkAbsolute` except the parameters are null-terminated pointers."},
{"lineNum":" 2883","line":"/// See also `symLinkAbsolute`."},
{"lineNum":" 2884","line":"pub fn symLinkAbsoluteZ(target_path_c: [*:0]const u8, sym_link_path_c: [*:0]const u8, flags: SymLinkFlags) !void {"},
{"lineNum":" 2885","line":"    assert(path.isAbsoluteZ(target_path_c));"},
{"lineNum":" 2886","line":"    assert(path.isAbsoluteZ(sym_link_path_c));"},
{"lineNum":" 2887","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2888","line":"        const target_path_w = try os.windows.cStrToWin32PrefixedFileW(target_path_c);"},
{"lineNum":" 2889","line":"        const sym_link_path_w = try os.windows.cStrToWin32PrefixedFileW(sym_link_path_c);"},
{"lineNum":" 2890","line":"        return os.windows.CreateSymbolicLink(sym_link_path_w.span(), target_path_w.span(), flags.is_directory);"},
{"lineNum":" 2891","line":"    }"},
{"lineNum":" 2892","line":"    return os.symlinkZ(target_path_c, sym_link_path_c);"},
{"lineNum":" 2893","line":"}"},
{"lineNum":" 2894","line":""},
{"lineNum":" 2895","line":"pub const OpenSelfExeError = error{"},
{"lineNum":" 2896","line":"    SharingViolation,"},
{"lineNum":" 2897","line":"    PathAlreadyExists,"},
{"lineNum":" 2898","line":"    FileNotFound,"},
{"lineNum":" 2899","line":"    AccessDenied,"},
{"lineNum":" 2900","line":"    PipeBusy,"},
{"lineNum":" 2901","line":"    NameTooLong,"},
{"lineNum":" 2902","line":"    /// On Windows, file paths must be valid Unicode."},
{"lineNum":" 2903","line":"    InvalidUtf8,"},
{"lineNum":" 2904","line":"    /// On Windows, file paths cannot contain these characters:"},
{"lineNum":" 2905","line":"    /// \'/\', \'*\', \'?\', \'\"\', \'<\', \'>\', \'|\'"},
{"lineNum":" 2906","line":"    BadPathName,"},
{"lineNum":" 2907","line":"    Unexpected,"},
{"lineNum":" 2908","line":"} || os.OpenError || SelfExePathError || os.FlockError;"},
{"lineNum":" 2909","line":""},
{"lineNum":" 2910","line":"pub fn openSelfExe(flags: File.OpenFlags) OpenSelfExeError!File {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2911","line":"    if (builtin.os.tag == .linux) {"},
{"lineNum":" 2912","line":"        return openFileAbsoluteZ(\"/proc/self/exe\", flags);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2913","line":"    }"},
{"lineNum":" 2914","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2915","line":"        const wide_slice = selfExePathW();"},
{"lineNum":" 2916","line":"        const prefixed_path_w = try os.windows.wToPrefixedFileW(wide_slice);"},
{"lineNum":" 2917","line":"        return cwd().openFileW(prefixed_path_w.span(), flags);"},
{"lineNum":" 2918","line":"    }"},
{"lineNum":" 2919","line":"    // Use of MAX_PATH_BYTES here is valid as the resulting path is immediately"},
{"lineNum":" 2920","line":"    // opened with no modification."},
{"lineNum":" 2921","line":"    var buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 2922","line":"    const self_exe_path = try selfExePath(&buf);"},
{"lineNum":" 2923","line":"    buf[self_exe_path.len] = 0;"},
{"lineNum":" 2924","line":"    return openFileAbsoluteZ(buf[0..self_exe_path.len :0].ptr, flags);"},
{"lineNum":" 2925","line":"}"},
{"lineNum":" 2926","line":""},
{"lineNum":" 2927","line":"pub const SelfExePathError = os.ReadLinkError || os.SysCtlError || os.RealPathError;"},
{"lineNum":" 2928","line":""},
{"lineNum":" 2929","line":"/// `selfExePath` except allocates the result on the heap."},
{"lineNum":" 2930","line":"/// Caller owns returned memory."},
{"lineNum":" 2931","line":"pub fn selfExePathAlloc(allocator: Allocator) ![]u8 {"},
{"lineNum":" 2932","line":"    // Use of MAX_PATH_BYTES here is justified as, at least on one tested Linux"},
{"lineNum":" 2933","line":"    // system, readlink will completely fail to return a result larger than"},
{"lineNum":" 2934","line":"    // PATH_MAX even if given a sufficiently large buffer. This makes it"},
{"lineNum":" 2935","line":"    // fundamentally impossible to get the selfExePath of a program running in"},
{"lineNum":" 2936","line":"    // a very deeply nested directory chain in this way."},
{"lineNum":" 2937","line":"    // TODO(#4812): Investigate other systems and whether it is possible to get"},
{"lineNum":" 2938","line":"    // this path by trying larger and larger buffers until one succeeds."},
{"lineNum":" 2939","line":"    var buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 2940","line":"    return allocator.dupe(u8, try selfExePath(&buf));"},
{"lineNum":" 2941","line":"}"},
{"lineNum":" 2942","line":""},
{"lineNum":" 2943","line":"/// Get the path to the current executable."},
{"lineNum":" 2944","line":"/// If you only need the directory, use selfExeDirPath."},
{"lineNum":" 2945","line":"/// If you only want an open file handle, use openSelfExe."},
{"lineNum":" 2946","line":"/// This function may return an error if the current executable"},
{"lineNum":" 2947","line":"/// was deleted after spawning."},
{"lineNum":" 2948","line":"/// Returned value is a slice of out_buffer."},
{"lineNum":" 2949","line":"///"},
{"lineNum":" 2950","line":"/// On Linux, depends on procfs being mounted. If the currently executing binary has"},
{"lineNum":" 2951","line":"/// been deleted, the file path looks something like `/a/b/c/exe (deleted)`."},
{"lineNum":" 2952","line":"/// TODO make the return type of this a null terminated pointer"},
{"lineNum":" 2953","line":"pub fn selfExePath(out_buffer: []u8) SelfExePathError![]u8 {"},
{"lineNum":" 2954","line":"    if (is_darwin) {"},
{"lineNum":" 2955","line":"        // Note that _NSGetExecutablePath() will return \"a path\" to"},
{"lineNum":" 2956","line":"        // the executable not a \"real path\" to the executable."},
{"lineNum":" 2957","line":"        var symlink_path_buf: [MAX_PATH_BYTES:0]u8 = undefined;"},
{"lineNum":" 2958","line":"        var u32_len: u32 = MAX_PATH_BYTES + 1; // include the sentinel"},
{"lineNum":" 2959","line":"        const rc = std.c._NSGetExecutablePath(&symlink_path_buf, &u32_len);"},
{"lineNum":" 2960","line":"        if (rc != 0) return error.NameTooLong;"},
{"lineNum":" 2961","line":""},
{"lineNum":" 2962","line":"        var real_path_buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 2963","line":"        const real_path = try std.os.realpathZ(&symlink_path_buf, &real_path_buf);"},
{"lineNum":" 2964","line":"        if (real_path.len > out_buffer.len) return error.NameTooLong;"},
{"lineNum":" 2965","line":"        std.mem.copy(u8, out_buffer, real_path);"},
{"lineNum":" 2966","line":"        return out_buffer[0..real_path.len];"},
{"lineNum":" 2967","line":"    }"},
{"lineNum":" 2968","line":"    switch (builtin.os.tag) {"},
{"lineNum":" 2969","line":"        .linux => return os.readlinkZ(\"/proc/self/exe\", out_buffer),"},
{"lineNum":" 2970","line":"        .solaris => return os.readlinkZ(\"/proc/self/path/a.out\", out_buffer),"},
{"lineNum":" 2971","line":"        .freebsd, .dragonfly => {"},
{"lineNum":" 2972","line":"            var mib = [4]c_int{ os.CTL.KERN, os.KERN.PROC, os.KERN.PROC_PATHNAME, -1 };"},
{"lineNum":" 2973","line":"            var out_len: usize = out_buffer.len;"},
{"lineNum":" 2974","line":"            try os.sysctl(&mib, out_buffer.ptr, &out_len, null, 0);"},
{"lineNum":" 2975","line":"            // TODO could this slice from 0 to out_len instead?"},
{"lineNum":" 2976","line":"            return mem.sliceTo(out_buffer, 0);"},
{"lineNum":" 2977","line":"        },"},
{"lineNum":" 2978","line":"        .netbsd => {"},
{"lineNum":" 2979","line":"            var mib = [4]c_int{ os.CTL.KERN, os.KERN.PROC_ARGS, -1, os.KERN.PROC_PATHNAME };"},
{"lineNum":" 2980","line":"            var out_len: usize = out_buffer.len;"},
{"lineNum":" 2981","line":"            try os.sysctl(&mib, out_buffer.ptr, &out_len, null, 0);"},
{"lineNum":" 2982","line":"            // TODO could this slice from 0 to out_len instead?"},
{"lineNum":" 2983","line":"            return mem.sliceTo(out_buffer, 0);"},
{"lineNum":" 2984","line":"        },"},
{"lineNum":" 2985","line":"        .openbsd, .haiku => {"},
{"lineNum":" 2986","line":"            // OpenBSD doesn\'t support getting the path of a running process, so try to guess it"},
{"lineNum":" 2987","line":"            if (os.argv.len == 0)"},
{"lineNum":" 2988","line":"                return error.FileNotFound;"},
{"lineNum":" 2989","line":""},
{"lineNum":" 2990","line":"            const argv0 = mem.span(os.argv[0]);"},
{"lineNum":" 2991","line":"            if (mem.indexOf(u8, argv0, \"/\") != null) {"},
{"lineNum":" 2992","line":"                // argv[0] is a path (relative or absolute): use realpath(3) directly"},
{"lineNum":" 2993","line":"                var real_path_buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 2994","line":"                const real_path = try os.realpathZ(os.argv[0], &real_path_buf);"},
{"lineNum":" 2995","line":"                if (real_path.len > out_buffer.len)"},
{"lineNum":" 2996","line":"                    return error.NameTooLong;"},
{"lineNum":" 2997","line":"                mem.copy(u8, out_buffer, real_path);"},
{"lineNum":" 2998","line":"                return out_buffer[0..real_path.len];"},
{"lineNum":" 2999","line":"            } else if (argv0.len != 0) {"},
{"lineNum":" 3000","line":"                // argv[0] is not empty (and not a path): search it inside PATH"},
{"lineNum":" 3001","line":"                const PATH = std.os.getenvZ(\"PATH\") orelse return error.FileNotFound;"},
{"lineNum":" 3002","line":"                var path_it = mem.tokenize(u8, PATH, &[_]u8{path.delimiter});"},
{"lineNum":" 3003","line":"                while (path_it.next()) |a_path| {"},
{"lineNum":" 3004","line":"                    var resolved_path_buf: [MAX_PATH_BYTES - 1:0]u8 = undefined;"},
{"lineNum":" 3005","line":"                    const resolved_path = std.fmt.bufPrintZ(&resolved_path_buf, \"{s}/{s}\", .{"},
{"lineNum":" 3006","line":"                        a_path,"},
{"lineNum":" 3007","line":"                        os.argv[0],"},
{"lineNum":" 3008","line":"                    }) catch continue;"},
{"lineNum":" 3009","line":""},
{"lineNum":" 3010","line":"                    var real_path_buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 3011","line":"                    if (os.realpathZ(resolved_path, &real_path_buf)) |real_path| {"},
{"lineNum":" 3012","line":"                        // found a file, and hope it is the right file"},
{"lineNum":" 3013","line":"                        if (real_path.len > out_buffer.len)"},
{"lineNum":" 3014","line":"                            return error.NameTooLong;"},
{"lineNum":" 3015","line":"                        mem.copy(u8, out_buffer, real_path);"},
{"lineNum":" 3016","line":"                        return out_buffer[0..real_path.len];"},
{"lineNum":" 3017","line":"                    } else |_| continue;"},
{"lineNum":" 3018","line":"                }"},
{"lineNum":" 3019","line":"            }"},
{"lineNum":" 3020","line":"            return error.FileNotFound;"},
{"lineNum":" 3021","line":"        },"},
{"lineNum":" 3022","line":"        .windows => {"},
{"lineNum":" 3023","line":"            const utf16le_slice = selfExePathW();"},
{"lineNum":" 3024","line":"            // Trust that Windows gives us valid UTF-16LE."},
{"lineNum":" 3025","line":"            const end_index = std.unicode.utf16leToUtf8(out_buffer, utf16le_slice) catch unreachable;"},
{"lineNum":" 3026","line":"            return out_buffer[0..end_index];"},
{"lineNum":" 3027","line":"        },"},
{"lineNum":" 3028","line":"        .wasi => @compileError(\"std.fs.selfExePath not supported for WASI. Use std.fs.selfExePathAlloc instead.\"),"},
{"lineNum":" 3029","line":"        else => @compileError(\"std.fs.selfExePath not supported for this target\"),"},
{"lineNum":" 3030","line":"    }"},
{"lineNum":" 3031","line":"}"},
{"lineNum":" 3032","line":""},
{"lineNum":" 3033","line":"/// The result is UTF16LE-encoded."},
{"lineNum":" 3034","line":"pub fn selfExePathW() [:0]const u16 {"},
{"lineNum":" 3035","line":"    const image_path_name = &os.windows.peb().ProcessParameters.ImagePathName;"},
{"lineNum":" 3036","line":"    return image_path_name.Buffer[0 .. image_path_name.Length / 2 :0];"},
{"lineNum":" 3037","line":"}"},
{"lineNum":" 3038","line":""},
{"lineNum":" 3039","line":"/// `selfExeDirPath` except allocates the result on the heap."},
{"lineNum":" 3040","line":"/// Caller owns returned memory."},
{"lineNum":" 3041","line":"pub fn selfExeDirPathAlloc(allocator: Allocator) ![]u8 {"},
{"lineNum":" 3042","line":"    // Use of MAX_PATH_BYTES here is justified as, at least on one tested Linux"},
{"lineNum":" 3043","line":"    // system, readlink will completely fail to return a result larger than"},
{"lineNum":" 3044","line":"    // PATH_MAX even if given a sufficiently large buffer. This makes it"},
{"lineNum":" 3045","line":"    // fundamentally impossible to get the selfExeDirPath of a program running"},
{"lineNum":" 3046","line":"    // in a very deeply nested directory chain in this way."},
{"lineNum":" 3047","line":"    // TODO(#4812): Investigate other systems and whether it is possible to get"},
{"lineNum":" 3048","line":"    // this path by trying larger and larger buffers until one succeeds."},
{"lineNum":" 3049","line":"    var buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 3050","line":"    return allocator.dupe(u8, try selfExeDirPath(&buf));"},
{"lineNum":" 3051","line":"}"},
{"lineNum":" 3052","line":""},
{"lineNum":" 3053","line":"/// Get the directory path that contains the current executable."},
{"lineNum":" 3054","line":"/// Returned value is a slice of out_buffer."},
{"lineNum":" 3055","line":"pub fn selfExeDirPath(out_buffer: []u8) SelfExePathError![]const u8 {"},
{"lineNum":" 3056","line":"    const self_exe_path = try selfExePath(out_buffer);"},
{"lineNum":" 3057","line":"    // Assume that the OS APIs return absolute paths, and therefore dirname"},
{"lineNum":" 3058","line":"    // will not return null."},
{"lineNum":" 3059","line":"    return path.dirname(self_exe_path).?;"},
{"lineNum":" 3060","line":"}"},
{"lineNum":" 3061","line":""},
{"lineNum":" 3062","line":"/// `realpath`, except caller must free the returned memory."},
{"lineNum":" 3063","line":"/// See also `Dir.realpath`."},
{"lineNum":" 3064","line":"pub fn realpathAlloc(allocator: Allocator, pathname: []const u8) ![]u8 {"},
{"lineNum":" 3065","line":"    // Use of MAX_PATH_BYTES here is valid as the realpath function does not"},
{"lineNum":" 3066","line":"    // have a variant that takes an arbitrary-size buffer."},
{"lineNum":" 3067","line":"    // TODO(#4812): Consider reimplementing realpath or using the POSIX.1-2008"},
{"lineNum":" 3068","line":"    // NULL out parameter (GNU\'s canonicalize_file_name) to handle overelong"},
{"lineNum":" 3069","line":"    // paths. musl supports passing NULL but restricts the output to PATH_MAX"},
{"lineNum":" 3070","line":"    // anyway."},
{"lineNum":" 3071","line":"    var buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 3072","line":"    return allocator.dupe(u8, try os.realpath(pathname, &buf));"},
{"lineNum":" 3073","line":"}"},
{"lineNum":" 3074","line":""},
{"lineNum":" 3075","line":"const CopyFileRawError = error{SystemResources} || os.CopyFileRangeError || os.SendFileError;"},
{"lineNum":" 3076","line":""},
{"lineNum":" 3077","line":"// Transfer all the data between two file descriptors in the most efficient way."},
{"lineNum":" 3078","line":"// The copy starts at offset 0, the initial offsets are preserved."},
{"lineNum":" 3079","line":"// No metadata is transferred over."},
{"lineNum":" 3080","line":"fn copy_file(fd_in: os.fd_t, fd_out: os.fd_t, maybe_size: ?u64) CopyFileRawError!void {"},
{"lineNum":" 3081","line":"    if (comptime builtin.target.isDarwin()) {"},
{"lineNum":" 3082","line":"        const rc = os.system.fcopyfile(fd_in, fd_out, null, os.system.COPYFILE_DATA);"},
{"lineNum":" 3083","line":"        switch (os.errno(rc)) {"},
{"lineNum":" 3084","line":"            .SUCCESS => return,"},
{"lineNum":" 3085","line":"            .INVAL => unreachable,"},
{"lineNum":" 3086","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 3087","line":"            // The source file is not a directory, symbolic link, or regular file."},
{"lineNum":" 3088","line":"            // Try with the fallback path before giving up."},
{"lineNum":" 3089","line":"            .OPNOTSUPP => {},"},
{"lineNum":" 3090","line":"            else => |err| return os.unexpectedErrno(err),"},
{"lineNum":" 3091","line":"        }"},
{"lineNum":" 3092","line":"    }"},
{"lineNum":" 3093","line":""},
{"lineNum":" 3094","line":"    if (builtin.os.tag == .linux) {"},
{"lineNum":" 3095","line":"        // Try copy_file_range first as that works at the FS level and is the"},
{"lineNum":" 3096","line":"        // most efficient method (if available)."},
{"lineNum":" 3097","line":"        var offset: u64 = 0;"},
{"lineNum":" 3098","line":"        cfr_loop: while (true) {"},
{"lineNum":" 3099","line":"            // The kernel checks the u64 value `offset+count` for overflow, use"},
{"lineNum":" 3100","line":"            // a 32 bit value so that the syscall won\'t return EINVAL except for"},
{"lineNum":" 3101","line":"            // impossibly large files (> 2^64-1 - 2^32-1)."},
{"lineNum":" 3102","line":"            const amt = try os.copy_file_range(fd_in, offset, fd_out, offset, math.maxInt(u32), 0);"},
{"lineNum":" 3103","line":"            // Terminate as soon as we have copied size bytes or no bytes"},
{"lineNum":" 3104","line":"            if (maybe_size) |s| {"},
{"lineNum":" 3105","line":"                if (s == amt) break :cfr_loop;"},
{"lineNum":" 3106","line":"            }"},
{"lineNum":" 3107","line":"            if (amt == 0) break :cfr_loop;"},
{"lineNum":" 3108","line":"            offset += amt;"},
{"lineNum":" 3109","line":"        }"},
{"lineNum":" 3110","line":"        return;"},
{"lineNum":" 3111","line":"    }"},
{"lineNum":" 3112","line":""},
{"lineNum":" 3113","line":"    // Sendfile is a zero-copy mechanism iff the OS supports it, otherwise the"},
{"lineNum":" 3114","line":"    // fallback code will copy the contents chunk by chunk."},
{"lineNum":" 3115","line":"    const empty_iovec = [0]os.iovec_const{};"},
{"lineNum":" 3116","line":"    var offset: u64 = 0;"},
{"lineNum":" 3117","line":"    sendfile_loop: while (true) {"},
{"lineNum":" 3118","line":"        const amt = try os.sendfile(fd_out, fd_in, offset, 0, &empty_iovec, &empty_iovec, 0);"},
{"lineNum":" 3119","line":"        // Terminate as soon as we have copied size bytes or no bytes"},
{"lineNum":" 3120","line":"        if (maybe_size) |s| {"},
{"lineNum":" 3121","line":"            if (s == amt) break :sendfile_loop;"},
{"lineNum":" 3122","line":"        }"},
{"lineNum":" 3123","line":"        if (amt == 0) break :sendfile_loop;"},
{"lineNum":" 3124","line":"        offset += amt;"},
{"lineNum":" 3125","line":"    }"},
{"lineNum":" 3126","line":"}"},
{"lineNum":" 3127","line":""},
{"lineNum":" 3128","line":"test {"},
{"lineNum":" 3129","line":"    if (builtin.os.tag != .wasi) {"},
{"lineNum":" 3130","line":"        _ = makeDirAbsolute;"},
{"lineNum":" 3131","line":"        _ = makeDirAbsoluteZ;"},
{"lineNum":" 3132","line":"        _ = copyFileAbsolute;"},
{"lineNum":" 3133","line":"        _ = updateFileAbsolute;"},
{"lineNum":" 3134","line":"    }"},
{"lineNum":" 3135","line":"    _ = Dir.copyFile;"},
{"lineNum":" 3136","line":"    _ = @import(\"fs/test.zig\");"},
{"lineNum":" 3137","line":"    _ = @import(\"fs/path.zig\");"},
{"lineNum":" 3138","line":"    _ = @import(\"fs/file.zig\");"},
{"lineNum":" 3139","line":"    _ = @import(\"fs/get_app_data_dir.zig\");"},
{"lineNum":" 3140","line":"    _ = @import(\"fs/watch.zig\");"},
{"lineNum":" 3141","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 29, "covered" : 0,};
var merged_data = [];
