var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"../std.zig\");"},
{"lineNum":"    2","line":"const assert = std.debug.assert;"},
{"lineNum":"    3","line":"const mem = std.mem;"},
{"lineNum":"    4","line":"const Allocator = std.mem.Allocator;"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"/// This allocator takes an existing allocator, wraps it, and provides an interface"},
{"lineNum":"    7","line":"/// where you can allocate without freeing, and then free it all together."},
{"lineNum":"    8","line":"pub const ArenaAllocator = struct {"},
{"lineNum":"    9","line":"    child_allocator: Allocator,"},
{"lineNum":"   10","line":"    state: State,"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"    /// Inner state of ArenaAllocator. Can be stored rather than the entire ArenaAllocator"},
{"lineNum":"   13","line":"    /// as a memory-saving optimization."},
{"lineNum":"   14","line":"    pub const State = struct {"},
{"lineNum":"   15","line":"        buffer_list: std.SinglyLinkedList(usize) = .{},"},
{"lineNum":"   16","line":"        end_index: usize = 0,"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"        pub fn promote(self: State, child_allocator: Allocator) ArenaAllocator {","class":"lineCov","hits":"1","order":"1270","possible_hits":"1",},
{"lineNum":"   19","line":"            return .{","class":"lineCov","hits":"1","order":"1271","possible_hits":"1",},
{"lineNum":"   20","line":"                .child_allocator = child_allocator,"},
{"lineNum":"   21","line":"                .state = self,"},
{"lineNum":"   22","line":"            };"},
{"lineNum":"   23","line":"        }"},
{"lineNum":"   24","line":"    };"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"    pub fn allocator(self: *ArenaAllocator) Allocator {","class":"lineCov","hits":"1","order":"1273","possible_hits":"1",},
{"lineNum":"   27","line":"        return .{","class":"lineCov","hits":"1","order":"1274","possible_hits":"1",},
{"lineNum":"   28","line":"            .ptr = self,"},
{"lineNum":"   29","line":"            .vtable = &.{"},
{"lineNum":"   30","line":"                .alloc = alloc,"},
{"lineNum":"   31","line":"                .resize = resize,"},
{"lineNum":"   32","line":"                .free = free,"},
{"lineNum":"   33","line":"            },"},
{"lineNum":"   34","line":"        };"},
{"lineNum":"   35","line":"    }"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"    const BufNode = std.SinglyLinkedList(usize).Node;"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"    pub fn init(child_allocator: Allocator) ArenaAllocator {","class":"lineCov","hits":"1","order":"1268","possible_hits":"1",},
{"lineNum":"   40","line":"        return (State{}).promote(child_allocator);","class":"lineCov","hits":"1","order":"1269","possible_hits":"1",},
{"lineNum":"   41","line":"    }"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"    pub fn deinit(self: ArenaAllocator) void {","class":"lineCov","hits":"1","order":"1597","possible_hits":"1",},
{"lineNum":"   44","line":"        // NOTE: When changing this, make sure `reset()` is adjusted accordingly!"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"        var it = self.state.buffer_list.first;","class":"lineCov","hits":"1","order":"1598","possible_hits":"1",},
{"lineNum":"   47","line":"        while (it) |node| {","class":"lineCov","hits":"1","order":"1599","possible_hits":"1",},
{"lineNum":"   48","line":"            // this has to occur before the free because the free frees node"},
{"lineNum":"   49","line":"            const next_it = node.next;","class":"lineCov","hits":"1","order":"1600","possible_hits":"1",},
{"lineNum":"   50","line":"            const align_bits = std.math.log2_int(usize, @alignOf(BufNode));","class":"lineCov","hits":"1","order":"1601","possible_hits":"1",},
{"lineNum":"   51","line":"            const alloc_buf = @ptrCast([*]u8, node)[0..node.data];","class":"lineCov","hits":"2","order":"1602","possible_hits":"2",},
{"lineNum":"   52","line":"            self.child_allocator.rawFree(alloc_buf, align_bits, @returnAddress());","class":"lineCov","hits":"1","order":"1603","possible_hits":"1",},
{"lineNum":"   53","line":"            it = next_it;","class":"lineCov","hits":"2","order":"1604","possible_hits":"2",},
{"lineNum":"   54","line":"        }"},
{"lineNum":"   55","line":"    }"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    pub const ResetMode = union(enum) {"},
{"lineNum":"   58","line":"        /// Releases all allocated memory in the arena."},
{"lineNum":"   59","line":"        free_all,"},
{"lineNum":"   60","line":"        /// This will pre-heat the arena for future allocations by allocating a"},
{"lineNum":"   61","line":"        /// large enough buffer for all previously done allocations."},
{"lineNum":"   62","line":"        /// Preheating will speed up the allocation process by invoking the backing allocator"},
{"lineNum":"   63","line":"        /// less often than before. If `reset()` is used in a loop, this means that after the"},
{"lineNum":"   64","line":"        /// biggest operation, no memory allocations are performed anymore."},
{"lineNum":"   65","line":"        retain_capacity,"},
{"lineNum":"   66","line":"        /// This is the same as `retain_capacity`, but the memory will be shrunk to"},
{"lineNum":"   67","line":"        /// this value if it exceeds the limit."},
{"lineNum":"   68","line":"        retain_with_limit: usize,"},
{"lineNum":"   69","line":"    };"},
{"lineNum":"   70","line":"    /// Queries the current memory use of this arena."},
{"lineNum":"   71","line":"    /// This will **not** include the storage required for internal keeping."},
{"lineNum":"   72","line":"    pub fn queryCapacity(self: ArenaAllocator) usize {"},
{"lineNum":"   73","line":"        var size: usize = 0;"},
{"lineNum":"   74","line":"        var it = self.state.buffer_list.first;"},
{"lineNum":"   75","line":"        while (it) |node| : (it = node.next) {"},
{"lineNum":"   76","line":"            // Compute the actually allocated size excluding the"},
{"lineNum":"   77","line":"            // linked list node."},
{"lineNum":"   78","line":"            size += node.data - @sizeOf(BufNode);"},
{"lineNum":"   79","line":"        }"},
{"lineNum":"   80","line":"        return size;"},
{"lineNum":"   81","line":"    }"},
{"lineNum":"   82","line":"    /// Resets the arena allocator and frees all allocated memory."},
{"lineNum":"   83","line":"    ///"},
{"lineNum":"   84","line":"    /// `mode` defines how the currently allocated memory is handled."},
{"lineNum":"   85","line":"    /// See the variant documentation for `ResetMode` for the effects of each mode."},
{"lineNum":"   86","line":"    ///"},
{"lineNum":"   87","line":"    /// The function will return whether the reset operation was successful or not."},
{"lineNum":"   88","line":"    /// If the reallocation  failed `false` is returned. The arena will still be fully"},
{"lineNum":"   89","line":"    /// functional in that case, all memory is released. Future allocations just might"},
{"lineNum":"   90","line":"    /// be slower."},
{"lineNum":"   91","line":"    ///"},
{"lineNum":"   92","line":"    /// NOTE: If `mode` is `free_mode`, the function will always return `true`."},
{"lineNum":"   93","line":"    pub fn reset(self: *ArenaAllocator, mode: ResetMode) bool {"},
{"lineNum":"   94","line":"        // Some words on the implementation:"},
{"lineNum":"   95","line":"        // The reset function can be implemented with two basic approaches:"},
{"lineNum":"   96","line":"        // - Counting how much bytes were allocated since the last reset, and storing that"},
{"lineNum":"   97","line":"        //   information in State. This will make reset fast and alloc only a teeny tiny bit"},
{"lineNum":"   98","line":"        //   slower."},
{"lineNum":"   99","line":"        // - Counting how much bytes were allocated by iterating the chunk linked list. This"},
{"lineNum":"  100","line":"        //   will make reset slower, but alloc() keeps the same speed when reset() as if reset()"},
{"lineNum":"  101","line":"        //   would not exist."},
{"lineNum":"  102","line":"        //"},
{"lineNum":"  103","line":"        // The second variant was chosen for implementation, as with more and more calls to reset(),"},
{"lineNum":"  104","line":"        // the function will get faster and faster. At one point, the complexity of the function"},
{"lineNum":"  105","line":"        // will drop to amortized O(1), as we\'re only ever having a single chunk that will not be"},
{"lineNum":"  106","line":"        // reallocated, and we\'re not even touching the backing allocator anymore."},
{"lineNum":"  107","line":"        //"},
{"lineNum":"  108","line":"        // Thus, only the first hand full of calls to reset() will actually need to iterate the linked"},
{"lineNum":"  109","line":"        // list, all future calls are just taking the first node, and only resetting the `end_index`"},
{"lineNum":"  110","line":"        // value."},
{"lineNum":"  111","line":"        const current_capacity = if (mode != .free_all)"},
{"lineNum":"  112","line":"            @sizeOf(BufNode) + self.queryCapacity() // we need at least space for exactly one node + the current capacity"},
{"lineNum":"  113","line":"        else"},
{"lineNum":"  114","line":"            0;"},
{"lineNum":"  115","line":"        if (mode == .free_all or current_capacity == 0) {"},
{"lineNum":"  116","line":"            // just reset when we don\'t have anything to reallocate"},
{"lineNum":"  117","line":"            self.deinit();"},
{"lineNum":"  118","line":"            self.state = State{};"},
{"lineNum":"  119","line":"            return true;"},
{"lineNum":"  120","line":"        }"},
{"lineNum":"  121","line":"        const total_size = switch (mode) {"},
{"lineNum":"  122","line":"            .retain_capacity => current_capacity,"},
{"lineNum":"  123","line":"            .retain_with_limit => |limit| std.math.min(limit, current_capacity),"},
{"lineNum":"  124","line":"            .free_all => unreachable,"},
{"lineNum":"  125","line":"        };"},
{"lineNum":"  126","line":"        const align_bits = std.math.log2_int(usize, @alignOf(BufNode));"},
{"lineNum":"  127","line":"        // Free all nodes except for the last one"},
{"lineNum":"  128","line":"        var it = self.state.buffer_list.first;"},
{"lineNum":"  129","line":"        const maybe_first_node = while (it) |node| {"},
{"lineNum":"  130","line":"            // this has to occur before the free because the free frees node"},
{"lineNum":"  131","line":"            const next_it = node.next;"},
{"lineNum":"  132","line":"            if (next_it == null)"},
{"lineNum":"  133","line":"                break node;"},
{"lineNum":"  134","line":"            const alloc_buf = @ptrCast([*]u8, node)[0..node.data];"},
{"lineNum":"  135","line":"            self.child_allocator.rawFree(alloc_buf, align_bits, @returnAddress());"},
{"lineNum":"  136","line":"            it = next_it;"},
{"lineNum":"  137","line":"        } else null;"},
{"lineNum":"  138","line":"        std.debug.assert(maybe_first_node == null or maybe_first_node.?.next == null);"},
{"lineNum":"  139","line":"        // reset the state before we try resizing the buffers, so we definitly have reset the arena to 0."},
{"lineNum":"  140","line":"        self.state.end_index = 0;"},
{"lineNum":"  141","line":"        if (maybe_first_node) |first_node| {"},
{"lineNum":"  142","line":"            // perfect, no need to invoke the child_allocator"},
{"lineNum":"  143","line":"            if (first_node.data == total_size)"},
{"lineNum":"  144","line":"                return true;"},
{"lineNum":"  145","line":"            const first_alloc_buf = @ptrCast([*]u8, first_node)[0..first_node.data];"},
{"lineNum":"  146","line":"            if (self.child_allocator.rawResize(first_alloc_buf, align_bits, total_size, @returnAddress())) {"},
{"lineNum":"  147","line":"                // successful resize"},
{"lineNum":"  148","line":"                first_node.data = total_size;"},
{"lineNum":"  149","line":"            } else {"},
{"lineNum":"  150","line":"                // manual realloc"},
{"lineNum":"  151","line":"                const new_ptr = self.child_allocator.rawAlloc(total_size, align_bits, @returnAddress()) orelse {"},
{"lineNum":"  152","line":"                    // we failed to preheat the arena properly, signal this to the user."},
{"lineNum":"  153","line":"                    return false;"},
{"lineNum":"  154","line":"                };"},
{"lineNum":"  155","line":"                self.child_allocator.rawFree(first_alloc_buf, align_bits, @returnAddress());"},
{"lineNum":"  156","line":"                const node = @ptrCast(*BufNode, @alignCast(@alignOf(BufNode), new_ptr));"},
{"lineNum":"  157","line":"                node.* = .{ .data = total_size };"},
{"lineNum":"  158","line":"                self.state.buffer_list.first = node;"},
{"lineNum":"  159","line":"            }"},
{"lineNum":"  160","line":"        }"},
{"lineNum":"  161","line":"        return true;"},
{"lineNum":"  162","line":"    }"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"    fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) ?*BufNode {","class":"lineCov","hits":"1","order":"1314","possible_hits":"1",},
{"lineNum":"  165","line":"        const actual_min_size = minimum_size + (@sizeOf(BufNode) + 16);","class":"lineCov","hits":"1","order":"1315","possible_hits":"1",},
{"lineNum":"  166","line":"        const big_enough_len = prev_len + actual_min_size;","class":"lineCov","hits":"1","order":"1316","possible_hits":"1",},
{"lineNum":"  167","line":"        const len = big_enough_len + big_enough_len / 2;","class":"lineCov","hits":"1","order":"1317","possible_hits":"1",},
{"lineNum":"  168","line":"        const log2_align = comptime std.math.log2_int(usize, @alignOf(BufNode));","class":"lineCov","hits":"1","order":"1318","possible_hits":"1",},
{"lineNum":"  169","line":"        const ptr = self.child_allocator.rawAlloc(len, log2_align, @returnAddress()) orelse","class":"lineCov","hits":"1","order":"1319","possible_hits":"1",},
{"lineNum":"  170","line":"            return null;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  171","line":"        const buf_node = @ptrCast(*BufNode, @alignCast(@alignOf(BufNode), ptr));","class":"lineCov","hits":"1","order":"1320","possible_hits":"1",},
{"lineNum":"  172","line":"        buf_node.* = .{ .data = len };","class":"lineCov","hits":"1","order":"1321","possible_hits":"1",},
{"lineNum":"  173","line":"        self.state.buffer_list.prepend(buf_node);","class":"lineCov","hits":"1","order":"1322","possible_hits":"1",},
{"lineNum":"  174","line":"        self.state.end_index = 0;","class":"lineCov","hits":"1","order":"1326","possible_hits":"1",},
{"lineNum":"  175","line":"        return buf_node;","class":"lineCov","hits":"1","order":"1327","possible_hits":"1",},
{"lineNum":"  176","line":"    }"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"    fn alloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 {","class":"lineCov","hits":"1","order":"1309","possible_hits":"1",},
{"lineNum":"  179","line":"        const self = @ptrCast(*ArenaAllocator, @alignCast(@alignOf(ArenaAllocator), ctx));","class":"lineCov","hits":"1","order":"1310","possible_hits":"1",},
{"lineNum":"  180","line":"        _ = ra;"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"        const ptr_align = @as(usize, 1) << @intCast(Allocator.Log2Align, log2_ptr_align);","class":"lineCov","hits":"1","order":"1311","possible_hits":"1",},
{"lineNum":"  183","line":"        var cur_node = if (self.state.buffer_list.first) |first_node|","class":"lineCov","hits":"1","order":"1312","possible_hits":"1",},
{"lineNum":"  184","line":"            first_node"},
{"lineNum":"  185","line":"        else"},
{"lineNum":"  186","line":"            (self.createNode(0, n + ptr_align) orelse return null);","class":"lineCov","hits":"1","order":"1313","possible_hits":"1",},
{"lineNum":"  187","line":"        while (true) {"},
{"lineNum":"  188","line":"            const cur_alloc_buf = @ptrCast([*]u8, cur_node)[0..cur_node.data];","class":"lineCov","hits":"1","order":"1328","possible_hits":"1",},
{"lineNum":"  189","line":"            const cur_buf = cur_alloc_buf[@sizeOf(BufNode)..];","class":"lineCov","hits":"1","order":"1329","possible_hits":"1",},
{"lineNum":"  190","line":"            const addr = @ptrToInt(cur_buf.ptr) + self.state.end_index;","class":"lineCov","hits":"1","order":"1330","possible_hits":"1",},
{"lineNum":"  191","line":"            const adjusted_addr = mem.alignForward(addr, ptr_align);","class":"lineCov","hits":"1","order":"1331","possible_hits":"1",},
{"lineNum":"  192","line":"            const adjusted_index = self.state.end_index + (adjusted_addr - addr);","class":"lineCov","hits":"1","order":"1332","possible_hits":"1",},
{"lineNum":"  193","line":"            const new_end_index = adjusted_index + n;","class":"lineCov","hits":"1","order":"1333","possible_hits":"1",},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"            if (new_end_index <= cur_buf.len) {","class":"lineCov","hits":"1","order":"1334","possible_hits":"1",},
{"lineNum":"  196","line":"                const result = cur_buf[adjusted_index..new_end_index];","class":"lineCov","hits":"2","order":"1335","possible_hits":"2",},
{"lineNum":"  197","line":"                self.state.end_index = new_end_index;","class":"lineCov","hits":"1","order":"1336","possible_hits":"1",},
{"lineNum":"  198","line":"                return result.ptr;","class":"lineCov","hits":"2","order":"1337","possible_hits":"2",},
{"lineNum":"  199","line":"            }"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"            const bigger_buf_size = @sizeOf(BufNode) + new_end_index;","class":"lineCov","hits":"1","order":"1379","possible_hits":"1",},
{"lineNum":"  202","line":"            const log2_align = comptime std.math.log2_int(usize, @alignOf(BufNode));","class":"lineCov","hits":"1","order":"1380","possible_hits":"1",},
{"lineNum":"  203","line":"            if (self.child_allocator.rawResize(cur_alloc_buf, log2_align, bigger_buf_size, @returnAddress())) {","class":"lineCov","hits":"1","order":"1381","possible_hits":"1",},
{"lineNum":"  204","line":"                cur_node.data = bigger_buf_size;","class":"lineCov","hits":"1","order":"1385","possible_hits":"1",},
{"lineNum":"  205","line":"            } else {"},
{"lineNum":"  206","line":"                // Allocate a new node if that\'s not possible"},
{"lineNum":"  207","line":"                cur_node = self.createNode(cur_buf.len, n + ptr_align) orelse return null;","class":"lineCov","hits":"1","order":"1471","possible_hits":"1",},
{"lineNum":"  208","line":"            }"},
{"lineNum":"  209","line":"        }"},
{"lineNum":"  210","line":"    }"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"    fn resize(ctx: *anyopaque, buf: []u8, log2_buf_align: u8, new_len: usize, ret_addr: usize) bool {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  213","line":"        const self = @ptrCast(*ArenaAllocator, @alignCast(@alignOf(ArenaAllocator), ctx));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  214","line":"        _ = log2_buf_align;"},
{"lineNum":"  215","line":"        _ = ret_addr;"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"        const cur_node = self.state.buffer_list.first orelse return false;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  218","line":"        const cur_buf = @ptrCast([*]u8, cur_node)[@sizeOf(BufNode)..cur_node.data];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  219","line":"        if (@ptrToInt(cur_buf.ptr) + self.state.end_index != @ptrToInt(buf.ptr) + buf.len) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  220","line":"            // It\'s not the most recent allocation, so it cannot be expanded,"},
{"lineNum":"  221","line":"            // but it\'s fine if they want to make it smaller."},
{"lineNum":"  222","line":"            return new_len <= buf.len;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  223","line":"        }"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"        if (buf.len >= new_len) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  226","line":"            self.state.end_index -= buf.len - new_len;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  227","line":"            return true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  228","line":"        } else if (cur_buf.len - self.state.end_index >= new_len - buf.len) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  229","line":"            self.state.end_index += new_len - buf.len;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  230","line":"            return true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  231","line":"        } else {"},
{"lineNum":"  232","line":"            return false;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  233","line":"        }"},
{"lineNum":"  234","line":"    }"},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"    fn free(ctx: *anyopaque, buf: []u8, log2_buf_align: u8, ret_addr: usize) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  237","line":"        _ = log2_buf_align;"},
{"lineNum":"  238","line":"        _ = ret_addr;"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"        const self = @ptrCast(*ArenaAllocator, @alignCast(@alignOf(ArenaAllocator), ctx));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"        const cur_node = self.state.buffer_list.first orelse return;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  243","line":"        const cur_buf = @ptrCast([*]u8, cur_node)[@sizeOf(BufNode)..cur_node.data];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"        if (@ptrToInt(cur_buf.ptr) + self.state.end_index == @ptrToInt(buf.ptr) + buf.len) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  246","line":"            self.state.end_index -= buf.len;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  247","line":"        }"},
{"lineNum":"  248","line":"    }"},
{"lineNum":"  249","line":"};"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"test \"ArenaAllocator (reset with preheating)\" {"},
{"lineNum":"  252","line":"    var arena_allocator = ArenaAllocator.init(std.testing.allocator);"},
{"lineNum":"  253","line":"    defer arena_allocator.deinit();"},
{"lineNum":"  254","line":"    // provides some variance in the allocated data"},
{"lineNum":"  255","line":"    var rng_src = std.rand.DefaultPrng.init(19930913);"},
{"lineNum":"  256","line":"    const random = rng_src.random();"},
{"lineNum":"  257","line":"    var rounds: usize = 25;"},
{"lineNum":"  258","line":"    while (rounds > 0) {"},
{"lineNum":"  259","line":"        rounds -= 1;"},
{"lineNum":"  260","line":"        _ = arena_allocator.reset(.retain_capacity);"},
{"lineNum":"  261","line":"        var alloced_bytes: usize = 0;"},
{"lineNum":"  262","line":"        var total_size: usize = random.intRangeAtMost(usize, 256, 16384);"},
{"lineNum":"  263","line":"        while (alloced_bytes < total_size) {"},
{"lineNum":"  264","line":"            const size = random.intRangeAtMost(usize, 16, 256);"},
{"lineNum":"  265","line":"            const alignment = 32;"},
{"lineNum":"  266","line":"            const slice = try arena_allocator.allocator().alignedAlloc(u8, alignment, size);"},
{"lineNum":"  267","line":"            try std.testing.expect(std.mem.isAligned(@ptrToInt(slice.ptr), alignment));"},
{"lineNum":"  268","line":"            try std.testing.expectEqual(size, slice.len);"},
{"lineNum":"  269","line":"            alloced_bytes += slice.len;"},
{"lineNum":"  270","line":"        }"},
{"lineNum":"  271","line":"    }"},
{"lineNum":"  272","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 65, "covered" : 45,};
var merged_data = [];
