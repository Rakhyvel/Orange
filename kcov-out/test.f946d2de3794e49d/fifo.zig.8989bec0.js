var data = {lines:[
{"lineNum":"    1","line":"// FIFO of fixed size items"},
{"lineNum":"    2","line":"// Usually used for e.g. byte buffers"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"const std = @import(\"std\");"},
{"lineNum":"    5","line":"const math = std.math;"},
{"lineNum":"    6","line":"const mem = std.mem;"},
{"lineNum":"    7","line":"const Allocator = mem.Allocator;"},
{"lineNum":"    8","line":"const debug = std.debug;"},
{"lineNum":"    9","line":"const assert = debug.assert;"},
{"lineNum":"   10","line":"const testing = std.testing;"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"pub const LinearFifoBufferType = union(enum) {"},
{"lineNum":"   13","line":"    /// The buffer is internal to the fifo; it is of the specified size."},
{"lineNum":"   14","line":"    Static: usize,"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"    /// The buffer is passed as a slice to the initialiser."},
{"lineNum":"   17","line":"    Slice,"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"    /// The buffer is managed dynamically using a `mem.Allocator`."},
{"lineNum":"   20","line":"    Dynamic,"},
{"lineNum":"   21","line":"};"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"pub fn LinearFifo("},
{"lineNum":"   24","line":"    comptime T: type,"},
{"lineNum":"   25","line":"    comptime buffer_type: LinearFifoBufferType,"},
{"lineNum":"   26","line":") type {"},
{"lineNum":"   27","line":"    const autoalign = false;"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"    const powers_of_two = switch (buffer_type) {"},
{"lineNum":"   30","line":"        .Static => std.math.isPowerOfTwo(buffer_type.Static),"},
{"lineNum":"   31","line":"        .Slice => false, // Any size slice could be passed in"},
{"lineNum":"   32","line":"        .Dynamic => true, // This could be configurable in future"},
{"lineNum":"   33","line":"    };"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"    return struct {"},
{"lineNum":"   36","line":"        allocator: if (buffer_type == .Dynamic) Allocator else void,"},
{"lineNum":"   37","line":"        buf: if (buffer_type == .Static) [buffer_type.Static]T else []T,"},
{"lineNum":"   38","line":"        head: usize,"},
{"lineNum":"   39","line":"        count: usize,"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"        const Self = @This();"},
{"lineNum":"   42","line":"        pub const Reader = std.io.Reader(*Self, error{}, readFn);"},
{"lineNum":"   43","line":"        pub const Writer = std.io.Writer(*Self, error{OutOfMemory}, appendWrite);"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"        // Type of Self argument for slice operations."},
{"lineNum":"   46","line":"        // If buffer is inline (Static) then we need to ensure we haven\'t"},
{"lineNum":"   47","line":"        // returned a slice into a copy on the stack"},
{"lineNum":"   48","line":"        const SliceSelfArg = if (buffer_type == .Static) *Self else Self;"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"        pub usingnamespace switch (buffer_type) {"},
{"lineNum":"   51","line":"            .Static => struct {"},
{"lineNum":"   52","line":"                pub fn init() Self {"},
{"lineNum":"   53","line":"                    return .{"},
{"lineNum":"   54","line":"                        .allocator = {},"},
{"lineNum":"   55","line":"                        .buf = undefined,"},
{"lineNum":"   56","line":"                        .head = 0,"},
{"lineNum":"   57","line":"                        .count = 0,"},
{"lineNum":"   58","line":"                    };"},
{"lineNum":"   59","line":"                }"},
{"lineNum":"   60","line":"            },"},
{"lineNum":"   61","line":"            .Slice => struct {"},
{"lineNum":"   62","line":"                pub fn init(buf: []T) Self {"},
{"lineNum":"   63","line":"                    return .{"},
{"lineNum":"   64","line":"                        .allocator = {},"},
{"lineNum":"   65","line":"                        .buf = buf,"},
{"lineNum":"   66","line":"                        .head = 0,"},
{"lineNum":"   67","line":"                        .count = 0,"},
{"lineNum":"   68","line":"                    };"},
{"lineNum":"   69","line":"                }"},
{"lineNum":"   70","line":"            },"},
{"lineNum":"   71","line":"            .Dynamic => struct {"},
{"lineNum":"   72","line":"                pub fn init(allocator: Allocator) Self {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   73","line":"                    return .{","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   74","line":"                        .allocator = allocator,"},
{"lineNum":"   75","line":"                        .buf = &[_]T{},"},
{"lineNum":"   76","line":"                        .head = 0,"},
{"lineNum":"   77","line":"                        .count = 0,"},
{"lineNum":"   78","line":"                    };"},
{"lineNum":"   79","line":"                }"},
{"lineNum":"   80","line":"            },"},
{"lineNum":"   81","line":"        };"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"        pub fn deinit(self: Self) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   84","line":"            if (buffer_type == .Dynamic) self.allocator.free(self.buf);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   85","line":"        }"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"        pub fn realign(self: *Self) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   88","line":"            if (self.buf.len - self.head >= self.count) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   89","line":"                // this copy overlaps"},
{"lineNum":"   90","line":"                mem.copy(T, self.buf[0..self.count], self.buf[self.head..][0..self.count]);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   91","line":"                self.head = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   92","line":"            } else {"},
{"lineNum":"   93","line":"                var tmp: [mem.page_size / 2 / @sizeOf(T)]T = undefined;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"                while (self.head != 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   96","line":"                    const n = math.min(self.head, tmp.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   97","line":"                    const m = self.buf.len - n;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   98","line":"                    mem.copy(T, tmp[0..n], self.buf[0..n]);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   99","line":"                    // this middle copy overlaps; the others here don\'t"},
{"lineNum":"  100","line":"                    mem.copy(T, self.buf[0..m], self.buf[n..][0..m]);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  101","line":"                    mem.copy(T, self.buf[m..], tmp[0..n]);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  102","line":"                    self.head -= n;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  103","line":"                }"},
{"lineNum":"  104","line":"            }"},
{"lineNum":"  105","line":"            { // set unused area to undefined"},
{"lineNum":"  106","line":"                const unused = mem.sliceAsBytes(self.buf[self.count..]);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  107","line":"                @memset(unused.ptr, undefined, unused.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  108","line":"            }"},
{"lineNum":"  109","line":"        }"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"        /// Reduce allocated capacity to `size`."},
{"lineNum":"  112","line":"        pub fn shrink(self: *Self, size: usize) void {"},
{"lineNum":"  113","line":"            assert(size >= self.count);"},
{"lineNum":"  114","line":"            if (buffer_type == .Dynamic) {"},
{"lineNum":"  115","line":"                self.realign();"},
{"lineNum":"  116","line":"                self.buf = self.allocator.realloc(self.buf, size) catch |e| switch (e) {"},
{"lineNum":"  117","line":"                    error.OutOfMemory => return, // no problem, capacity is still correct then."},
{"lineNum":"  118","line":"                };"},
{"lineNum":"  119","line":"            }"},
{"lineNum":"  120","line":"        }"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"        pub const ensureCapacity = @compileError(\"deprecated; call `ensureUnusedCapacity` or `ensureTotalCapacity`\");"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"        /// Ensure that the buffer can fit at least `size` items"},
{"lineNum":"  125","line":"        pub fn ensureTotalCapacity(self: *Self, size: usize) !void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  126","line":"            if (self.buf.len >= size) return;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  127","line":"            if (buffer_type == .Dynamic) {"},
{"lineNum":"  128","line":"                self.realign();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  129","line":"                const new_size = if (powers_of_two) math.ceilPowerOfTwo(usize, size) catch return error.OutOfMemory else size;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  130","line":"                self.buf = try self.allocator.realloc(self.buf, new_size);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  131","line":"            } else {"},
{"lineNum":"  132","line":"                return error.OutOfMemory;"},
{"lineNum":"  133","line":"            }"},
{"lineNum":"  134","line":"        }"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"        /// Makes sure at least `size` items are unused"},
{"lineNum":"  137","line":"        pub fn ensureUnusedCapacity(self: *Self, size: usize) error{OutOfMemory}!void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  138","line":"            if (self.writableLength() >= size) return;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"            return try self.ensureTotalCapacity(math.add(usize, self.count, size) catch return error.OutOfMemory);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  141","line":"        }"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"        /// Returns number of items currently in fifo"},
{"lineNum":"  144","line":"        pub fn readableLength(self: Self) usize {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  145","line":"            return self.count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  146","line":"        }"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"        /// Returns a writable slice from the \'read\' end of the fifo"},
{"lineNum":"  149","line":"        fn readableSliceMut(self: SliceSelfArg, offset: usize) []T {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  150","line":"            if (offset > self.count) return &[_]T{};","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"            var start = self.head + offset;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  153","line":"            if (start >= self.buf.len) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  154","line":"                start -= self.buf.len;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  155","line":"                return self.buf[start .. start + (self.count - offset)];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  156","line":"            } else {"},
{"lineNum":"  157","line":"                const end = math.min(self.head + self.count, self.buf.len);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  158","line":"                return self.buf[start..end];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  159","line":"            }"},
{"lineNum":"  160","line":"        }"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"        /// Returns a readable slice from `offset`"},
{"lineNum":"  163","line":"        pub fn readableSlice(self: SliceSelfArg, offset: usize) []const T {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  164","line":"            return self.readableSliceMut(offset);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  165","line":"        }"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"        pub fn readableSliceOfLen(self: *Self, len: usize) []const T {"},
{"lineNum":"  168","line":"            assert(len <= self.count);"},
{"lineNum":"  169","line":"            const buf = self.readableSlice(0);"},
{"lineNum":"  170","line":"            if (buf.len >= len) {"},
{"lineNum":"  171","line":"                return buf[0..len];"},
{"lineNum":"  172","line":"            } else {"},
{"lineNum":"  173","line":"                self.realign();"},
{"lineNum":"  174","line":"                return self.readableSlice(0)[0..len];"},
{"lineNum":"  175","line":"            }"},
{"lineNum":"  176","line":"        }"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"        /// Discard first `count` items in the fifo"},
{"lineNum":"  179","line":"        pub fn discard(self: *Self, count: usize) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  180","line":"            assert(count <= self.count);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  181","line":"            { // set old range to undefined. Note: may be wrapped around"},
{"lineNum":"  182","line":"                const slice = self.readableSliceMut(0);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  183","line":"                if (slice.len >= count) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  184","line":"                    const unused = mem.sliceAsBytes(slice[0..count]);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  185","line":"                    @memset(unused.ptr, undefined, unused.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  186","line":"                } else {"},
{"lineNum":"  187","line":"                    const unused = mem.sliceAsBytes(slice[0..]);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  188","line":"                    @memset(unused.ptr, undefined, unused.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  189","line":"                    const unused2 = mem.sliceAsBytes(self.readableSliceMut(slice.len)[0 .. count - slice.len]);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  190","line":"                    @memset(unused2.ptr, undefined, unused2.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  191","line":"                }"},
{"lineNum":"  192","line":"            }"},
{"lineNum":"  193","line":"            if (autoalign and self.count == count) {"},
{"lineNum":"  194","line":"                self.head = 0;"},
{"lineNum":"  195","line":"                self.count = 0;"},
{"lineNum":"  196","line":"            } else {"},
{"lineNum":"  197","line":"                var head = self.head + count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  198","line":"                if (powers_of_two) {"},
{"lineNum":"  199","line":"                    // Note it is safe to do a wrapping subtract as"},
{"lineNum":"  200","line":"                    // bitwise & with all 1s is a noop"},
{"lineNum":"  201","line":"                    head &= self.buf.len -% 1;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  202","line":"                } else {"},
{"lineNum":"  203","line":"                    head %= self.buf.len;"},
{"lineNum":"  204","line":"                }"},
{"lineNum":"  205","line":"                self.head = head;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  206","line":"                self.count -= count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  207","line":"            }"},
{"lineNum":"  208","line":"        }"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"        /// Read the next item from the fifo"},
{"lineNum":"  211","line":"        pub fn readItem(self: *Self) ?T {"},
{"lineNum":"  212","line":"            if (self.count == 0) return null;"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"            const c = self.buf[self.head];"},
{"lineNum":"  215","line":"            self.discard(1);"},
{"lineNum":"  216","line":"            return c;"},
{"lineNum":"  217","line":"        }"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"        /// Read data from the fifo into `dst`, returns number of items copied."},
{"lineNum":"  220","line":"        pub fn read(self: *Self, dst: []T) usize {"},
{"lineNum":"  221","line":"            var dst_left = dst;"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"            while (dst_left.len > 0) {"},
{"lineNum":"  224","line":"                const slice = self.readableSlice(0);"},
{"lineNum":"  225","line":"                if (slice.len == 0) break;"},
{"lineNum":"  226","line":"                const n = math.min(slice.len, dst_left.len);"},
{"lineNum":"  227","line":"                mem.copy(T, dst_left, slice[0..n]);"},
{"lineNum":"  228","line":"                self.discard(n);"},
{"lineNum":"  229","line":"                dst_left = dst_left[n..];"},
{"lineNum":"  230","line":"            }"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"            return dst.len - dst_left.len;"},
{"lineNum":"  233","line":"        }"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"        /// Same as `read` except it returns an error union"},
{"lineNum":"  236","line":"        /// The purpose of this function existing is to match `std.io.Reader` API."},
{"lineNum":"  237","line":"        fn readFn(self: *Self, dest: []u8) error{}!usize {"},
{"lineNum":"  238","line":"            return self.read(dest);"},
{"lineNum":"  239","line":"        }"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"        pub fn reader(self: *Self) Reader {"},
{"lineNum":"  242","line":"            return .{ .context = self };"},
{"lineNum":"  243","line":"        }"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"        /// Returns number of items available in fifo"},
{"lineNum":"  246","line":"        pub fn writableLength(self: Self) usize {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  247","line":"            return self.buf.len - self.count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  248","line":"        }"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"        /// Returns the first section of writable buffer"},
{"lineNum":"  251","line":"        /// Note that this may be of length 0"},
{"lineNum":"  252","line":"        pub fn writableSlice(self: SliceSelfArg, offset: usize) []T {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  253","line":"            if (offset > self.buf.len) return &[_]T{};","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"            const tail = self.head + offset + self.count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  256","line":"            if (tail < self.buf.len) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  257","line":"                return self.buf[tail..];","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  258","line":"            } else {"},
{"lineNum":"  259","line":"                return self.buf[tail - self.buf.len ..][0 .. self.writableLength() - offset];","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  260","line":"            }"},
{"lineNum":"  261","line":"        }"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"        /// Returns a writable buffer of at least `size` items, allocating memory as needed."},
{"lineNum":"  264","line":"        /// Use `fifo.update` once you\'ve written data to it."},
{"lineNum":"  265","line":"        pub fn writableWithSize(self: *Self, size: usize) ![]T {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  266","line":"            try self.ensureUnusedCapacity(size);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"            // try to avoid realigning buffer"},
{"lineNum":"  269","line":"            var slice = self.writableSlice(0);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  270","line":"            if (slice.len < size) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  271","line":"                self.realign();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  272","line":"                slice = self.writableSlice(0);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  273","line":"            }"},
{"lineNum":"  274","line":"            return slice;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  275","line":"        }"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"        /// Update the tail location of the buffer (usually follows use of writable/writableWithSize)"},
{"lineNum":"  278","line":"        pub fn update(self: *Self, count: usize) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  279","line":"            assert(self.count + count <= self.buf.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  280","line":"            self.count += count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  281","line":"        }"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"        /// Appends the data in `src` to the fifo."},
{"lineNum":"  284","line":"        /// You must have ensured there is enough space."},
{"lineNum":"  285","line":"        pub fn writeAssumeCapacity(self: *Self, src: []const T) void {"},
{"lineNum":"  286","line":"            assert(self.writableLength() >= src.len);"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"            var src_left = src;"},
{"lineNum":"  289","line":"            while (src_left.len > 0) {"},
{"lineNum":"  290","line":"                const writable_slice = self.writableSlice(0);"},
{"lineNum":"  291","line":"                assert(writable_slice.len != 0);"},
{"lineNum":"  292","line":"                const n = math.min(writable_slice.len, src_left.len);"},
{"lineNum":"  293","line":"                mem.copy(T, writable_slice, src_left[0..n]);"},
{"lineNum":"  294","line":"                self.update(n);"},
{"lineNum":"  295","line":"                src_left = src_left[n..];"},
{"lineNum":"  296","line":"            }"},
{"lineNum":"  297","line":"        }"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"        /// Write a single item to the fifo"},
{"lineNum":"  300","line":"        pub fn writeItem(self: *Self, item: T) !void {"},
{"lineNum":"  301","line":"            try self.ensureUnusedCapacity(1);"},
{"lineNum":"  302","line":"            return self.writeItemAssumeCapacity(item);"},
{"lineNum":"  303","line":"        }"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"        pub fn writeItemAssumeCapacity(self: *Self, item: T) void {"},
{"lineNum":"  306","line":"            var tail = self.head + self.count;"},
{"lineNum":"  307","line":"            if (powers_of_two) {"},
{"lineNum":"  308","line":"                tail &= self.buf.len - 1;"},
{"lineNum":"  309","line":"            } else {"},
{"lineNum":"  310","line":"                tail %= self.buf.len;"},
{"lineNum":"  311","line":"            }"},
{"lineNum":"  312","line":"            self.buf[tail] = item;"},
{"lineNum":"  313","line":"            self.update(1);"},
{"lineNum":"  314","line":"        }"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"        /// Appends the data in `src` to the fifo."},
{"lineNum":"  317","line":"        /// Allocates more memory as necessary"},
{"lineNum":"  318","line":"        pub fn write(self: *Self, src: []const T) !void {"},
{"lineNum":"  319","line":"            try self.ensureUnusedCapacity(src.len);"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"            return self.writeAssumeCapacity(src);"},
{"lineNum":"  322","line":"        }"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"        /// Same as `write` except it returns the number of bytes written, which is always the same"},
{"lineNum":"  325","line":"        /// as `bytes.len`. The purpose of this function existing is to match `std.io.Writer` API."},
{"lineNum":"  326","line":"        fn appendWrite(self: *Self, bytes: []const u8) error{OutOfMemory}!usize {"},
{"lineNum":"  327","line":"            try self.write(bytes);"},
{"lineNum":"  328","line":"            return bytes.len;"},
{"lineNum":"  329","line":"        }"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"        pub fn writer(self: *Self) Writer {"},
{"lineNum":"  332","line":"            return .{ .context = self };"},
{"lineNum":"  333","line":"        }"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"        /// Make `count` items available before the current read location"},
{"lineNum":"  336","line":"        fn rewind(self: *Self, count: usize) void {"},
{"lineNum":"  337","line":"            assert(self.writableLength() >= count);"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"            var head = self.head + (self.buf.len - count);"},
{"lineNum":"  340","line":"            if (powers_of_two) {"},
{"lineNum":"  341","line":"                head &= self.buf.len - 1;"},
{"lineNum":"  342","line":"            } else {"},
{"lineNum":"  343","line":"                head %= self.buf.len;"},
{"lineNum":"  344","line":"            }"},
{"lineNum":"  345","line":"            self.head = head;"},
{"lineNum":"  346","line":"            self.count += count;"},
{"lineNum":"  347","line":"        }"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"        /// Place data back into the read stream"},
{"lineNum":"  350","line":"        pub fn unget(self: *Self, src: []const T) !void {"},
{"lineNum":"  351","line":"            try self.ensureUnusedCapacity(src.len);"},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"            self.rewind(src.len);"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"            const slice = self.readableSliceMut(0);"},
{"lineNum":"  356","line":"            if (src.len < slice.len) {"},
{"lineNum":"  357","line":"                mem.copy(T, slice, src);"},
{"lineNum":"  358","line":"            } else {"},
{"lineNum":"  359","line":"                mem.copy(T, slice, src[0..slice.len]);"},
{"lineNum":"  360","line":"                const slice2 = self.readableSliceMut(slice.len);"},
{"lineNum":"  361","line":"                mem.copy(T, slice2, src[slice.len..]);"},
{"lineNum":"  362","line":"            }"},
{"lineNum":"  363","line":"        }"},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"        /// Returns the item at `offset`."},
{"lineNum":"  366","line":"        /// Asserts offset is within bounds."},
{"lineNum":"  367","line":"        pub fn peekItem(self: Self, offset: usize) T {"},
{"lineNum":"  368","line":"            assert(offset < self.count);"},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"            var index = self.head + offset;"},
{"lineNum":"  371","line":"            if (powers_of_two) {"},
{"lineNum":"  372","line":"                index &= self.buf.len - 1;"},
{"lineNum":"  373","line":"            } else {"},
{"lineNum":"  374","line":"                index %= self.buf.len;"},
{"lineNum":"  375","line":"            }"},
{"lineNum":"  376","line":"            return self.buf[index];"},
{"lineNum":"  377","line":"        }"},
{"lineNum":"  378","line":""},
{"lineNum":"  379","line":"        /// Pump data from a reader into a writer"},
{"lineNum":"  380","line":"        /// stops when reader returns 0 bytes (EOF)"},
{"lineNum":"  381","line":"        /// Buffer size must be set before calling; a buffer length of 0 is invalid."},
{"lineNum":"  382","line":"        pub fn pump(self: *Self, src_reader: anytype, dest_writer: anytype) !void {"},
{"lineNum":"  383","line":"            assert(self.buf.len > 0);"},
{"lineNum":"  384","line":"            while (true) {"},
{"lineNum":"  385","line":"                if (self.writableLength() > 0) {"},
{"lineNum":"  386","line":"                    const n = try src_reader.read(self.writableSlice(0));"},
{"lineNum":"  387","line":"                    if (n == 0) break; // EOF"},
{"lineNum":"  388","line":"                    self.update(n);"},
{"lineNum":"  389","line":"                }"},
{"lineNum":"  390","line":"                self.discard(try dest_writer.write(self.readableSlice(0)));"},
{"lineNum":"  391","line":"            }"},
{"lineNum":"  392","line":"            // flush remaining data"},
{"lineNum":"  393","line":"            while (self.readableLength() > 0) {"},
{"lineNum":"  394","line":"                self.discard(try dest_writer.write(self.readableSlice(0)));"},
{"lineNum":"  395","line":"            }"},
{"lineNum":"  396","line":"        }"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":"        pub fn toOwnedSlice(self: *Self) Allocator.Error![]T {"},
{"lineNum":"  399","line":"            if (self.head != 0) self.realign();"},
{"lineNum":"  400","line":"            assert(self.head == 0);"},
{"lineNum":"  401","line":"            assert(self.count <= self.buf.len);"},
{"lineNum":"  402","line":"            const allocator = self.allocator;"},
{"lineNum":"  403","line":"            if (allocator.resize(self.buf, self.count)) {"},
{"lineNum":"  404","line":"                const result = self.buf[0..self.count];"},
{"lineNum":"  405","line":"                self.* = Self.init(allocator);"},
{"lineNum":"  406","line":"                return result;"},
{"lineNum":"  407","line":"            }"},
{"lineNum":"  408","line":"            const new_memory = try allocator.dupe(T, self.buf[0..self.count]);"},
{"lineNum":"  409","line":"            allocator.free(self.buf);"},
{"lineNum":"  410","line":"            self.* = Self.init(allocator);"},
{"lineNum":"  411","line":"            return new_memory;"},
{"lineNum":"  412","line":"        }"},
{"lineNum":"  413","line":"    };"},
{"lineNum":"  414","line":"}"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"test \"LinearFifo(u8, .Dynamic) discard(0) from empty buffer should not error on overflow\" {"},
{"lineNum":"  417","line":"    var fifo = LinearFifo(u8, .Dynamic).init(testing.allocator);"},
{"lineNum":"  418","line":"    defer fifo.deinit();"},
{"lineNum":"  419","line":""},
{"lineNum":"  420","line":"    // If overflow is not explicitly allowed this will crash in debug / safe mode"},
{"lineNum":"  421","line":"    fifo.discard(0);"},
{"lineNum":"  422","line":"}"},
{"lineNum":"  423","line":""},
{"lineNum":"  424","line":"test \"LinearFifo(u8, .Dynamic)\" {"},
{"lineNum":"  425","line":"    var fifo = LinearFifo(u8, .Dynamic).init(testing.allocator);"},
{"lineNum":"  426","line":"    defer fifo.deinit();"},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"    try fifo.write(\"HELLO\");"},
{"lineNum":"  429","line":"    try testing.expectEqual(@as(usize, 5), fifo.readableLength());"},
{"lineNum":"  430","line":"    try testing.expectEqualSlices(u8, \"HELLO\", fifo.readableSlice(0));"},
{"lineNum":"  431","line":""},
{"lineNum":"  432","line":"    {"},
{"lineNum":"  433","line":"        var i: usize = 0;"},
{"lineNum":"  434","line":"        while (i < 5) : (i += 1) {"},
{"lineNum":"  435","line":"            try fifo.write(&[_]u8{fifo.peekItem(i)});"},
{"lineNum":"  436","line":"        }"},
{"lineNum":"  437","line":"        try testing.expectEqual(@as(usize, 10), fifo.readableLength());"},
{"lineNum":"  438","line":"        try testing.expectEqualSlices(u8, \"HELLOHELLO\", fifo.readableSlice(0));"},
{"lineNum":"  439","line":"    }"},
{"lineNum":"  440","line":""},
{"lineNum":"  441","line":"    {"},
{"lineNum":"  442","line":"        try testing.expectEqual(@as(u8, \'H\'), fifo.readItem().?);"},
{"lineNum":"  443","line":"        try testing.expectEqual(@as(u8, \'E\'), fifo.readItem().?);"},
{"lineNum":"  444","line":"        try testing.expectEqual(@as(u8, \'L\'), fifo.readItem().?);"},
{"lineNum":"  445","line":"        try testing.expectEqual(@as(u8, \'L\'), fifo.readItem().?);"},
{"lineNum":"  446","line":"        try testing.expectEqual(@as(u8, \'O\'), fifo.readItem().?);"},
{"lineNum":"  447","line":"    }"},
{"lineNum":"  448","line":"    try testing.expectEqual(@as(usize, 5), fifo.readableLength());"},
{"lineNum":"  449","line":""},
{"lineNum":"  450","line":"    { // Writes that wrap around"},
{"lineNum":"  451","line":"        try testing.expectEqual(@as(usize, 11), fifo.writableLength());"},
{"lineNum":"  452","line":"        try testing.expectEqual(@as(usize, 6), fifo.writableSlice(0).len);"},
{"lineNum":"  453","line":"        fifo.writeAssumeCapacity(\"6<chars<11\");"},
{"lineNum":"  454","line":"        try testing.expectEqualSlices(u8, \"HELLO6<char\", fifo.readableSlice(0));"},
{"lineNum":"  455","line":"        try testing.expectEqualSlices(u8, \"s<11\", fifo.readableSlice(11));"},
{"lineNum":"  456","line":"        try testing.expectEqualSlices(u8, \"11\", fifo.readableSlice(13));"},
{"lineNum":"  457","line":"        try testing.expectEqualSlices(u8, \"\", fifo.readableSlice(15));"},
{"lineNum":"  458","line":"        fifo.discard(11);"},
{"lineNum":"  459","line":"        try testing.expectEqualSlices(u8, \"s<11\", fifo.readableSlice(0));"},
{"lineNum":"  460","line":"        fifo.discard(4);"},
{"lineNum":"  461","line":"        try testing.expectEqual(@as(usize, 0), fifo.readableLength());"},
{"lineNum":"  462","line":"    }"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"    {"},
{"lineNum":"  465","line":"        const buf = try fifo.writableWithSize(12);"},
{"lineNum":"  466","line":"        try testing.expectEqual(@as(usize, 12), buf.len);"},
{"lineNum":"  467","line":"        var i: u8 = 0;"},
{"lineNum":"  468","line":"        while (i < 10) : (i += 1) {"},
{"lineNum":"  469","line":"            buf[i] = i + \'a\';"},
{"lineNum":"  470","line":"        }"},
{"lineNum":"  471","line":"        fifo.update(10);"},
{"lineNum":"  472","line":"        try testing.expectEqualSlices(u8, \"abcdefghij\", fifo.readableSlice(0));"},
{"lineNum":"  473","line":"    }"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"    {"},
{"lineNum":"  476","line":"        try fifo.unget(\"prependedstring\");"},
{"lineNum":"  477","line":"        var result: [30]u8 = undefined;"},
{"lineNum":"  478","line":"        try testing.expectEqualSlices(u8, \"prependedstringabcdefghij\", result[0..fifo.read(&result)]);"},
{"lineNum":"  479","line":"        try fifo.unget(\"b\");"},
{"lineNum":"  480","line":"        try fifo.unget(\"a\");"},
{"lineNum":"  481","line":"        try testing.expectEqualSlices(u8, \"ab\", result[0..fifo.read(&result)]);"},
{"lineNum":"  482","line":"    }"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"    fifo.shrink(0);"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"    {"},
{"lineNum":"  487","line":"        try fifo.writer().print(\"{s}, {s}!\", .{ \"Hello\", \"World\" });"},
{"lineNum":"  488","line":"        var result: [30]u8 = undefined;"},
{"lineNum":"  489","line":"        try testing.expectEqualSlices(u8, \"Hello, World!\", result[0..fifo.read(&result)]);"},
{"lineNum":"  490","line":"        try testing.expectEqual(@as(usize, 0), fifo.readableLength());"},
{"lineNum":"  491","line":"    }"},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"    {"},
{"lineNum":"  494","line":"        try fifo.writer().writeAll(\"This is a test\");"},
{"lineNum":"  495","line":"        var result: [30]u8 = undefined;"},
{"lineNum":"  496","line":"        try testing.expectEqualSlices(u8, \"This\", (try fifo.reader().readUntilDelimiterOrEof(&result, \' \')).?);"},
{"lineNum":"  497","line":"        try testing.expectEqualSlices(u8, \"is\", (try fifo.reader().readUntilDelimiterOrEof(&result, \' \')).?);"},
{"lineNum":"  498","line":"        try testing.expectEqualSlices(u8, \"a\", (try fifo.reader().readUntilDelimiterOrEof(&result, \' \')).?);"},
{"lineNum":"  499","line":"        try testing.expectEqualSlices(u8, \"test\", (try fifo.reader().readUntilDelimiterOrEof(&result, \' \')).?);"},
{"lineNum":"  500","line":"    }"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":"    {"},
{"lineNum":"  503","line":"        try fifo.ensureTotalCapacity(1);"},
{"lineNum":"  504","line":"        var in_fbs = std.io.fixedBufferStream(\"pump test\");"},
{"lineNum":"  505","line":"        var out_buf: [50]u8 = undefined;"},
{"lineNum":"  506","line":"        var out_fbs = std.io.fixedBufferStream(&out_buf);"},
{"lineNum":"  507","line":"        try fifo.pump(in_fbs.reader(), out_fbs.writer());"},
{"lineNum":"  508","line":"        try testing.expectEqualSlices(u8, in_fbs.buffer, out_fbs.getWritten());"},
{"lineNum":"  509","line":"    }"},
{"lineNum":"  510","line":"}"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"test \"LinearFifo\" {"},
{"lineNum":"  513","line":"    inline for ([_]type{ u1, u8, u16, u64 }) |T| {"},
{"lineNum":"  514","line":"        inline for ([_]LinearFifoBufferType{ LinearFifoBufferType{ .Static = 32 }, .Slice, .Dynamic }) |bt| {"},
{"lineNum":"  515","line":"            const FifoType = LinearFifo(T, bt);"},
{"lineNum":"  516","line":"            var buf: if (bt == .Slice) [32]T else void = undefined;"},
{"lineNum":"  517","line":"            var fifo = switch (bt) {"},
{"lineNum":"  518","line":"                .Static => FifoType.init(),"},
{"lineNum":"  519","line":"                .Slice => FifoType.init(buf[0..]),"},
{"lineNum":"  520","line":"                .Dynamic => FifoType.init(testing.allocator),"},
{"lineNum":"  521","line":"            };"},
{"lineNum":"  522","line":"            defer fifo.deinit();"},
{"lineNum":"  523","line":""},
{"lineNum":"  524","line":"            try fifo.write(&[_]T{ 0, 1, 1, 0, 1 });"},
{"lineNum":"  525","line":"            try testing.expectEqual(@as(usize, 5), fifo.readableLength());"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"            {"},
{"lineNum":"  528","line":"                try testing.expectEqual(@as(T, 0), fifo.readItem().?);"},
{"lineNum":"  529","line":"                try testing.expectEqual(@as(T, 1), fifo.readItem().?);"},
{"lineNum":"  530","line":"                try testing.expectEqual(@as(T, 1), fifo.readItem().?);"},
{"lineNum":"  531","line":"                try testing.expectEqual(@as(T, 0), fifo.readItem().?);"},
{"lineNum":"  532","line":"                try testing.expectEqual(@as(T, 1), fifo.readItem().?);"},
{"lineNum":"  533","line":"                try testing.expectEqual(@as(usize, 0), fifo.readableLength());"},
{"lineNum":"  534","line":"            }"},
{"lineNum":"  535","line":""},
{"lineNum":"  536","line":"            {"},
{"lineNum":"  537","line":"                try fifo.writeItem(1);"},
{"lineNum":"  538","line":"                try fifo.writeItem(1);"},
{"lineNum":"  539","line":"                try fifo.writeItem(1);"},
{"lineNum":"  540","line":"                try testing.expectEqual(@as(usize, 3), fifo.readableLength());"},
{"lineNum":"  541","line":"            }"},
{"lineNum":"  542","line":""},
{"lineNum":"  543","line":"            {"},
{"lineNum":"  544","line":"                var readBuf: [3]T = undefined;"},
{"lineNum":"  545","line":"                const n = fifo.read(&readBuf);"},
{"lineNum":"  546","line":"                try testing.expectEqual(@as(usize, 3), n); // NOTE: It should be the number of items."},
{"lineNum":"  547","line":"            }"},
{"lineNum":"  548","line":"        }"},
{"lineNum":"  549","line":"    }"},
{"lineNum":"  550","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 70, "covered" : 0,};
var merged_data = [];
