var data = {lines:[
{"lineNum":"    1","line":"//! The standard memory allocation interface."},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"const std = @import(\"../std.zig\");"},
{"lineNum":"    4","line":"const assert = std.debug.assert;"},
{"lineNum":"    5","line":"const math = std.math;"},
{"lineNum":"    6","line":"const mem = std.mem;"},
{"lineNum":"    7","line":"const Allocator = @This();"},
{"lineNum":"    8","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"pub const Error = error{OutOfMemory};"},
{"lineNum":"   11","line":"pub const Log2Align = math.Log2Int(usize);"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"// The type erased pointer to the allocator implementation"},
{"lineNum":"   14","line":"ptr: *anyopaque,"},
{"lineNum":"   15","line":"vtable: *const VTable,"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"pub const VTable = struct {"},
{"lineNum":"   18","line":"    /// Attempt to allocate exactly `len` bytes aligned to `1 << ptr_align`."},
{"lineNum":"   19","line":"    ///"},
{"lineNum":"   20","line":"    /// `ret_addr` is optionally provided as the first return address of the"},
{"lineNum":"   21","line":"    /// allocation call stack. If the value is `0` it means no return address"},
{"lineNum":"   22","line":"    /// has been provided."},
{"lineNum":"   23","line":"    alloc: *const fn (ctx: *anyopaque, len: usize, ptr_align: u8, ret_addr: usize) ?[*]u8,"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"    /// Attempt to expand or shrink memory in place. `buf.len` must equal the"},
{"lineNum":"   26","line":"    /// length requested from the most recent successful call to `alloc` or"},
{"lineNum":"   27","line":"    /// `resize`. `buf_align` must equal the same value that was passed as the"},
{"lineNum":"   28","line":"    /// `ptr_align` parameter to the original `alloc` call."},
{"lineNum":"   29","line":"    ///"},
{"lineNum":"   30","line":"    /// A result of `true` indicates the resize was successful and the"},
{"lineNum":"   31","line":"    /// allocation now has the same address but a size of `new_len`. `false`"},
{"lineNum":"   32","line":"    /// indicates the resize could not be completed without moving the"},
{"lineNum":"   33","line":"    /// allocation to a different address."},
{"lineNum":"   34","line":"    ///"},
{"lineNum":"   35","line":"    /// `new_len` must be greater than zero."},
{"lineNum":"   36","line":"    ///"},
{"lineNum":"   37","line":"    /// `ret_addr` is optionally provided as the first return address of the"},
{"lineNum":"   38","line":"    /// allocation call stack. If the value is `0` it means no return address"},
{"lineNum":"   39","line":"    /// has been provided."},
{"lineNum":"   40","line":"    resize: *const fn (ctx: *anyopaque, buf: []u8, buf_align: u8, new_len: usize, ret_addr: usize) bool,"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"    /// Free and invalidate a buffer."},
{"lineNum":"   43","line":"    ///"},
{"lineNum":"   44","line":"    /// `buf.len` must equal the most recent length returned by `alloc` or"},
{"lineNum":"   45","line":"    /// given to a successful `resize` call."},
{"lineNum":"   46","line":"    ///"},
{"lineNum":"   47","line":"    /// `buf_align` must equal the same value that was passed as the"},
{"lineNum":"   48","line":"    /// `ptr_align` parameter to the original `alloc` call."},
{"lineNum":"   49","line":"    ///"},
{"lineNum":"   50","line":"    /// `ret_addr` is optionally provided as the first return address of the"},
{"lineNum":"   51","line":"    /// allocation call stack. If the value is `0` it means no return address"},
{"lineNum":"   52","line":"    /// has been provided."},
{"lineNum":"   53","line":"    free: *const fn (ctx: *anyopaque, buf: []u8, buf_align: u8, ret_addr: usize) void,"},
{"lineNum":"   54","line":"};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"pub fn noResize("},
{"lineNum":"   57","line":"    self: *anyopaque,"},
{"lineNum":"   58","line":"    buf: []u8,"},
{"lineNum":"   59","line":"    log2_buf_align: u8,"},
{"lineNum":"   60","line":"    new_len: usize,"},
{"lineNum":"   61","line":"    ret_addr: usize,"},
{"lineNum":"   62","line":") bool {"},
{"lineNum":"   63","line":"    _ = self;"},
{"lineNum":"   64","line":"    _ = buf;"},
{"lineNum":"   65","line":"    _ = log2_buf_align;"},
{"lineNum":"   66","line":"    _ = new_len;"},
{"lineNum":"   67","line":"    _ = ret_addr;"},
{"lineNum":"   68","line":"    return false;"},
{"lineNum":"   69","line":"}"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"pub fn noFree("},
{"lineNum":"   72","line":"    self: *anyopaque,"},
{"lineNum":"   73","line":"    buf: []u8,"},
{"lineNum":"   74","line":"    log2_buf_align: u8,"},
{"lineNum":"   75","line":"    ret_addr: usize,"},
{"lineNum":"   76","line":") void {"},
{"lineNum":"   77","line":"    _ = self;"},
{"lineNum":"   78","line":"    _ = buf;"},
{"lineNum":"   79","line":"    _ = log2_buf_align;"},
{"lineNum":"   80","line":"    _ = ret_addr;"},
{"lineNum":"   81","line":"}"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"/// This function is not intended to be called except from within the"},
{"lineNum":"   84","line":"/// implementation of an Allocator"},
{"lineNum":"   85","line":"pub inline fn rawAlloc(self: Allocator, len: usize, ptr_align: u8, ret_addr: usize) ?[*]u8 {"},
{"lineNum":"   86","line":"    return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);","class":"linePartCov","hits":"10","order":"226","possible_hits":"22",},
{"lineNum":"   87","line":"}"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"/// This function is not intended to be called except from within the"},
{"lineNum":"   90","line":"/// implementation of an Allocator"},
{"lineNum":"   91","line":"pub inline fn rawResize(self: Allocator, buf: []u8, log2_buf_align: u8, new_len: usize, ret_addr: usize) bool {"},
{"lineNum":"   92","line":"    return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);","class":"linePartCov","hits":"3","order":"1092","possible_hits":"15",},
{"lineNum":"   93","line":"}"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"/// This function is not intended to be called except from within the"},
{"lineNum":"   96","line":"/// implementation of an Allocator"},
{"lineNum":"   97","line":"pub inline fn rawFree(self: Allocator, buf: []u8, log2_buf_align: u8, ret_addr: usize) void {"},
{"lineNum":"   98","line":"    return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);","class":"linePartCov","hits":"8","order":"316","possible_hits":"22",},
{"lineNum":"   99","line":"}"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"/// Returns a pointer to undefined memory."},
{"lineNum":"  102","line":"/// Call `destroy` with the result to free the memory."},
{"lineNum":"  103","line":"pub fn create(self: Allocator, comptime T: type) Error!*T {","class":"linePartCov","hits":"1","order":"1307","possible_hits":"3",},
{"lineNum":"  104","line":"    if (@sizeOf(T) == 0) return @intToPtr(*T, math.maxInt(usize));"},
{"lineNum":"  105","line":"    const slice = try self.allocAdvancedWithRetAddr(T, null, 1, @returnAddress());","class":"linePartCov","hits":"1","order":"1308","possible_hits":"3",},
{"lineNum":"  106","line":"    return &slice[0];","class":"linePartCov","hits":"1","order":"1338","possible_hits":"3",},
{"lineNum":"  107","line":"}"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"/// `ptr` should be the return value of `create`, or otherwise"},
{"lineNum":"  110","line":"/// have the same address and alignment property."},
{"lineNum":"  111","line":"pub fn destroy(self: Allocator, ptr: anytype) void {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  112","line":"    const info = @typeInfo(@TypeOf(ptr)).Pointer;"},
{"lineNum":"  113","line":"    const T = info.child;"},
{"lineNum":"  114","line":"    if (@sizeOf(T) == 0) return;"},
{"lineNum":"  115","line":"    const non_const_ptr = @ptrCast([*]u8, @constCast(ptr));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  116","line":"    self.rawFree(non_const_ptr[0..@sizeOf(T)], math.log2(info.alignment), @returnAddress());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  117","line":"}"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"/// Allocates an array of `n` items of type `T` and sets all the"},
{"lineNum":"  120","line":"/// items to `undefined`. Depending on the Allocator"},
{"lineNum":"  121","line":"/// implementation, it may be required to call `free` once the"},
{"lineNum":"  122","line":"/// memory is no longer needed, to avoid a resource leak. If the"},
{"lineNum":"  123","line":"/// `Allocator` implementation is unknown, then correct code will"},
{"lineNum":"  124","line":"/// call `free` when done."},
{"lineNum":"  125","line":"///"},
{"lineNum":"  126","line":"/// For allocating a single item, see `create`."},
{"lineNum":"  127","line":"pub fn alloc(self: Allocator, comptime T: type, n: usize) Error![]T {","class":"linePartCov","hits":"1","order":"1502","possible_hits":"2",},
{"lineNum":"  128","line":"    return self.allocAdvancedWithRetAddr(T, null, n, @returnAddress());","class":"linePartCov","hits":"1","order":"1503","possible_hits":"2",},
{"lineNum":"  129","line":"}"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"pub fn allocWithOptions("},
{"lineNum":"  132","line":"    self: Allocator,"},
{"lineNum":"  133","line":"    comptime Elem: type,"},
{"lineNum":"  134","line":"    n: usize,"},
{"lineNum":"  135","line":"    /// null means naturally aligned"},
{"lineNum":"  136","line":"    comptime optional_alignment: ?u29,"},
{"lineNum":"  137","line":"    comptime optional_sentinel: ?Elem,"},
{"lineNum":"  138","line":") Error!AllocWithOptionsPayload(Elem, optional_alignment, optional_sentinel) {"},
{"lineNum":"  139","line":"    return self.allocWithOptionsRetAddr(Elem, n, optional_alignment, optional_sentinel, @returnAddress());"},
{"lineNum":"  140","line":"}"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"pub fn allocWithOptionsRetAddr("},
{"lineNum":"  143","line":"    self: Allocator,"},
{"lineNum":"  144","line":"    comptime Elem: type,"},
{"lineNum":"  145","line":"    n: usize,"},
{"lineNum":"  146","line":"    /// null means naturally aligned"},
{"lineNum":"  147","line":"    comptime optional_alignment: ?u29,"},
{"lineNum":"  148","line":"    comptime optional_sentinel: ?Elem,"},
{"lineNum":"  149","line":"    return_address: usize,"},
{"lineNum":"  150","line":") Error!AllocWithOptionsPayload(Elem, optional_alignment, optional_sentinel) {"},
{"lineNum":"  151","line":"    if (optional_sentinel) |sentinel| {"},
{"lineNum":"  152","line":"        const ptr = try self.allocAdvancedWithRetAddr(Elem, optional_alignment, n + 1, return_address);"},
{"lineNum":"  153","line":"        ptr[n] = sentinel;"},
{"lineNum":"  154","line":"        return ptr[0..n :sentinel];"},
{"lineNum":"  155","line":"    } else {"},
{"lineNum":"  156","line":"        return self.allocAdvancedWithRetAddr(Elem, optional_alignment, n, return_address);"},
{"lineNum":"  157","line":"    }"},
{"lineNum":"  158","line":"}"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"fn AllocWithOptionsPayload(comptime Elem: type, comptime alignment: ?u29, comptime sentinel: ?Elem) type {"},
{"lineNum":"  161","line":"    if (sentinel) |s| {"},
{"lineNum":"  162","line":"        return [:s]align(alignment orelse @alignOf(Elem)) Elem;"},
{"lineNum":"  163","line":"    } else {"},
{"lineNum":"  164","line":"        return []align(alignment orelse @alignOf(Elem)) Elem;"},
{"lineNum":"  165","line":"    }"},
{"lineNum":"  166","line":"}"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"/// Allocates an array of `n + 1` items of type `T` and sets the first `n`"},
{"lineNum":"  169","line":"/// items to `undefined` and the last item to `sentinel`. Depending on the"},
{"lineNum":"  170","line":"/// Allocator implementation, it may be required to call `free` once the"},
{"lineNum":"  171","line":"/// memory is no longer needed, to avoid a resource leak. If the"},
{"lineNum":"  172","line":"/// `Allocator` implementation is unknown, then correct code will"},
{"lineNum":"  173","line":"/// call `free` when done."},
{"lineNum":"  174","line":"///"},
{"lineNum":"  175","line":"/// For allocating a single item, see `create`."},
{"lineNum":"  176","line":"pub fn allocSentinel("},
{"lineNum":"  177","line":"    self: Allocator,"},
{"lineNum":"  178","line":"    comptime Elem: type,"},
{"lineNum":"  179","line":"    n: usize,"},
{"lineNum":"  180","line":"    comptime sentinel: Elem,"},
{"lineNum":"  181","line":") Error![:sentinel]Elem {"},
{"lineNum":"  182","line":"    return self.allocWithOptionsRetAddr(Elem, n, null, sentinel, @returnAddress());"},
{"lineNum":"  183","line":"}"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"pub fn alignedAlloc("},
{"lineNum":"  186","line":"    self: Allocator,"},
{"lineNum":"  187","line":"    comptime T: type,"},
{"lineNum":"  188","line":"    /// null means naturally aligned"},
{"lineNum":"  189","line":"    comptime alignment: ?u29,"},
{"lineNum":"  190","line":"    n: usize,"},
{"lineNum":"  191","line":") Error![]align(alignment orelse @alignOf(T)) T {","class":"linePartCov","hits":"7","order":"215","possible_hits":"14",},
{"lineNum":"  192","line":"    return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());","class":"linePartCov","hits":"7","order":"216","possible_hits":"14",},
{"lineNum":"  193","line":"}"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"pub fn allocAdvancedWithRetAddr("},
{"lineNum":"  196","line":"    self: Allocator,"},
{"lineNum":"  197","line":"    comptime T: type,"},
{"lineNum":"  198","line":"    /// null means naturally aligned"},
{"lineNum":"  199","line":"    comptime alignment: ?u29,"},
{"lineNum":"  200","line":"    n: usize,"},
{"lineNum":"  201","line":"    return_address: usize,"},
{"lineNum":"  202","line":") Error![]align(alignment orelse @alignOf(T)) T {","class":"linePartCov","hits":"8","order":"217","possible_hits":"19",},
{"lineNum":"  203","line":"    const a = alignment orelse @alignOf(T);","class":"linePartCov","hits":"2","order":"294","possible_hits":"3",},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"    // The Zig Allocator interface is not intended to solve alignments beyond"},
{"lineNum":"  206","line":"    // the minimum OS page size. For these use cases, the caller must use OS"},
{"lineNum":"  207","line":"    // APIs directly."},
{"lineNum":"  208","line":"    comptime assert(a <= mem.page_size);"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"    if (n == 0) {","class":"linePartCov","hits":"8","order":"218","possible_hits":"19",},
{"lineNum":"  211","line":"        const ptr = comptime std.mem.alignBackward(math.maxInt(usize), a);","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  212","line":"        return @intToPtr([*]align(a) T, ptr)[0..0];","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  213","line":"    }"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"    const byte_count = math.mul(usize, @sizeOf(T), n) catch return Error.OutOfMemory;","class":"linePartCov","hits":"8","order":"219","possible_hits":"19",},
{"lineNum":"  216","line":"    const byte_ptr = self.rawAlloc(byte_count, log2a(a), return_address) orelse return Error.OutOfMemory;","class":"linePartCov","hits":"8","order":"224","possible_hits":"38",},
{"lineNum":"  217","line":"    // TODO: https://github.com/ziglang/zig/issues/4298"},
{"lineNum":"  218","line":"    @memset(byte_ptr, undefined, byte_count);","class":"linePartCov","hits":"8","order":"242","possible_hits":"19",},
{"lineNum":"  219","line":"    const byte_slice = byte_ptr[0..byte_count];","class":"linePartCov","hits":"8","order":"243","possible_hits":"19",},
{"lineNum":"  220","line":"    return mem.bytesAsSlice(T, @alignCast(a, byte_slice));","class":"linePartCov","hits":"8","order":"244","possible_hits":"19",},
{"lineNum":"  221","line":"}"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"/// Requests to modify the size of an allocation. It is guaranteed to not move"},
{"lineNum":"  224","line":"/// the pointer, however the allocator implementation may refuse the resize"},
{"lineNum":"  225","line":"/// request by returning `false`."},
{"lineNum":"  226","line":"pub fn resize(self: Allocator, old_mem: anytype, new_n: usize) bool {","class":"linePartCov","hits":"5","order":"210","possible_hits":"12",},
{"lineNum":"  227","line":"    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;"},
{"lineNum":"  228","line":"    const T = Slice.child;"},
{"lineNum":"  229","line":"    if (new_n == 0) {","class":"linePartCov","hits":"5","order":"211","possible_hits":"12",},
{"lineNum":"  230","line":"        self.free(old_mem);","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  231","line":"        return true;","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  232","line":"    }"},
{"lineNum":"  233","line":"    if (old_mem.len == 0) {","class":"linePartCov","hits":"5","order":"212","possible_hits":"12",},
{"lineNum":"  234","line":"        return false;","class":"linePartCov","hits":"5","order":"213","possible_hits":"12",},
{"lineNum":"  235","line":"    }"},
{"lineNum":"  236","line":"    const old_byte_slice = mem.sliceAsBytes(old_mem);","class":"linePartCov","hits":"1","order":"1089","possible_hits":"12",},
{"lineNum":"  237","line":"    // I would like to use saturating multiplication here, but LLVM cannot lower it"},
{"lineNum":"  238","line":"    // on WebAssembly: https://github.com/ziglang/zig/issues/9660"},
{"lineNum":"  239","line":"    //const new_byte_count = new_n *| @sizeOf(T);"},
{"lineNum":"  240","line":"    const new_byte_count = math.mul(usize, @sizeOf(T), new_n) catch return false;","class":"linePartCov","hits":"1","order":"1090","possible_hits":"12",},
{"lineNum":"  241","line":"    return self.rawResize(old_byte_slice, log2a(Slice.alignment), new_byte_count, @returnAddress());","class":"linePartCov","hits":"2","order":"1091","possible_hits":"24",},
{"lineNum":"  242","line":"}"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"/// This function requests a new byte size for an existing allocation, which"},
{"lineNum":"  245","line":"/// can be larger, smaller, or the same size as the old memory allocation."},
{"lineNum":"  246","line":"/// If `new_n` is 0, this is the same as `free` and it always succeeds."},
{"lineNum":"  247","line":"pub fn realloc(self: Allocator, old_mem: anytype, new_n: usize) t: {"},
{"lineNum":"  248","line":"    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;"},
{"lineNum":"  249","line":"    break :t Error![]align(Slice.alignment) Slice.child;"},
{"lineNum":"  250","line":"} {","class":"lineCov","hits":"1","order":"1527","possible_hits":"1",},
{"lineNum":"  251","line":"    return self.reallocAdvanced(old_mem, new_n, @returnAddress());","class":"lineCov","hits":"1","order":"1528","possible_hits":"1",},
{"lineNum":"  252","line":"}"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"pub fn reallocAdvanced("},
{"lineNum":"  255","line":"    self: Allocator,"},
{"lineNum":"  256","line":"    old_mem: anytype,"},
{"lineNum":"  257","line":"    new_n: usize,"},
{"lineNum":"  258","line":"    return_address: usize,"},
{"lineNum":"  259","line":") t: {"},
{"lineNum":"  260","line":"    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;"},
{"lineNum":"  261","line":"    break :t Error![]align(Slice.alignment) Slice.child;"},
{"lineNum":"  262","line":"} {","class":"lineCov","hits":"1","order":"1529","possible_hits":"1",},
{"lineNum":"  263","line":"    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;"},
{"lineNum":"  264","line":"    const T = Slice.child;"},
{"lineNum":"  265","line":"    if (old_mem.len == 0) {","class":"lineCov","hits":"1","order":"1530","possible_hits":"1",},
{"lineNum":"  266","line":"        return self.allocAdvancedWithRetAddr(T, Slice.alignment, new_n, return_address);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  267","line":"    }"},
{"lineNum":"  268","line":"    if (new_n == 0) {","class":"lineCov","hits":"1","order":"1531","possible_hits":"1",},
{"lineNum":"  269","line":"        self.free(old_mem);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  270","line":"        const ptr = comptime std.mem.alignBackward(math.maxInt(usize), Slice.alignment);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  271","line":"        return @intToPtr([*]align(Slice.alignment) T, ptr)[0..0];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  272","line":"    }"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"    const old_byte_slice = mem.sliceAsBytes(old_mem);","class":"lineCov","hits":"1","order":"1532","possible_hits":"1",},
{"lineNum":"  275","line":"    const byte_count = math.mul(usize, @sizeOf(T), new_n) catch return Error.OutOfMemory;","class":"lineCov","hits":"1","order":"1533","possible_hits":"1",},
{"lineNum":"  276","line":"    // Note: can\'t set shrunk memory to undefined as memory shouldn\'t be modified on realloc failure"},
{"lineNum":"  277","line":"    if (mem.isAligned(@ptrToInt(old_byte_slice.ptr), Slice.alignment)) {","class":"lineCov","hits":"1","order":"1534","possible_hits":"1",},
{"lineNum":"  278","line":"        if (self.rawResize(old_byte_slice, log2a(Slice.alignment), byte_count, return_address)) {","class":"lineCov","hits":"1","order":"1535","possible_hits":"1",},
{"lineNum":"  279","line":"            return mem.bytesAsSlice(T, @alignCast(Slice.alignment, old_byte_slice.ptr[0..byte_count]));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  280","line":"        }"},
{"lineNum":"  281","line":"    }"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"    const new_mem = self.rawAlloc(byte_count, log2a(Slice.alignment), return_address) orelse","class":"lineCov","hits":"1","order":"1540","possible_hits":"1",},
{"lineNum":"  284","line":"        return error.OutOfMemory;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  285","line":"    @memcpy(new_mem, old_byte_slice.ptr, @min(byte_count, old_byte_slice.len));","class":"lineCov","hits":"1","order":"1541","possible_hits":"1",},
{"lineNum":"  286","line":"    // TODO https://github.com/ziglang/zig/issues/4298"},
{"lineNum":"  287","line":"    @memset(old_byte_slice.ptr, undefined, old_byte_slice.len);","class":"lineCov","hits":"1","order":"1542","possible_hits":"1",},
{"lineNum":"  288","line":"    self.rawFree(old_byte_slice, log2a(Slice.alignment), return_address);","class":"lineCov","hits":"1","order":"1543","possible_hits":"1",},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"    return mem.bytesAsSlice(T, @alignCast(Slice.alignment, new_mem[0..byte_count]));","class":"lineCov","hits":"1","order":"1544","possible_hits":"1",},
{"lineNum":"  291","line":"}"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"/// Free an array allocated with `alloc`. To free a single item,"},
{"lineNum":"  294","line":"/// see `destroy`."},
{"lineNum":"  295","line":"pub fn free(self: Allocator, memory: anytype) void {","class":"linePartCov","hits":"7","order":"250","possible_hits":"17",},
{"lineNum":"  296","line":"    const Slice = @typeInfo(@TypeOf(memory)).Pointer;"},
{"lineNum":"  297","line":"    const bytes = mem.sliceAsBytes(memory);","class":"linePartCov","hits":"7","order":"251","possible_hits":"17",},
{"lineNum":"  298","line":"    const bytes_len = bytes.len + if (Slice.sentinel != null) @sizeOf(Slice.child) else 0;","class":"linePartCov","hits":"7","order":"255","possible_hits":"17",},
{"lineNum":"  299","line":"    if (bytes_len == 0) return;","class":"linePartCov","hits":"7","order":"256","possible_hits":"17",},
{"lineNum":"  300","line":"    const non_const_ptr = @constCast(bytes.ptr);","class":"linePartCov","hits":"6","order":"313","possible_hits":"17",},
{"lineNum":"  301","line":"    // TODO: https://github.com/ziglang/zig/issues/4298"},
{"lineNum":"  302","line":"    @memset(non_const_ptr, undefined, bytes_len);","class":"linePartCov","hits":"6","order":"314","possible_hits":"17",},
{"lineNum":"  303","line":"    self.rawFree(non_const_ptr[0..bytes_len], log2a(Slice.alignment), @returnAddress());","class":"linePartCov","hits":"6","order":"315","possible_hits":"17",},
{"lineNum":"  304","line":"}"},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"/// Copies `m` to newly allocated memory. Caller owns the memory."},
{"lineNum":"  307","line":"pub fn dupe(allocator: Allocator, comptime T: type, m: []const T) ![]T {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  308","line":"    const new_buf = try allocator.alloc(T, m.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  309","line":"    mem.copy(T, new_buf, m);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  310","line":"    return new_buf;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  311","line":"}"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"/// Copies `m` to newly allocated memory, with a null-terminated element. Caller owns the memory."},
{"lineNum":"  314","line":"pub fn dupeZ(allocator: Allocator, comptime T: type, m: []const T) ![:0]T {"},
{"lineNum":"  315","line":"    const new_buf = try allocator.alloc(T, m.len + 1);"},
{"lineNum":"  316","line":"    mem.copy(T, new_buf, m);"},
{"lineNum":"  317","line":"    new_buf[m.len] = 0;"},
{"lineNum":"  318","line":"    return new_buf[0..m.len :0];"},
{"lineNum":"  319","line":"}"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"/// TODO replace callsites with `@log2` after this proposal is implemented:"},
{"lineNum":"  322","line":"/// https://github.com/ziglang/zig/issues/13642"},
{"lineNum":"  323","line":"inline fn log2a(x: anytype) switch (@typeInfo(@TypeOf(x))) {"},
{"lineNum":"  324","line":"    .Int => math.Log2Int(@TypeOf(x)),","class":"linePartCov","hits":"2","order":"295","possible_hits":"3",},
{"lineNum":"  325","line":"    .ComptimeInt => comptime_int,"},
{"lineNum":"  326","line":"    else => @compileError(\"int please\"),"},
{"lineNum":"  327","line":"} {"},
{"lineNum":"  328","line":"    switch (@typeInfo(@TypeOf(x))) {"},
{"lineNum":"  329","line":"        .Int => return math.log2_int(@TypeOf(x), x),","class":"linePartCov","hits":"2","order":"296","possible_hits":"3",},
{"lineNum":"  330","line":"        .ComptimeInt => return math.log2(x),","class":"linePartCov","hits":"16","order":"225","possible_hits":"48",},
{"lineNum":"  331","line":"        else => @compileError(\"bad\"),"},
{"lineNum":"  332","line":"    }"},
{"lineNum":"  333","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2023-04-18 20:41:50", "instrumented" : 66, "covered" : 49,};
var merged_data = [];
