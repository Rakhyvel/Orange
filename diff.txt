diff --git a/src/ast/ast.zig b/src/ast/ast.zig
index c9eb966e..595f2346 100644
--- a/src/ast/ast.zig
+++ b/src/ast/ast.zig
@@ -15,6 +15,7 @@ const String = @import("../zig-string/zig-string.zig").String;
 const Scope = @import("../symbol/scope.zig");
 const Symbol = @import("../symbol/symbol.zig");
 const Token = @import("../lexer/token.zig");
+const Type_Map = @import("../ast/type_map.zig").Type_Map;
 const validation_state_ = @import("../util/validation_state.zig");
 
 pub const AST_Validation_State = validation_state_.Validation_State(*AST);
@@ -508,7 +509,7 @@ pub const AST = union(enum) {
     template: struct {
         common: AST_Common,
         decl: *AST, // The decl of the symbol(s) that is being templated
-        memo: ?*Symbol, // TODO: This should be some sort of map that maps const parameters to stamped-out anonymous function symbols
+        memo: Type_Map(*Symbol),
         _symbol: ?*Symbol = null, // The symbol for this template
     },
     @"defer": struct { common: AST_Common, _statement: *AST },
diff --git a/src/ast/symbol-tree.zig b/src/ast/symbol-tree.zig
index f4206ec9..b8849460 100644
--- a/src/ast/symbol-tree.zig
+++ b/src/ast/symbol-tree.zig
@@ -9,6 +9,7 @@ const String = @import("../zig-string/zig-string.zig").String;
 const Scope = @import("../symbol/scope.zig");
 const Symbol = @import("../symbol/symbol.zig");
 const Token = @import("../lexer/token.zig");
+const Type_Map = @import("../ast/type_map.zig").Type_Map;
 const walk_ = @import("../ast/walker.zig");
 
 scope: *Scope,
@@ -127,7 +128,7 @@ pub fn prefix(self: Self, ast: *ast_.AST) walk_.Error!?Self {
                 ast.* = ast_.AST{ .template = .{
                     .common = common,
                     .decl = template_pattern_fn_decl,
-                    .memo = null,
+                    .memo = Type_Map(*Symbol).init(self.allocator),
                 } };
                 const symbol = try create_template_symbol(ast, self.scope, self.allocator);
                 try self.register_symbol(ast, symbol);
diff --git a/src/semantic/stamp.zig b/src/semantic/stamp.zig
index 40940e48..9e2a594f 100644
--- a/src/semantic/stamp.zig
+++ b/src/semantic/stamp.zig
@@ -6,6 +6,7 @@ const Decorate = @import("../ast/decorate.zig");
 const Decorate_Access = @import("../ast/decorate-access.zig");
 const Span = @import("../util/span.zig");
 const Scope = @import("../symbol/scope.zig");
+const Symbol = @import("../symbol/symbol.zig");
 const scope_validate_ = @import("../semantic/scope_validate.zig");
 const Symbol_Tree = @import("../ast/symbol-tree.zig");
 const Token = @import("../lexer/token.zig");
@@ -23,63 +24,80 @@ pub fn stamp(
     compiler: *Compiler_Context,
 ) !*ast_.AST {
     std.debug.assert(template_ast.* == .template);
-    if (template_ast.template.memo == null) {
-        // Clone out a new fn decl AST, with a new name
-        const fn_decl = template_ast.template.decl.clone(compiler.allocator());
-        fn_decl.fn_decl.remove_const_params();
-        fn_decl.fn_decl.name = null; // make function anonymous
 
-        // Create a new symbol and scope for the new fn decl
-        const fn_symbol = try Symbol_Tree.create_function_symbol(
-            fn_decl,
-            scope,
-            &compiler.errors,
-            compiler.allocator(),
-        );
-        try fn_symbol.scope.put_symbol(fn_symbol, &compiler.errors);
-        fn_decl.set_symbol(fn_symbol);
+    const stamped_symbol = try get_stamp_symbol(template_ast, args, call_span, scope, compiler);
 
-        const domain = Symbol_Tree.extract_domain(template_ast.template.decl.children().*, compiler.allocator());
-        args.* = try args_.default_args(.function, args.*, call_span, domain, &compiler.errors, compiler.allocator());
-        _ = try args_.validate_args_arity(.function, args, domain, false, call_span, &compiler.errors);
+    const identifier = ast_.AST.create_identifier(Token.init_simple(stamped_symbol.name), compiler.allocator());
+    identifier.set_symbol(stamped_symbol);
+    return identifier;
+}
 
-        // Go through each comptime arg, evaluate it, and store it in a list along with it's position
-        // Combines the arg value and the position in the args/params list
-        var const_decls = std.ArrayList(*ast_.AST).init(compiler.allocator());
-        defer const_decls.deinit();
-        for (template_ast.template.decl.fn_decl._params.items, args.items) |param, arg| {
-            if (param.decl.pattern.pattern_symbol.kind == .@"const") {
-                const decl = ast_.AST.create_decl(
-                    param.token(),
-                    param.decl.pattern,
-                    param.decl.type,
-                    arg, // TODO: Comptime eval this
-                    true,
-                    compiler.allocator(),
-                );
-                const_decls.append(decl) catch unreachable;
-            }
-        }
+fn get_stamp_symbol(
+    template_ast: *ast_.AST,
+    args: *std.ArrayList(*ast_.AST),
+    call_span: Span,
+    scope: *Scope,
+    compiler: *Compiler_Context,
+) !*Symbol {
+    const memo_result = template_ast.template.memo.get(args);
+    if (memo_result) |retval| {
+        return retval;
+    }
+
+    const new_scope = Scope.init(scope, scope.uid_gen, compiler.allocator());
+
+    // Clone out a new fn decl AST, with a new name
+    const fn_decl = template_ast.template.decl.clone(compiler.allocator());
+    fn_decl.fn_decl.remove_const_params();
+    fn_decl.fn_decl.name = null; // make function anonymous
+
+    // Create a new symbol and scope for the new fn decl
+    const fn_symbol = try Symbol_Tree.create_function_symbol(
+        fn_decl,
+        new_scope,
+        &compiler.errors,
+        compiler.allocator(),
+    );
+    try fn_symbol.scope.put_symbol(fn_symbol, &compiler.errors);
+    fn_decl.set_symbol(fn_symbol);
 
-        // Define each constant parameter in the fn decl's scope
-        try walker_.walk_asts(&const_decls, Symbol_Tree.new(scope, &compiler.errors, compiler.allocator()));
+    const domain = Symbol_Tree.extract_domain(template_ast.template.decl.children().*, compiler.allocator());
+    args.* = try args_.default_args(.function, args.*, call_span, domain, &compiler.errors, compiler.allocator());
+    _ = try args_.validate_args_arity(.function, args, domain, false, call_span, &compiler.errors);
 
-        // Decorate identifiers, validate
-        const decorate_context = Decorate.new(scope, &compiler.errors, compiler.allocator());
-        const decorate_access_context = Decorate_Access.new(scope, &compiler.errors, compiler);
-        for (const_decls.items) |decl| {
-            try walker_.walk_ast(decl, decorate_context);
-            try walker_.walk_ast(decl, decorate_access_context);
+    // Go through each comptime arg, evaluate it, and store it in a list along with it's position
+    // Combines the arg value and the position in the args/params list
+    var const_decls = std.ArrayList(*ast_.AST).init(compiler.allocator());
+    defer const_decls.deinit();
+    for (template_ast.template.decl.fn_decl._params.items, args.items) |param, arg| {
+        if (param.decl.pattern.pattern_symbol.kind == .@"const") {
+            const decl = ast_.AST.create_decl(
+                param.token(),
+                param.decl.pattern,
+                param.decl.type,
+                arg, // TODO: Comptime eval this
+                true,
+                compiler.allocator(),
+            );
+            const_decls.append(decl) catch unreachable;
         }
-        try walker_.walk_ast(fn_decl, decorate_context);
-        try walker_.walk_ast(fn_decl, decorate_access_context);
-        try scope_validate_.validate(fn_symbol.scope, compiler);
+    }
+
+    // Define each constant parameter in the fn decl's scope
+    try walker_.walk_asts(&const_decls, Symbol_Tree.new(new_scope, &compiler.errors, compiler.allocator()));
 
-        // Memoize symbol
-        template_ast.template.memo = fn_symbol;
+    // Decorate identifiers, validate
+    const decorate_context = Decorate.new(new_scope, &compiler.errors, compiler.allocator());
+    const decorate_access_context = Decorate_Access.new(new_scope, &compiler.errors, compiler);
+    for (const_decls.items) |decl| {
+        try walker_.walk_ast(decl, decorate_context);
+        try walker_.walk_ast(decl, decorate_access_context);
     }
+    try walker_.walk_ast(fn_decl, decorate_context);
+    try walker_.walk_ast(fn_decl, decorate_access_context);
+    try scope_validate_.validate(fn_symbol.scope, compiler);
 
-    const identifier = ast_.AST.create_identifier(Token.init_simple(template_ast.template.memo.?.name), compiler.allocator());
-    identifier.set_symbol(template_ast.template.memo);
-    return identifier;
+    // Memoize symbol
+    template_ast.template.memo.put(args, fn_symbol);
+    return fn_symbol;
 }
